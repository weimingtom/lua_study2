
luaL_prepbuffer
[-0, +0, -] 

char *luaL_prepbuffer (luaL_Buffer *B);
Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see luaL_Buffer). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_prepbuffer
[-0, +0, -] 

char *luaL_prepbuffer (luaL_Buffer *B);
返回尺寸为LUAL_BUFFERSIZE的空间的地址，你能把要被加入缓冲器B的字符串拷贝到其中（见luaL_Buffer）。在把字符串拷贝到该空间中以后，你必须用字符串的尺寸调用luaL_addsize来把它加入缓冲器中。 



--------------------------------------------------------------------------------

luaL_pushresult
[-?, +1, m] 

void luaL_pushresult (luaL_Buffer *B);
Finishes the use of buffer B leaving the final string on the top of the stack. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_pushresult
[-?, +1, m] 

void luaL_pushresult (luaL_Buffer *B);
结束对缓冲器B的使用，把最终字符串留在栈顶。 




--------------------------------------------------------------------------------

luaL_ref
[-1, +0, m] 

int luaL_ref (lua_State *L, int t);
Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object). 

A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object. 

If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_ref
[-1, +0, m] 

int luaL_ref (lua_State *L, int t);
在索引t处的表中为栈顶的对象创建一个引用（reference）并返回（而且弹出该对象）。 

引用是唯一的整数键。只要你不手工向表t中加入整数键，luaL_ref保证它返回的键的唯一性。你可通过调用lua_rawgeti(L, t, r)取回被r引用的对象。函数luaL_unref释放引用及其关联的对象。 

如果栈顶的对象是nil，luaL_ref返回常量LUA_REFNIL。常量LUA_NOREF被确保与luaL_ref返回的任何引用都不同。 


--------------------------------------------------------------------------------

luaL_Reg
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_Reg
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
用于要被luaL_register注册的函数数组的类型。name是函数名，func是函数指针。任何luaL_Reg数组必须以name和func都为NULL的标记项结尾。 



--------------------------------------------------------------------------------

luaL_register
[-(0|1), +1, m] 

void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);
Opens a library. 

When called with libname equal to NULL, it simply registers all functions in the list l (see luaL_Reg) into the table on the top of the stack. 

When called with a non-null libname, luaL_register creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one. 

In any case the function leaves the table on the top of the stack. 


--------------------------------------------------------------------------------
（注：TODO）

luaL_register
[-(0|1), +1, m] 

void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);
打开一个库。 

当以libname等于NULL调用时，它只是注册列表l中的所有函数（见luaL_Reg）到栈顶的表中。 

当以非空的libname调用时，luaL_register创建新表t，把它设为全局变量libname的值，和package.loaded[libname]的值，并把列表l中的所有函数注册到该表。如果package.loaded[libname]中或变量libname中有个表，则重用该表而不是创建一个新的。 

无论如何函数都把表留在栈顶。 


--------------------------------------------------------------------------------

luaL_typename
[-0, +0, -] 

const char *luaL_typename (lua_State *L, int index);
Returns the name of the type of the value at the given index. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_typename
[-0, +0, -] 

const char *luaL_typename (lua_State *L, int index);
返回给定索引处的值的类型名。 


--------------------------------------------------------------------------------

luaL_typerror
[-0, +0, v] 

int luaL_typerror (lua_State *L, int narg, const char *tname);
Generates an error with a message like the following: 

     location: bad argument narg to 'func' (tname expected, got rt)

where location is produced by luaL_where, func is the name of the current function, and rt is the type name of the actual argument. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_typerror
[-0, +0, v] 

int luaL_typerror (lua_State *L, int narg, const char *tname);
用类似下面的消息产生一个错误： 

     location: bad argument narg to 'func' (tname expected, got rt)

其中location由luaL_where产生，func是当前函数名，且rt是实际参数的类型名。 


--------------------------------------------------------------------------------

luaL_unref
[-0, +0, -] 

void luaL_unref (lua_State *L, int t, int ref);
Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again. 

If ref is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_unref
[-0, +0, -] 

void luaL_unref (lua_State *L, int t, int ref);
解除来自索引t处的表的引用ref（见luaL_ref）。该项从表中删除，所以被引用的对象可被回收。引用ref也被释放以备再次使用。 

如果ref是LUA_NOREF或LUA_REFNIL，luaL_unref什么也不做。 


--------------------------------------------------------------------------------

luaL_where
[-0, +1, m] 

void luaL_where (lua_State *L, int lvl);
Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the following format: 

     chunkname:currentline:

Level 0 is the running function, level 1 is the function that called the running function, etc. 

This function is used to build a prefix for error messages. 



--------------------------------------------------------------------------------

luaL_where
[-0, +1, m] 

void luaL_where (lua_State *L, int lvl);
压入一个标识当前在lvl层调用堆栈的控制位置到堆栈中。
特别地这个字符串格式如下：
块名:当前行:
0层是正在运行的函数，1层是调用运行中函数的函数，如此类推。
这个函数用于构建错误信息的前缀。





5 - Standard Libraries
The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., type and getmetatable); others provide access to "outside" services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., table.sort). 

All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries: 


（注：TODO）
5 - 标准库
Lua标准库提供直接通过C API实现的有用的函数。其中一些函数提供语言的核心服务（例如type和getmetatable）；其他的提供对“外”访问服务（例如I/O）；还有一些能用Lua自身实现，但是非常有用或者有关键的性能要求以致需要C实现（例如table.sort）。 

所有库通过官方C API实现并且作为独立的C 模块提供。当前Lua拥有如下标准库： 







basic library, which includes the coroutine sub-library; 
package library; 
string manipulation; 
table manipulation; 
mathematical functions (sin, log, etc.); 
input and output; 
operating system facilities; 
debug facilities. 

基础库，包括协程子库；
包库
字符串操作；
表操作；
数学函数（sin，log等）；
输入和输出；
操作系统工具；
调试工具。



Except for the basic and package libraries, each library provides all its functions as fields of a global table or as methods of its objects. 

To have access to these libraries, the C host program should call the luaL_openlibs function, which opens all standard libraries. Alternatively, it can open them individually by calling luaopen_base (for the basic library), luaopen_package (for the package library), luaopen_string (for the string library), luaopen_table (for the table library), luaopen_math (for the mathematical library), luaopen_io (for the I/O library), luaopen_os (for the Operating System library), and luaopen_debug (for the debug library). These functions are declared in lualib.h and should not be called directly: you must call them like any other Lua C function, e.g., by using lua_call. 


除了基础库和包库以外，每个库都以一个全局表的域或它的对象的方法提供所有函数。
想要拥有这些库的访问权，可以通过调用luaopen_base（对于基础库），luaopen_package（对于包库），luaopen_string（对于字符串），luaopen_table（对于表库），luaopen_math（对于数学库），luaopen_io（对于输入输出库），luaopen_os（对于操作系统库），luaopen_debug（对于调试库）单独地打开它们。这些函数在lualib.h中声明，不应该直接调用：你必须像其他Lua的C函数那样调用它们，例如lua_call。








5.1 - Basic Functions
The basic library provides some core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities. 



--------------------------------------------------------------------------------


5.1 - 基础函数
基础库提供一些Lua的核心函数。
如果你在你的应用程序中不包含这个库，你应该细心检查是否需要提供它的某些工具的实现。

--------------------------------------------------------------------------------



assert (v [, message])
Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to "assertion failed!" 


--------------------------------------------------------------------------------



assert (v [, message])
Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to "assertion failed!" 
当它的参数v的值是false（例如nil或false）时发出错误，否则，返回它所有参数。
message是一个错误信息；如果缺省，则默认为"assertion failed!"

--------------------------------------------------------------------------------

collectgarbage (opt [, arg])
This function is a generic interface to the garbage collector. It performs different functions according to its first argument, opt: 

"stop": stops the garbage collector. 
"restart": restarts the garbage collector. 
"collect": performs a full garbage-collection cycle. 
"count": returns the total memory in use by Lua (in Kbytes). 
"step": performs a garbage-collection step. The step "size" is controlled by arg (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of arg. Returns true if the step finished a collection cycle. 
"setpause": sets arg as the new value for the pause of the collector (see §2.10). Returns the previous value for pause. 
"setstepmul": sets arg as the new value for the step multiplier of the collector (see §2.10). Returns the previous value for step. 

--------------------------------------------------------------------------------

collectgarbage (opt [, arg])
这个函数式一个对于垃圾回收器的通用界面。
它根据第一个参数opt执行不同的函数，包括：

"stop": 停止垃圾回收。 
"restart": 重新启动垃圾回收。
"collect": 执行一个完整的垃圾回收循环。 
"count": 返回Lua使用的总内存(千字节单位). 
"step": 执行一个垃圾回收步长。这个步长“大小”以不确定的方式受arg控制（较大的值意味着加大的步长）。
如果你想控制步长大小你必须试验地调节arg的值。
如果步长完成了一次回收循环则返回true。
"setpause": 设置arg为回收器新的暂停值（参考§2.10）。
返回前一个暂停值。
"setstepmul": 设置arg为回收器步长乘数的新值。
返回前一个步长值。


--------------------------------------------------------------------------------

dofile (filename)
Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode). 


--------------------------------------------------------------------------------

dofile (filename)
打开命名文件，并且把它的内容作为Lua块来执行。
当不带参数调用时，dofile执行标准输入（stdin）的内容。
返回块所返回的所有值。
如果出错，dofile把错误传播给它的调用者（即dofile不在保护模式下运行）。

--------------------------------------------------------------------------------

error (message [, level])
Terminates the last protected function called and returns message as the error message. Function error never returns. 
Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message. 

--------------------------------------------------------------------------------

error (message [, level])
终止被调用的最后一个被保护函数然后返回错误信息message。
函数error从不返回。
通常，error在信息的开头添加一些关于错误位置的信息。
参数level指定如何获得错误位置。
当使用层1（默认）时，错误信息是error被调用的地方。
层2把错误指向调用error的函数所在的地方；如此类推。
传递0层参数以避免添加额外的错误位置信息到message中。

--------------------------------------------------------------------------------

_G
A global variable (not a function) that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice-versa. (Use setfenv to change environments.) 

--------------------------------------------------------------------------------
（注：TODO）

_G
持有全局环境的全局变量（非函数）（即_G._G = _G）。Lua自身并不使用该变量；改变其值不影响任何环境，反之亦然。（使用setfenv来改变环境。） 

--------------------------------------------------------------------------------

getfenv ([f])
Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1. 

--------------------------------------------------------------------------------
（注：TODO）

getfenv ([f])
返回函数的当前环境。f可以是Lua函数或指定调用栈级别的数字：级别1是调用getfenv的函数。如果给出的函数不是Lua函数或者f为0，getfenv返回全局环境。f缺省为1。 



--------------------------------------------------------------------------------

getmetatable (object)
If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a "__metatable" field, returns the associated value. Otherwise, returns the metatable of the given object. 

--------------------------------------------------------------------------------
（注：TODO）

getmetatable (object)
如果object没有元表，返回nil。否则，如果对象的元表具有"__metatable"字段，返回关联的值。否则返回给定对象的元表。 


--------------------------------------------------------------------------------

ipairs (t)
Returns three values: an iterator function, the table t, and 0, so that the construction 

     for i,v in ipairs(t) do body end

will iterate over the pairs (1,t[1]), (2,t[2]), ・・・, up to the first integer key absent from the table. 

--------------------------------------------------------------------------------
（注：TODO）

ipairs (t)
返回三个值：迭代器函数、表t和0，所以结构 

     for i,v in ipairs(t) do body end

将迭代键值对（1,t[1]）、（2,t[2]）、・・・，直到第一个不存在于表中的整数键。 


--------------------------------------------------------------------------------

load (func [, chunkname])
Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results. A return of an empty string, nil, or no value signals the end of the chunk. 

If there are no errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message. The environment of the returned function is the global environment. 

chunkname is used as the chunk name for error messages and debug information. When absent, it defaults to "=(load)". 

--------------------------------------------------------------------------------
（注：TODO）

load (func [, chunkname])
通过用func函数获取代码片的方式载入单元。对func的每次调用必须返回一个与先前的结果串联的字符串。返回空串、nil或无值告知单元结束。 

如果没有错误，将编译的单元作为函数返回；否则返回nil以及错误消息。被返回的函数的环境是全局环境。 

chunkname作为单元名用于错误消息和调试信息。当省略时，缺省委“=(load)”。 


--------------------------------------------------------------------------------

loadfile ([filename])
Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given. 

--------------------------------------------------------------------------------
（注：TODO）

loadfile ([filename])
与load类似，但是从文件filename中获取单元，如果未给出文件名则从标准输入获取。 


--------------------------------------------------------------------------------

loadstring (string [, chunkname])
Similar to load, but gets the chunk from the given string. 

To load and run a given string, use the idiom 

     assert(loadstring(s))()

When absent, chunkname defaults to the given string. 

--------------------------------------------------------------------------------
（注：TODO）

loadstring (string [, chunkname])
与load类似，但是从给定的字符串获得单元。 

要载入并运行给定的字符串，使用惯用法： 

     assert(loadstring(s))()

当省略时，chunkname缺省为给定的字符串。 


--------------------------------------------------------------------------------

next (table [, index])
Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty. 

The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numeric order, use a numerical for or the ipairs function.) 

The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields. 

--------------------------------------------------------------------------------
（注：TODO）

next (table [, index])
允许程序遍历标的所有字段。它的第一参数是表，第二参数是该表中的索引。next返回表的下一个索引及其关联的值。当以nil作为第二参数调用时，next返回初始索引和关联的值。当以最后的索引调用或以nil调用空表时，next返回nil。如果省略第二参数，它被解释为nil。特别地，可用next(t)测试表是否为空。 

索引被列举的顺序是未指定的，即使是数字索引。（要以数字顺序遍历表，使用数字for或ipairs函数。） 

如果在遍历期间给表中不存在的字段赋任意值，则next的行为是未定义的。然而，你可以修改已经存在的字段。特别地，你可以清空已经存在的字段。 


--------------------------------------------------------------------------------

pairs (t)
Returns three values: the next function, the table t, and nil, so that the construction 

     for k,v in pairs(t) do body end

will iterate over all keyCvalue pairs of table t. 

See function next for the caveats of modifying the table during its traversal. 


--------------------------------------------------------------------------------
（注：TODO）

pairs (t)
返回三个值：next函数、表t和nil，所以结构 

     for k,v in pairs(t) do body end

将迭代表t的所有键-值对。 

参阅函数next关于其遍历期间对表修改的警告。 


--------------------------------------------------------------------------------

pcall (f, arg1, ・・・)
Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message. 

--------------------------------------------------------------------------------
（注：TODO）

pcall (f, arg1, ・・・)
用给定参数以保护模式（protected mode）调用函数f。这意味着f内的任何错误都不被传播；代替的做法是，pcall捕获错误并返回一个状态码。它的第一结果是状态码（布尔），如果调用成功无误则为true。在这种情况下，pcall也在第一结果之后返回来自调用的所有结果。在任何错误的情况下，pcall返回false以及错误消息。 


--------------------------------------------------------------------------------

print (・・・)
Receives any number of arguments, and prints their values to stdout, using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format. 

--------------------------------------------------------------------------------
（注：TODO）

print (・・・)
接受任意数量的参数，打印它们的值到标准输出（stdout），方式是利用tostring函数将他们转换为字符串。print不是打算给格式化的输出使用的，而是作为一种快速显示值的方式，特别是对调试。对于格式化的输出，使用string.format。 


--------------------------------------------------------------------------------

rawequal (v1, v2)
Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean. 

--------------------------------------------------------------------------------
（注：TODO）

rawequal (v1, v2)
检查v1与v2是否相等，不会调用任何元方法。返回布尔值。 

--------------------------------------------------------------------------------

rawget (table, index)
Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value. 

--------------------------------------------------------------------------------
（注：TODO）

rawget (table, index)
获取table[index]的实际值，不会调用任何元方法。table必须是个表；index可以是任何值。 


--------------------------------------------------------------------------------

rawset (table, index, value)
Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. 
This function returns table. 

--------------------------------------------------------------------------------
（注：TODO）

rawset (table, index, value)
设置table[index]的实际值为value，不会调用任何元方法。table必须是个表，index可以是任何非nil值，并且value可以是任何Lua值。 
该函数返回表。 


--------------------------------------------------------------------------------

select (index, ・・・)
If index is a number, returns all arguments after argument number index. Otherwise, index must be the string "#", and select returns the total number of extra arguments it received. 

--------------------------------------------------------------------------------

select (index, ・・・)
如果索引是数字，返回在参数数目index后的所有参数。
否则index必须是字符串"#"，select会返回它接收的所有额外参数。

--------------------------------------------------------------------------------

setfenv (f, table)
Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling setfenv. setfenv returns the given function. 

As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values. 

--------------------------------------------------------------------------------
（注：TODO）

setfenv (f, table)
设置给定函数要用的环境。f可以是Lua函数或栈中指定级别的函数：级别1是调用setfenv的函数。setfenv返回给定的函数。 

作为特例，当f为0时setfenv改变当前运行线程的环境。在该情况下，setfenv不返回值。 



--------------------------------------------------------------------------------

setmetatable (table, metatable)
Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a "__metatable" field, raises an error. 

This function returns table. 


--------------------------------------------------------------------------------

setmetatable (table, metatable)
为所给的表设置元表。
（你不可以修改来自Lua的其它类型的元表，只能修改来自C的。）
如果元表为nil，删除所给表的元表。
如果原来的元表拥有"__metatable"域，引发一个错误。
这个函数返回表。

--------------------------------------------------------------------------------

tonumber (e [, base])
Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil. 
An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. In base 10 (the default), the number can have a decimal part, as well as an optional exponent part (see §2.1). In other bases, only unsigned integers are accepted. 

--------------------------------------------------------------------------------
（注：TODO）

tonumber (e [, base])
尝试将参数转换为数字。如果参数已经是数字或可转换为数字的字符串，则tonumber返回该数字；否则返回nil。 
可选参数指定如何解释数字的基数。基数可以是2和36之间的任何整数，也包括它们。在高于10的基数中，字母'A'（大小写皆可）表示10，'B'表示11，依次类推，直到'Z'表示35。在基数为10（缺省）时，数字可有小数部分，也可有可选的指数部分（见§2.1）。其他基数只接受无符号整数。 



--------------------------------------------------------------------------------

tostring (e)
Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format. 
If the metatable of e has a "__tostring" field, then tostring calls the corresponding value with e as argument, and uses the result of the call as its result. 


--------------------------------------------------------------------------------
（注：TODO）

tostring (e)
接受任意类型的参数并以合理的格式将其转换为字符串。对于完全控制数字如何转换，使用string.format。 
如果e的元表有"__tostring"字段，则tostring以e为参数调用相应的值，并用调用的结果为其结果。 


--------------------------------------------------------------------------------

type (v)
Returns the type of its only argument, coded as a string. The possible results of this function are "nil" (a string, not the value nil), "number", "string", "boolean", "table", "function", "thread", and "userdata". 

--------------------------------------------------------------------------------
（注：TODO）

type (v)
返回其仅有参数的类型，编码为一个字符串。该函数的可能结果是"nil"（字符串，不是值nil）、"number"、"string"、"boolean"、"table"、"function"、"thread"和"userdata"。 


--------------------------------------------------------------------------------

unpack (list [, i [, j]])
Returns the elements from the given table. This function is equivalent to 
     return list[i], list[i+1], ・・・, list[j]

except that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator (see §2.5.5). 

--------------------------------------------------------------------------------
（注：TODO）

unpack (list [, i [, j]])
返回给定标的元素。该函数等价于 
     return list[i], list[i+1], ・・・, list[j]

除了上面的代码只能用在元素数量固定的情况。缺省时，i是1而j是列表的长度，就像取长操作符（见§2.5.5）定义的那样。 


--------------------------------------------------------------------------------

_VERSION
A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is "Lua 5.1". 

--------------------------------------------------------------------------------
（注：TODO）

_VERSION
保存含有当前解释器版本的字符串的全局变量（非函数）。该变量的当前内容是“Lua 5.1”。 


--------------------------------------------------------------------------------

xpcall (f, err)
This function is similar to pcall, except that you can set a new error handler. 

xpcall calls function f in protected mode, using err as the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In this case, xpcall also returns all results from the call, after this first result. In case of any error, xpcall returns false plus the result from err. 


--------------------------------------------------------------------------------
（注：TODO）

xpcall (f, err)
该函数类似pcall，除了可以设置新的错误处理器。 

xpcall用err作为错误处理器，在保护模式中调用函数f。f内的错误不被传播；代替做法是，xpcall捕获错误，以原始错误对象调用err函数，并返回一个状态码。它的第一结果是状态码（布尔值），如果调用成功无误则为true。在该情况下，xpcall也在该第一结果后面返回来自调用的所有结果。在错误的情况下，xpcall返回false以及来自err的结果。 








5.2 - Coroutine Manipulation
The operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. See §2.11 for a general description of coroutines. 


（注：TODO）
5.2 - 协程操作
涉及协程的操作由基础库的一个子库组成，并且出现在表coroutine内。关于协程的全面描述见§2.11。 


--------------------------------------------------------------------------------

coroutine.create (f)
Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type "thread". 


--------------------------------------------------------------------------------
（注：TODO）

coroutine.create (f)
用f主体创建一个新协程。f必须是Lua函数。返回该新协程，它是类型为“thread”的对象。 



--------------------------------------------------------------------------------

coroutine.resume (co [, val1, ・・・])
Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ・・・ are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ・・・ are passed as the results from the yield. 

If the coroutine runs without any errors, resume returns true plus any values passed to yield (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, resume returns false plus the error message. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.resume (co [, val1, ・・・])
启动或继续协程co的执行。首次恢复协程时，它启动运行协程主体。值val1, ・・・是传入主体函数的参数。如果协程被中断了，resume重新启动它；值val1, ・・・是从yield传来的结果。 

如果协程运行无误，resume返回true以及传入yield（如果协程中断）的任何值或由主体函数（如果协程结束）返回的任何值。如果有任何错误，resume返回false以及错误消息。 



--------------------------------------------------------------------------------

coroutine.running ()
Returns the running coroutine, or nil when called by the main thread. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.running ()
返回运行的协程，或者当被主线程调用时返回nil。 


--------------------------------------------------------------------------------

coroutine.status (co)
Returns the status of coroutine co, as a string: "running", if the coroutine is running (that is, it called status); "suspended", if the coroutine is suspended in a call to yield, or if it has not started running yet; "normal" if the coroutine is active but not running (that is, it has resumed another coroutine); and "dead" if the coroutine has finished its body function, or if it has stopped with an error. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.status (co)
返回协程co的状态，以字符串的方式：如果协程正在运行（即是它调用了status）则为“running”；如果协程被yield调用暂停或还未启动运行则为“suspended”；如果协程是活动的但不在运行中（即它恢复了另一个协程）则为“normal”；如果协程结束了它的主体函数或出错停止则为"dead"。 



--------------------------------------------------------------------------------

coroutine.wrap (f)
Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.wrap (f)
用f主体创建一个新协程。f必须是Lua函数。返回一个函数，每次调用它会恢复协程。传入该函数的任何参数都作为resume的额外参数。返回值同resume相同，除了第一个布尔值。在发生错误情况下传播错误。 


--------------------------------------------------------------------------------

coroutine.yield (・・・)
Suspends the execution of the calling coroutine. The coroutine cannot be running a C function, a metamethod, or an iterator. Any arguments to yield are passed as extra results to resume. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.yield (・・・)
暂停调用者协程的执行。协程不能正在运行C函数、元方法或迭代器。yield的任何参数被传为resume的结果。 





5.3 - Modules
The package library provides basic facilities for loading and building modules in Lua. It exports two of its functions directly in the global environment: require and module. Everything else is exported in a table package. 


（注：TODO）

5.3 - 模块
打包库为在Lua中加载和创建模块提供基础设备。它直接导出两个函数到全局环境中：require和module。其他东西都导出到表package中。 



--------------------------------------------------------------------------------

module (name [, ・・・])
Creates a module. If there is a table in package.loaded[name], this table is the module. Otherwise, if there is a global table t with the given name, this table is the module. Otherwise creates a new table t and sets it as the value of the global name and the value of package.loaded[name]. This function also initializes t._NAME with the given name, t._M with the module (t itself), and t._PACKAGE with the package name (the full module name minus last component; see below). Finally, module sets t as the new environment of the current function and the new value of package.loaded[name], so that require returns t. 

If name is a compound name (that is, one with components separated by dots), module creates (or reuses, if they already exist) tables for each component. For instance, if name is a.b.c, then module stores the module table in field c of field b of global a. 

This function can receive optional options after the module name, where each option is a function to be applied over the module. 

--------------------------------------------------------------------------------
（注：TODO）

module (name [, ・・・])
创建一个模块。如果在package.loaded[name]中有个表，该表就是模块。否则，如果有个给定名字的全局表t，该表就是模块。否则创建新表t并把它设为全局name和package.loaded[name]的值。该函数也用给定的名字初始化t._NAME，用模块（t自身）设置t._M，并用包名设置t._PACKAGE（完整模块名减去最后部分；见下）。最后，module设置t为当前函数的新环境和package.loaded[name]的新值，因此require返回t。 

如果name是个复合名字（即用点号分隔的几个部分），module为每个部分创建（或重用，如果它们已经存在）表。例如，如果name是a.b.c，则module在全局a的字段b的字段c中存储模块表。 

该函数可接受模块名后可选的options，其中每个选项是要加入模块的函数。 


--------------------------------------------------------------------------------

require (modname)
Loads the given module. The function starts by looking into the package.loaded table to determine whether modname is already loaded. If it is, then require returns the value stored at package.loaded[modname]. Otherwise, it tries to find a loader for the module. 

To find a loader, require is guided by the package.loaders array. By changing this array, we can change how require looks for a module. The following explanation is based on the default configuration for package.loaders. 

First require queries package.preload[modname]. If it has a value, this value (which should be a function) is the loader. Otherwise require searches for a Lua loader using the path stored in package.path. If that also fails, it searches for a C loader using the path stored in package.cpath. If that also fails, it tries an all-in-one loader (see package.loaders). 

Once a loader is found, require calls the loader with a single argument, modname. If the loader returns any value, require assigns the returned value to package.loaded[modname]. If the loader returns no value and has not assigned any value to package.loaded[modname], then require assigns true to this entry. In any case, require returns the final value of package.loaded[modname]. 

If there is any error loading or running the module, or if it cannot find any loader for the module, then require signals an error. 

--------------------------------------------------------------------------------
（注：TODO）

require (modname)
加载给定模块。该函数先浏览表package.loaded确认modname是否已经加载了。如果是，require返回存储在package.loaded[modname]中的值。否则，它尝试为模块找到一个加载器（loader）。 

数组package.loaders指示require如何寻找加载器。通过改变该数组，我们可以改变require如何寻找模块。下面的解释基于package.loaders的缺省配置。 

require首先查询package.preload[modname]。如果它有值，该值（应是个函数）就是加载器。否则require使用存储在package.path中的路径搜索一个Lua加载器。如果那也失败了，它用存储在package.cpath中的路径搜索一个C加载器。如果也失败了，它尝试一个一体化（all-in-one）加载器（见package.loaders）。 

一旦找到，require用单个参数modname调用这个加载器。如果加载器返回任何值，require把返回值赋给package.loaded[modname]。如果加载器不返回值而且没有赋给package.loaded[modname]任何值，require把true赋给该条目。在任何情况下，require返回package.loaded[modname]的最终值。 

如果加载或运行模块时发生任何错误，或者如果不能为模块找到任何加载器，require导致一个错误。 




--------------------------------------------------------------------------------

package.cpath
The path used by require to search for a C loader. 

Lua initializes the C path package.cpath in the same way it initializes the Lua path package.path, using the environment variable LUA_CPATH or a default path defined in luaconf.h. 

--------------------------------------------------------------------------------
（注：TODO）

package.cpath
该路径被require用于搜索一个C加载器。 

Lua用同初始化Lua路径package.path一样的方式初始化C路径package.cpath，利用环境变量LUA_CPATH或一个定义在luaconf.h中的缺省路径。 


--------------------------------------------------------------------------------

package.loaded
A table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there. 

--------------------------------------------------------------------------------
（注：TODO）

package.loaded
被require用来控制已经加载了哪些模块。当你require一个模块modname而且package.loaded[modname]不为假时，require只是返回存储在那儿的值。 


--------------------------------------------------------------------------------

package.loaders
A table used by require to control how to load modules. 

Each entry in this table is a searcher function. When looking for a module, require calls each of these searchers in ascending order, with the module name (the argument given to require) as its sole parameter. The function can return another function (the module loader) or a string explaining why it did not find that module (or nil if it has nothing to say). Lua initializes this table with four functions. 

The first searcher simply looks for a loader in the package.preload table. 

The second searcher looks for a loader as a Lua library, using the path stored at package.path. A path is a sequence of templates separated by semicolons. For each template, the searcher will change each interrogation mark in the template by filename, which is the module name with each dot replaced by a "directory separator" (such as "/" in Unix); then it will try to open the resulting file name. So, for instance, if the Lua path is the string 

     "./?.lua;./?.lc;/usr/local/?/init.lua"

the search for a Lua file for module foo will try to open the files ./foo.lua, ./foo.lc, and /usr/local/foo/init.lua, in that order. 

The third searcher looks for a loader as a C library, using the path given by the variable package.cpath. For instance, if the C path is the string 

     "./?.so;./?.dll;/usr/local/?/init.so"

the searcher for module foo will try to open the files ./foo.so, ./foo.dll, and /usr/local/foo/init.so, in that order. Once it finds a C library, this searcher first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside the library to be used as the loader. The name of this C function is the string "luaopen_" concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is a.v1-b.c, the function name will be luaopen_b_c. 

The fourth searcher tries an all-in-one loader. It searches the C path for a library for the root name of the given module. For instance, when requiring a.b.c, it will search for a C library for a. If found, it looks into it for an open function for the submodule; in our example, that would be luaopen_a_b_c. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function. 


--------------------------------------------------------------------------------
（注：TODO）

package.loaders
被require用来控制如何加载模块的表。 

该表的每个条目是个搜索器函数（searcher function）。当查找模块时，require按照升序逐个调用这些搜索器，并用模块名（传给require的参数）作为它的唯一参数。该函数可返回另一个函数（模块加载器）或一条解释为何没找到模块的字符串（或nil，如果没话可说）。Lua用四个函数初始化该表。 

第一个搜索器只是在表package.preload中查找加载器。 

第二个搜索器（把模块）作为Lua库使用存储于package.path中的路径查找加载器。路径是由分号分隔的一系列模板（template）。对每个模板，搜索器将模板中的每个问号改为filename，后者是模块名，它的每个点号都被替换为“目录分隔符（directory separator）”（例如Unix中的/）；然后它将尝试打开合成的文件名。因此，例如，如果Lua路径是字符串 

     "./?.lua;./?.lc;/usr/local/?/init.lua"

对模块foo的Lua文件的搜索将尝试按顺序打开文件./foo.lua、./foo.lc和/usr/local/foo/init.lua。 

第三个搜索器（把模块）作为C库用变量package.cpath给出的路径查找加载器。例如，如果C路径是字符串 

     "./?.so;./?.dll;/usr/local/?/init.so"

对模块foo的搜索将尝试按顺序打开文件./foo.so、./foo.dll和/usr/local/foo/init.so。一旦找到C库，该搜索器首先用动态链接设备链接应用和库。然后尝试在库内查找一个将用作加载器的C函数。该C函数的名字是“luaopen_”同模块名的拷贝连接得到的字符串，模块名的每个点号被下划线替换。此外，如果模块名有个连字符，它的直到（并且包括）第一个连字符的前缀被移除。例如，如果模块名是a.v1-b.c，函数名将是luaopen_b_c。 

第四个搜索器尝试一个一体化加载器。它在C路径中为给定模块的根名搜索库。例如，当请求a.b.c时，它将为a搜索C库。如果找到了，在其中为子模块查找打开函数；在我们的例子中是luaopen_a_b_c。利用该设备，包可以将若干C子模块打包在单个库中，其中的每个子模块持有自己的原始打开函数。 



--------------------------------------------------------------------------------

package.loadlib (libname, funcname)
Dynamically links the host program with the C library libname. Inside this library, looks for a function funcname and returns this function as a C function. (So, funcname must follow the protocol (see lua_CFunction)). 

This is a low-level function. It completely bypasses the package and module system. Unlike require, it does not perform any path searching and does not automatically adds extensions. libname must be the complete file name of the C library, including if necessary a path and extension. funcname must be the exact name exported by the C library (which may depend on the C compiler and linker used). 

This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard). 

--------------------------------------------------------------------------------
（注：TODO）

package.loadlib (libname, funcname)
把C库libname动态链接到宿主程序。在库内查找函数funcname并作为C函数返回。（所以，funcname必须遵循协议（见lua_CFunction））。 

这是个低级函数。它完全绕过包和模块系统。不像require，它不执行任何陆路径搜索也不会自动地增加扩展名。libname必须是C库的完全文件名，如果需要还包括路径和扩展名。funcname必须是确切的C库导出的名字（依赖C编译器和链接器）。 

该函数不被ANSI C支持。同样，它只在某些平台可用（Windows、Linux、Mac OS X、Solaris、BSD，以及支持dlfcn标准的其他Unix系统）。 



--------------------------------------------------------------------------------

package.path
The path used by require to search for a Lua loader. 

At start-up, Lua initializes this variable with the value of the environment variable LUA_PATH or with a default path defined in luaconf.h, if the environment variable is not defined. Any ";;" in the value of the environment variable is replaced by the default path. 


--------------------------------------------------------------------------------
（注：TODO）

package.path
该路径被require用来搜索一个Lua加载器。 

Lua在启动时用环境变量LUA_PATH的值初始化该变量，或者如果该环境变量未定义则用定义在luaconf.h中的缺省路径。环境变量的值中的任何“;;”都被替换为缺省路径。 



--------------------------------------------------------------------------------

package.preload
A table to store loaders for specific modules (see require). 

--------------------------------------------------------------------------------
（注：TODO）

package.preload
用于特定模块存储加载器的表。（见require）。 


--------------------------------------------------------------------------------

package.seeall (module)
Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function module. 

--------------------------------------------------------------------------------
（注：TODO）

package.seeall (module)
为module设置元表，其__index字段引用全局变量，所以该模块继承全局变量的值。将要被用作函数module的一个选项。 







