<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>Lua 5.1 参考手册</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<link rel="stylesheet" type="text/css" href="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/"><img src="logo.gif" alt="" border="0"></a>
Lua 5.1 参考手册
</h1>

由Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes编写
<p>
<small>
版权归属 &copy; 2006-2008 Lua.org, PUC-Rio。
可在<a href="http://www.lua.org/license.html#5">Lua 许可</a>的条款下自由使用。
</small>
<hr>
<p>

<a href="contents.html#contents">目录</A>
&middot;
<a href="contents.html#index">索引</A>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.48 2008/08/18 15:24:20 roberto Exp $ -->

<h1>1 - <a name="1">介绍</a></h1>

<p>
Lua是种带有数据描述设备的扩展式程序设计语言，被设计用于支持常规过程式程序设计。也很好地支持面向对象，函数式以及数据驱动的程序设计。Lua作为强大、轻量的脚本语言，可供任何需要的程序使用。Lua被实现为使用<em>纯净</em>的C（即ANSI&nbsp;C和C++共有的子集）编写的库。

<p>
作为扩展式语言，Lua没有“main”程序的概念：它只能<em>嵌入</em>一个宿主程序运行——称为<em>嵌套程序</em>或简称为<em>宿主</em>。该宿主程序通过调用函数能够执行一段Lua代码，读写Lua变量，以及注册为Lua代码所用的C函数。C函数扩充了Lua的应用领域，使它可以处理不同的领域，如此则创建了定制的程序语言，而它们共享同一个语法框架。Lua分发包带有一个称为<code>lua</code>的示例宿主程序，它利用Lua库提供了完整、独立的Lua解释器。

<p>
Lua是自由软件，并且根据使用许可不提供任何担保。本手册描述的实现可在Lua官方网站<code>www.lua.org</code>找到。

<p>
跟任何其他的参考手册一样，本文档有些地方比较枯燥。Lua网站提供的技术论文探讨了Lua背后的设计决定。对于Lua程序设计方面的详细入门指导，可参阅Roberto的书<em>Lua程序设计（第二版）</em>。

<h1>2 - <a name="2">语言</a></h1>

<p>
本节描述Lua的词法、语法和语义。换句话说，本节描述了哪些记号（token）是有效的，它们可以怎样组合，以及组合的含义。

<p>
语言的构成概念将用常见的扩展的BNF记法（notation）进行说明，其中{<em>a</em>}&nbsp;表示&nbsp;0或多个<em>a</em>，[<em>a</em>]&nbsp;表示一个可选的<em>a</em>。非最终符号（non-terminal）原样显示，关键字显示似<b>kword</b>，其他最终符号（terminal symbols）显示似`<b>=</b>´。Lua的完整语法放在本手册最后的<a href="#8">&sect;8</a>。

<h2>2.1 - <a name="2.1">词法约定</a></h2>

<p>
Lua中的<em>名称</em>（也称为<em>标识符（identifier）</em>）是非数字开头的字母、数字和下划线构成的任何字符串。这与多数语言的名称定义相符。（字母的定义依赖于当前环境，其中的字母表中的任何字符都可用于标识符。）标识符用于命名变量和表的字段。

<p>
下面的<em>关键字</em>是保留的，不能用作名字：

<pre>
     and       break     do        else      elseif
     end       false     for       function  if
     in        local     nil       not       or
     repeat    return    then      true      until     while
</pre>

<p>
Lua是大小写敏感的语言：<code>and</code>是保留字，但<code>And</code>和<code>AND</code>是不同的合法名字。通常约定，以下划线开头后跟大写字母（如<a href="#pdf-_VERSION"><code>_VERSION</code></a>）的名字被Lua留作内部全局变量。

<p>
下面的字符串表示其他的记号：

<pre>
     +     -     *     /     %     ^     #
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>字面（literal）字符串</em>可用单引号或双引号定界，而且可包含下面C风格的转义序列：
<pre>
'<code>\a</code>' （响铃）
'<code>\b</code>' （退格）
'<code>\f</code>' （换页）
'<code>\n</code>' （换行）
'<code>\r</code>' （回车）
'<code>\t</code>' （横向制表符）
'<code>\v</code>' （纵向制表符）
'<code>\\</code>' （反斜线）
'<code>\"</code>' （双引号）
'<code>\'</code>' （单引号）
</pre>
此外，反斜线后跟真正的换行符会实际在字符串中插入一个换行符。在字符串中，也能利用转义序列<code>\<em>ddd</em></code>通过字符的数字值指定它，此处的<em>ddd</em>是最多3位的十进制数字序列。（注意，如果数字转义后面必须紧接着一个数字，必须严格地使用3个数字表示。）Lua中的字符串可以包含任意8位值，包括由‘<code>\0</code>’指定的内嵌的0。

<p>
字面字符串也能通过一种用<em>长括号</em>括起来长格式进行定义。我们把在2个开方括号中间插入<em>n</em>个等号的符号定义为<em>n级开长括号</em>。所以，0级开长括号记为<code>[[</code>，1级开长括号记为<code>[=[</code>，依次类推。<em>闭长括号</em>的定义类似；例如，4级闭长括号记为<code>]====]</code>。一个以任意级别开长括号开头的长字符串结束于第一个同级闭长括号。这种形式中的字面值可以跨越多行，不解释任何转义序列，并且忽略任何其他级别的长括号。除了合适级别的闭括号，无所不包。

<p>
出于方便性的考虑，当开长括号后面直接跟着一个换行时，该换行被忽略。举个例子，在使用ASCII的系统（其中‘<code>a</code>’被编码为97，换行是10，‘<code>1</code>’是49）中，下面的5个字面字符串表示相同的字符串：

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>数字常量</em>可被写成带有可选的小数部分和可选的十进制指数部分。Lua也接受十六进制整数常量，只需前缀<code>0x</code>。合法的数字常量的例子是

<pre>
     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56
</pre>

<p>
<em>注释</em>可在字符串外的任何地方以两个连字符（<code>--</code>）开始。
如果<code>--</code>直接后跟的文本不是开长括号，它就是<em>短注释</em>，到行尾结束。否则就是<em>长注释</em>，它直到相应的闭长括号结束。长注释常用于临时屏蔽代码。

<h2>2.2 - <a name="2.2">值与类型</a></h2>

<p>
Lua种<em>动态类型语言</em>。这表明变量没有类型；只有值才有。语言中不存在类型定义。所有值自带类型信息。

<p>
Lua中的所有值都是<em>一等（first-class）的值</em>。这表示所有值都能存于变量中，作为参数传入函数，以及作为结果返回。

<p>
Lua中有8中基本类型：<em>nil</em>，<em>boolean</em>，<em>number</em>，<em>string</em>，<em>function</em>，<em>userdata</em>，<em>thread</em>和<em>table</em>。
<em>Nil</em>是值<b>nil</b>的类型，该值的主要性质是与其他的所有值都不同；常用于表示一个无意义的值。<em>Boolean</em>是值<b>false</b>和<b>true</b>的类型。<b>nil</b>和<b>false</b>都使条件为假；任何其他值得到真。<em>Number</em>表现实数（双精度浮点数）。（很容易使用数值的其他内部表示形式，如单精度浮点数或长整型，构建Lua解释器，参考文件<code>luaconf.h</code>。）<em>String</em>表示字符数组。Lua使用完全的8位：字符串可含有任何8位字符，包括内嵌的0（‘<code>\0</code>’）（见<a href="#2.1">&sect;2.1</a>）。

<p>
Lua能调用（以及操作）用Lua和C写的函数（见<a href="#2.5.8">&sect;2.5.8</a>）。

<p>
类型<em>userdata</em>允许在Lua变量中存储任意的C数据。该类型对应一块原始内存，除了赋值和一致性判断，没有预定义的Lua操作。然而，通过使用<em>metatables</em>，程序员可以为用户数据值定义各种操作（见<a href="#2.8">&sect;2.8</a>）。
在Lua中不能创建或修改用户数据，只能通过C API。这样确保宿主程序持有的数据的完整性。

<p>
类型<em>thread</em>表示独立的执行线程，并且被用于实现协同例程（coroutine，见<a href="#2.11">&sect;2.11</a>）。不要把Lua线程同操作系统的线程搞混了。所有系统上的Lua都支持协程，甚至是不支持线程的系统。

<p>
类型<em>table</em>实现了关联数组，不只是数字，任何值都可以做索引（除了<b>nil</b>）。表可为<em>异质的</em>；即可以包含所有类型（除了<b>nil</b>）的值。表是Lua中唯一一种提供数据结构的机制；它们可用来表现普通的数组、符号表、集合、记录、图、树，等等。Lua用字段名作为索引可表现记录。在语言层面通过提供<code>a.name</code>作为<code>a["name"]</code>的语法糖来支持这种表现形式（记录）。有多种便利的方式在Lua中创建表（见<a href="#2.5.7">&sect;2.5.7</a>）。

<p>
跟索引一样，表字段的值可为任意类型（除了<b>nil</b>）。特别是，由于函数是一等值，表字段可含有函数。由此表也可支持<em>方法</em>（见<a href="#2.5.9">&sect;2.5.9</a>）。

<p>
表、函数、线程和（完整的）用户数据的值是<em>对象</em>：变量并不实际<em>持有</em>这些值，只是<em>引用</em>这些值。赋值、传参和函数返回总是操作对这些值的引用；这些操作不包含任何性质的拷贝。

<p>
库函数<a href="#pdf-type"><code>type</code></a>返回描述给定值的类型的字符串。

<h3>2.2.1 - <a name="2.2.1">强制转换</a></h3>

<p>
Lua提供运行时字符串和数字值间的自动转换。将数学运算符用于字符串会尝试依照通常的转换规则将该字符串转为数字。反过来，当把数字用在期望字符串的地方时，数字以合理的格式被转为字符串。要完全控制数字到字符串的转换，使用字符串库德<code>format</code>函数（见<a href="#pdf-string.format"><code>string.format</code></a>）。

<h2>2.3 - <a name="2.3">变量</a></h2>

<p>
变量是存储值的地方。Lua中有3种变量：全局变量、局部变量和表字段。

<p>
单个名字可表示全局变量或局部变量（或函数的形式参数，它是一种特殊的局部变量）：

<pre>
	var ::= Name
</pre><p>
Name表示<a href="#2.1">&sect;2.1</a>中定义的标识符。

<p>
如果未明确地声明为局部的（见<a href="#2.4.7">&sect;2.4.7</a>），任何变量都假定为全局的。局部变量具有<em>词法作用域（lexically scoped）</em>：局部变量可被定义于它们所在作用域内的函数自由访问（见<a href="#2.6">&sect;2.6</a>）。

<p>
在首次赋值以前，变量的职为<b>nil</b>。

<p>
方括号被用于索引一个标：

<pre>
	var ::= prefixexp `<b>[</b>&acute; exp `<b>]</b>&acute;
</pre><p>
对全局变量和表字段的访问的含义可通过元表（metatable）进行改变。对索引的变量<code>t[i]</code>的访问等价于调用<code>gettable_event(t,i)</code>。（函数<code>gettable_event</code>的完整描述见<a href="#2.8">&sect;2.8</a>。在Lua中该函数并不存在或不可访问。我们这儿用它只作说明的目的。）

<p>
语法<code>var.Name</code>仅仅是<code>var["Name"]</code>的语法糖：

<pre>
	var ::= prefixexp `<b>.</b>&acute; Name
</pre>

<p>
所有全局变量都作为字段存在于一个普通的Lua表中，称为<em>环境表</em>或简称<em>环境</em>（见<a href="#2.9">&sect;2.9</a>）。每个函数都有个引用指向某个环境，所以此函数内的所有全局变量都将引用该环境表。创建一个函数时，它从创建它的函数继承了环境。调用<a href="#pdf-getfenv"><code>getfenv</code></a>可得到Lua函数的环境表。调用<a href="#pdf-setfenv"><code>setfenv</code></a>可替换它。（你只能通过调试库来操作C函数的环境；见<a href="#5.9">&sect;5.9</a>）

<p>
访问全局变量<code>x</code>等价于<code>_env.x</code>，后者又等价于

<pre>
     gettable_event(_env, "x")
</pre><p>
这里的<code>_env</code>是当前运行的函数的环境。（函数<code>gettable_event</code>的完整描述见<a href="#2.8">&sect;2.8</a>。在Lua中该函数并不存在或不可访问。同样地，变量<code>_env</code>也未在Lua中定义。我们这儿用它们只作说明的目的。）

<h2>2.4 - <a name="2.4">语句</a></h2>

<p>
Lua支持语句的常规集，类似于Pascal或C。该集包括赋值、控制结构、函数调用和变量声明。

<h3>2.4.1 - <a name="2.4.1">（语句）单元（chunk）</a></h3>

<p>
Lua的执行单元（unit）称为<em>单元（chunk）</em>。一个单元只是一系列的语句，它们被顺序执行。每条语句可随意地以一个分号结束：

<pre>
	chunk ::= {stat [`<b>;</b>&acute;]}
</pre><p>
不允许空语句，因而‘<code>;;</code>’不合法。

<p>
Lua将单元视为带不定参数的匿名函数进行处理（见<a href="#2.5.9">&sect;2.5.9</a>）。正因如此，单元可定义局部变量、接收参数以及返回值。

<p>
单元可以存储在一个文件中或者存在于宿主程序的一个字符串中。要执行一个单元，Lua首先把它预编译为虚拟机中的指令，然后用虚拟机的解释器执行编译后的代码。

<p>
单元也可被预编译为二进制形式；细节参考程序<code>luac</code>。源码中的程序和编译后的形式可交换的；Lua自动检测文件类型进而作相应地处理。

<h3>2.4.2 - <a name="2.4.2">（语句）块（block）</a></h3><p>
语句块（block）是一系列语句；从语法上讲，语句块同单元一样：

<pre>
	block ::= chunk
</pre>

<p>
语句块可被显式地分隔以产生单条语句：

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
显式的语句块有助于控制变量声明的作用预。有时显式的语句块也用于在另一个语句块中加入<b>return</b>或<b>break</b>语句（见<a href="#2.4.4">&sect;2.4.4</a>）。

<h3>2.4.3 - <a name="2.4.3">赋值</a></h3>

<p>
Lua允许多重赋值。因此，赋值的语法定义为左边一系列变量和右边一系列表达式。两个系列中的元素都用逗号分隔：

<pre>
	stat ::= varlist `<b>=</b>&acute; explist
	varlist ::= var {`<b>,</b>&acute; var}
	explist ::= exp {`<b>,</b>&acute; exp}
</pre><p>
表达式在<a href="#2.5">&sect;2.5</a>中讨论。

<p>
赋值以前，值列表被<em>调整</em>匹配变量列表的长度。如果值比需要的多，多出的值被丢弃。如果值比需要的少，就用适当数量的<b>nil</b>扩展值列表。如果表达式列表以一个函数调用结束，那么调整之前那个调用所返回的所有值都进入值列表（除非该调用被括在圆括号中；见<a href="#2.5">&sect;2.5</a>）。

<p>
赋值语句首先计算它的所有表达式，然后才会执行赋值操作。因此代码

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
设置<code>a[3]</code>为20，而不影响<code>a[4]</code>，因为<code>a[i]</code>中的<code>i</code>在它被赋值为4之前被计算（为3）。同样地，代码行

<pre>
     x, y = y, x
</pre><p>
交换<code>x</code>和<code>y</code>的值，

<pre>
     x, y, z = y, z, x
</pre><p>
循环置换<code>x</code>、<code>y</code>和<code>z</code>的值。

<p>
向全局变量和表字段赋值的含义可通过元表被改变。向索引的变量<code>t[i] = val</code>赋值等价于<code>settable_event(t,i,val)</code>。（函数<code>settable_event</code>的完整说明见<a href="#2.8">&sect;2.8</a>。在Lua中该函数并不存在或不可访问。我们这儿用它只作说明的目的。）

<p>
向全局变量<code>x = val</code>赋值等价于赋值<code>_env.x = val</code>，后者又等价于

<pre>
     settable_event(_env, "x", val)
</pre><p>
此处<code>_env</code>是当前运行函数的环境。（在Lua中未定义变量<code>_env</code>。我们这儿用它只作说明的目的。）

<h3>2.4.4 - <a name="2.4.4">控制结构</a></h3><p>
控制结构<b>if</b>，<b>while</b>和<b>repeat</b>具有通常的含义和相似的语法：

<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua也有<b>for</b>语句，它有两种风格（见<a href="#2.4.5">&sect;2.4.5</a>）。

<p>
控制结构的条件表达式可能返回任何值。<b>false</b>和<b>nil</b>都作为假。所有不同于<b>nil</b>和<b>false</b>的值作为真（特别要注意，数字0和空字符串也是真）。

<p>
在<b>repeat</b>&ndash;<b>until</b>循环中，内部代码块并非截止于<b>until</b>关键字，而是在条件之后。所以，条件也能引用在循环体中声明的本地变量。

<p>
<b>return</b>语句用来从函数或单元（其实也是函数）中返回一些值。

函数和单元可以返回多个值，因此<b>return</b>语句的语法是

<pre>
	stat ::= <b>return</b> [explist]
</pre>

<p>
<b>break</b>语句用于终止<b>while</b>，<b>repeat</b>或<b>for</b>循环的执行，跳到循环之后的下一条语句：

<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b>终止最内层的循环。

<p>
<b>return</b>和<b>break</b>语句只能写作代码块的最后一条<em>last</em>语句。如果确实需要在代码块中部<b>return</b>或<b>break</b>，可以用<code>do return end</code>和<code>do break end</code>这种方式显式地加入内部代码块，这样<b>return</b>和<b>break</b>就是他们的（内部）代码块中的最后一条语句了。

<h3>2.4.5 - <a name="2.4.5">For 语句</a></h3>

<p>

<b>for</b>语句有两种形式：数字形式和一般形式。

<p>
数字形式的<b>for</b>循环随着控制变量在算术级数（等差级数，arithmetic progression）中移动，重复执行一块代码。语法如下：

<pre>
	stat ::= <b>for</b> Name `<b>=</b>&acute; exp `<b>,</b>&acute; exp [`<b>,</b>&acute; exp] <b>do</b> block <b>end</b>
</pre><p>
当<em>name</em>从第一个<em>exp</em>的值开始，直到它以第三个<em>exp</em>为步长通过第二个<em>exp</em>为止，<em>block</em>被重复执行。更确切地说，<b>for</b>语句类似

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
等价于代码：

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       while (<em>step</em> &gt; 0 and <em>var</em> &lt;= <em>limit</em>) or (<em>step</em> &lt;= 0 and <em>var</em> &gt;= <em>limit</em>) do
         local v = <em>var</em>
         <em>block</em>
         <em>var</em> = <em>var</em> + <em>step</em>
       end
     end
</pre><p>
注意事项如下：

<ul>

<li>
三个控制变量都只在循环开始前计算一次。它们都必须得到数字值。
</li>

<li>
<code><em>var</em></code>，<code><em>limit</em></code>和<code><em>step</em></code>是不可见变量。此处显示的名字只为方便说明。
</li>

<li>
如果省略第三个表达式（步长），则步长为1。
</li>

<li>
你可用<b>break</b>退出<b>for</b>循环。
</li>

<li>
循环变量<code>v</code>是循环局部的；不能在<b>for</b>结束或被打断之后使用。如果需要该值，可在打断或退出循环之前赋给另一个变量。
</li>

</ul>

<p>
一般形式的<b>for</b>语句重复检查称为<em>迭代器（iterator）</em>的函数。每次迭代，调用迭代器函数以产生一个新值，如该值为<b>nil</b>则停止。一般形式的<b>for</b>循环语法如下：

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {`<b>,</b>&acute; Name}
</pre><p>
<b>for</b>语句类似

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
等价于代码：

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         <em>var</em> = <em>var_1</em>
         if <em>var</em> == nil then break end
         <em>block</em>
       end
     end
</pre><p>
注意下列事项：

<ul>

<li>
<code><em>explist</em></code>只计算一次。其结果是一个<em>迭代器</em>函数、一个<em>状态机（state）</em>，以及第一个<em>迭代器变量（iterator variable）</em>的初始值。
</li>

<li>
<code><em>f</em></code>，<code><em>s</em></code>，和<code><em>var</em></code>是不可见变量。此处的名字只为方便说明。
</li>

<li>
可用<b>break</b>退出<b>for</b>循环。
</li>

<li>
循环变量<code><em>var_i</em></code>是循环局部的；<b>for</b>结束后不可使用。如果需要它们，在打断或退出循环之前把它们赋给其他的变量。
</li>

</ul>

<h3>2.4.6 - <a name="2.4.6">函数调用语句</a></h3><p>
为了允许使用可能的副作用，函数调用可作为语句执行：

<pre>
	stat ::= functioncall
</pre><p>
此时所有的返回值被丢弃。函数调用在<a href="#2.5.8">&sect;2.5.8</a>中解释。

<h3>2.4.7 - <a name="2.4.7">局部声明</a></h3><p>
可在代码块内部的任何位置声明局部变量。声明时可赋初值：

<pre>
	stat ::= <b>local</b> namelist [`<b>=</b>&acute; explist]
</pre><p>
如果存在，赋初值同样有多重赋值的语义（见<a href="#2.4.3">&sect;2.4.3</a>）。否则，所有变量初始化为<b>nil</b>。

<p>
单元也是代码块（见<a href="#2.4.1">&sect;2.4.1</a>），因此可在任何显式的代码块外面声明局部变量。这种局部变量的作用域延伸到单元末尾。

<p>
局部变量的可见性规则在<a href="#2.6">&sect;2.6</a>中说明。

<h2>2.5 - <a name="2.5">表达式</a></h2>

<p>
下面是Lua中的基础表达式：

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Number
	exp ::= String
	exp ::= function
	exp ::= tableconstructor
	exp ::= `<b>...</b>&acute;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | `<b>(</b>&acute; exp `<b>)</b>&acute;
</pre>

<p>
数值和字面字符串见<a href="#2.1">&sect;2.1</a>；变量见<a href="#2.3">&sect;2.3</a>；函数定义见<a href="#2.5.9">&sect;2.5.9</a>；函数调用见<a href="#2.5.8">&sect;2.5.8</a>；表构造器见<a href="#2.5.7">&sect;2.5.7</a>。可变参数（vararg）表达式，由三个点表示（‘<code>...</code>’），只能直接用在可变参数的函数中；它们在<a href="#2.5.9">&sect;2.5.9</a>中解释。

<p>
二元操作符包括算术运算操作符（见<a href="#2.5.1">&sect;2.5.1</a>）、关系操作符（见<a href="#2.5.2">&sect;2.5.2</a>）、逻辑操作符（见<a href="#2.5.3">&sect;2.5.3</a>）和连接符（见<a href="#2.5.4">&sect;2.5.4</a>）。一元操作符包括负号（见<a href="#2.5.1">&sect;2.5.1</a>）、<b>取反（not）</b>（见<a href="#2.5.3">&sect;2.5.3</a>）和<em>取长操作符（length operator）</em>（见<a href="#2.5.5">&sect;2.5.5</a>）。

<p>
函数调用和可变参数表达式都可产生多个值。如果表达式被用作语句（只能是函数调用（见<a href="#2.4.6">&sect;2.4.6</a>）），其返回列表被调整为0各元素，从而丢弃所有返回值。如果表达式用于表达式列表的最后（或是仅有的），就不做调整（除非该调用被括在圆括号中）。在所有其他情形中，Lua将结果列表调整为一个元素，除第一个之外所有值都被忽略。

<p>
看一些例子：

<pre>
     f()                -- 调整为0个结果
     g(f(), x)          -- f()被调整为1个结果
     g(x, f())          -- g得到x及来自f()的所有结果
     a,b,c = f(), x     -- f()被调整为1个结果（c为nil）
     a,b = ...          -- a得到第一个可变参数，b得到第二个
                        -- （如果没有相应的可变参数，a和b都为nil）
     
     a,b,c = x, f()     -- f()被调整为2个结果
     a,b,c = f()        -- f()被调整为3个结果
     return f()         -- 返回f()的所有结果
     return ...         -- 返回收到的所有可变参数
     return x,y,f()     -- 返回x，y和f()的所有结果
     {f()}              -- 用f()的所有结果创建列表
     {...}              -- 用所有可变参数创建列表
     {f(), nil}         -- f()被调整为1个结果
</pre>

<p>
括在圆括号中的任何表达式总是只产生一个值。因此，<code>(f(x,y,z))</code>总是单个值，即使<code>f</code>返回多个值。（<code>(f(x,y,z))</code>的值是<code>f</code>返回的第一个值或<b>nil</b>——如果<code>f</code>无返回值。）

<h3>2.5.1 - <a name="2.5.1">数学运算操作符</a></h3><p>
Lua支持常用的数学运算操作符：二元<code>+</code>（加），<code>-</code>（减），<code>*</code>（乘），<code>/</code>（除），<code>%</code>（取模）和<code>^</code>（求幂）；以及一元<code>-</code>（负号）。如果操作数是数值或可转为数值的字符串（见<a href="#2.2.1">&sect;2.2.1</a>），所有操作都是常规含义。求幂可用于任何指数。例如，<code>x^(-0.5)</code>计算<code>x</code>的平方根的倒数。取模定义为

<pre>
     a % b == a - math.floor(a/b)*b
</pre><p>
就是说，它是商被朝向负无穷大取整的除法的余数。

<h3>2.5.2 - <a name="2.5.2">关系操作符</a></h3><p>
Lua中的关系操作符有

<pre>
     ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</pre><p>
这些操作符总是得到<b>false</b>或<b>true</b>。

<p>
相等（<code>==</code>）首先比较操作数的类型。类型不同则结果为<b>false</b>。否则比较操作数的值。数值和字符串进行常规比较。对象（表，用户数据，线程和函数）比较<em>引用（reference）</em>：引用<em>同一个</em>对象才是相等。每次创建的新对象（表，用户数据，线程或函数）都与任何之前存在的对象不同。

<p>
可通过“eq”元方法改变表和用户数据的比较方式（见<a href="#2.8">&sect;2.8</a>）。

<p>
<a href="#2.2.1">&sect;2.2.1</a>的转换规则<em>不会</em>用到相等比较上。因此<code>"0"==0</code>求值为<b>false</b>，并且<code>t[0]</code>和<code>t["0"]</code>表示表中的不同条目。

<p>
操作符<code>~=</code>恰好是相等（<code>==</code>）的反值。

<p>
顺序（比较）操作按如下方式进行。数值比较自身。字符串根据当前环境比较它们的值。否则，Lua尝试调用“lt”或“le”元方法（见<a href="#2.8">&sect;2.8</a>）。对<code>a &gt; b</code>比较被转换为<code>b &lt; a</code>，<code>a &gt;= b</code>比较被转换为<code>b &lt;= a</code>。

<h3>2.5.3 - <a name="2.5.3">逻辑操作符</a></h3><p>
Lua中的逻辑操作符有<b>and</b>、<b>or</b>和<b>not</b>。同控制结构（见<a href="#2.4.4">&sect;2.4.4</a>）一样，所有逻辑操作符把<b>false</b>和<b>nil</b>作为假，其他所有的都为真。

<p>
取反操作符<b>not</b>总返回<b>false</b>或<b>true</b>。如果首参为<b>false</b>或<b>nil</b>，与操作符<b>and</b>返回它，否则返回第二个参数。如果首参不是<b>nil</b>或<b>false</b>，或操作符<b>or</b>返回它，否则返回第二个参数。<b>and</b>和<b>or</b>都是用捷径求值法；即，只在需要时对第二个操作数求值。看些例子：

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
（在本手册中，<code>--&gt;</code> 指出前面表达式的结果。）

<h3>2.5.4 - <a name="2.5.4">连接符</a></h3><p>
Lua中的字符串连接符用两个点（“<code>..</code>”）表示。对于字符串或数字，根据<a href="#2.2.1">&sect;2.2.1</a>中提到的规则转换为字符串。否则调用“concat”元方法。（见<a href="#2.8">&sect;2.8</a>）。

<h3>2.5.5 - <a name="2.5.5">取长操作符</a></h3>

<p>
取长操作符用一元操作符取长操作符<code>#</code>表示。字符串的长度是其字节数（即常规含义，一个字符为一个字节时的字符串长度）。

<p>
表<code>t</code>的长度定义为任何整数索引<code>n</code>，使得<code>t[n]</code>非<b>nil</b>且<code>t[n+1]</code>为<b>nil</b>；此外，如果<code>t[1]</code>为<b>nil</b>，<code>n</code>可为0。对于从1到给定的<code>n</code>都非空（non-nil）的常规数组，其长度就是末值的索引<code>n</code>。如果数组带有“空穴”（即其他非空值间的<b>nil</b>值），则<code>#t</code>可为任何<b>nil</b>值的直接前项（就是说，它可能把任何<b>nil</b>值作为数组的结束）。

<h3>2.5.6 - <a name="2.5.6">优先级</a></h3><p>
Lua中的操作符优先级遵循下表的顺序，由低到高：

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     ..
     +     -
     *     /     %
     not   #     - (unary)
     ^
</pre><p>
通常可用圆括号改变表达式的优先级。连接（“<code>..</code>”）和求幂（“<code>^</code>”）操作符是右结合的。所有其他二元操作符是左结合的。

<h3>2.5.7 - <a name="2.5.7">表构造器</a></h3><p>
表构造器是创建表的表达式。每次求值一个构造器都创建新表。构造器能用于创建空表或创建表并初始化一些字段。构造器的一般语法是

<pre>
	tableconstructor ::= `<b>{</b>&acute; [fieldlist] `<b>}</b>&acute;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= `<b>[</b>&acute; exp `<b>]</b>&acute; `<b>=</b>&acute; exp | Name `<b>=</b>&acute; exp | exp
	fieldsep ::= `<b>,</b>&acute; | `<b>;</b>&acute;
</pre>

<p>
每个形如<code>[exp1] = exp2</code>的域向新表中增加一项，其键值为<code>exp1</code>并且值为<code>exp2</code>。形如<code>name = exp</code>的域等价于<code>["name"] = exp</code>。最后，形如<code>exp</code>的域等价于<code>[i] = exp</code>，此处的<code>i</code>是从1开始的连续整数。其他形式的域不影响计数。举个例子，

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
等价于

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>
如果列表的最后一个域形如<code>exp</code>而且该表达式是函数调用或可变参数，则该表达式的所有返回值连续地加入列表（见<a href="#2.5.8">&sect;2.5.8</a>）。要避免这样，用圆括号把函数调用或可变参数表达式括起来（见<a href="#2.5">&sect;2.5</a>）。

<p>
域列表最后可带分隔符，这对机器生成的代码很方便。

<h3>2.5.8 - <a name="2.5.8">函数调用</a></h3><p>
Lua中的函数调用语法如下：

<pre>
	functioncall ::= prefixexp args
</pre><p>
函数调用时，首先对prefixexp和args求值。如果prefixexp的值是<em>function</em>类型，则用给定的参数调用该函数。否则调用prefixexp的元方法“call”，并以prefixexp的值为第一个参数，后跟原始调用参数（见<a href="#2.8">&sect;2.8</a>）。

<p>
形如

<pre>
	functioncall ::= prefixexp `<b>:</b>&acute; Name args
</pre><p>
可用于调用“方法”。一个<code>v:name(<em>args</em>)</code>调用是<code>v.name(v,<em>args</em>)</code>的语法糖，不同的是<code>v</code>只求值一次。

<p>
参数语法如下：

<pre>
	args ::= `<b>(</b>&acute; [explist] `<b>)</b>&acute;
	args ::= tableconstructor
	args ::= String
</pre><p>
所有参数表达式在调用前求值。形如<code>f{<em>fields</em>}</code>的调用是<code>f({<em>fields</em>})</code>的语法糖；此处参数列表是单个新建的表。形如<code>f'<em>string</em>'</code>（或<code>f"<em>string</em>"</code>或<code>f[[<em>string</em>]]</code>）的调用是<code>f('<em>string</em>')</code>的语法糖；此处参数列表示单个字面字符串。

<p>
Lua的语法格式很自由，但有个例外，你不能在函数调用的<code>(</code>之前断行。这个限制避免了语言的一些歧义。如果你编写

<pre>
     a = f
     (g).x(a)
</pre><p>
Lua会把它看作单条语句<code>a = f(g).x(a)</code>。所以，如果你要的是两条语句，必须在他们之间加个分号。如果你想要调用<code>f</code>，必须去掉<code>(g)</code>之前的断行。

<p>
形如<code>return</code> <em>functioncall</em>的调用称为<em>尾调用（tail call）</em>。Lua实现了<em>适当的尾调用（proper tail call）</em>（或者说<em>适当的尾递归（recursion）</em>）：在尾调用中，被调用函数重用调用者函数的栈项。因此，程序可执行的嵌套尾调用的数量是没有限制的。然而，尾调用擦除了调用者函数的调试信息。注意，尾调用需要特别的语法，<b>return</b>用单个寒暑调用作为参数；这种语法使得调用者函数严格地返回被调用函数的结果。所以，下面的例子都不是尾调用：

<pre>
     return (f(x))        -- 结果调整为1个
     return 2 * f(x)
     return x, f(x)       -- 额外的结果
     f(x); return         -- 丢弃结果
     return x or f(x)     -- 结果调整为1个
</pre>

<h3>2.5.9 - <a name="2.5.9">函数定义</a></h3>

<p>
函数定义的语法是

<pre>
	function ::= <b>function</b> funcbody
	funcbody ::= `<b>(</b>&acute; [parlist] `<b>)</b>&acute; block <b>end</b>
</pre>

<p>
下面是简化函数定义的语法糖：

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {`<b>.</b>&acute; Name} [`<b>:</b>&acute; Name]
</pre><p>
语句

<pre>
     function f () <em>body</em> end
</pre><p>
转换为

<pre>
     f = function () <em>body</em> end
</pre><p>
语句

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
转换为

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
语句

<pre>
     local function f () <em>body</em> end
</pre><p>
转换为

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
<em>而不是</em>

<pre>
     local f = function () <em>body</em> end
</pre><p>
（当函数体内含有对<code>f</code>的引用时才有区别。）

<p>
函数定义是个可执行的表达式，其值为<em>function</em>类型。Lua预编译单元时也会预编译它的所有函数体。因而Lua执行函数定义时，函数被<em>实例化（instantiate）</em>（或<em>闭合，close</em>）。该函数实例（或<em>闭包，closure</em>）是表达式的终值。相同函数的不同实例可引用不同的外部局部变量，并且可具有不同的环境表。

<p>
形参是由实参初始化的局部变量：

<pre>
	parlist ::= namelist [`<b>,</b>&acute; `<b>...</b>&acute;] | `<b>...</b>&acute;
</pre><p>
当函数被调用时，除了<em>可变参数函数（vararg function）</em>——由形参列表最后的三个点（“<code>...</code>”）表示，实参列表被调整为形参列表的长度。可变参数函数不会调整其实参列表；而是收集所有额外的实参并通过<em>可变参数表达式（vararg expression）</em>——也写为三个点提供给函数。该表达式的值同带多个结果的函数一样，是所有额外实参的列表。如果可变参数表达式被用于其他表达式内部或者表达式列表的中间，它的返回列表被调整为一个元素。如果该表达式用于表达式列表的最后一个元素则不做调整（除非末尾的表达式被括在圆括号中）。

<p>
作为例子，考虑下面的定义：

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
然后，我们有下列从实参到形参和可变参数表达式的映射：

<pre>
     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
结果使用<b>return</b>语句返回（见<a href="#2.4.4">&sect;2.4.4</a>）。如果控制流到达函数结尾而没遇到<b>return</b>语句，则函数不返回结果。

<p>
<em>冒号</em>语法用于定义<em>方法（method）</em>，就是说函数有个隐式的额外形参<code>self</code>。因此，语句

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
是下面写法的语法糖：

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>

<h2>2.6 - <a name="2.6">可见性规则</a></h2>

<p>
Lua是种有词法作用域的语言。变量的作用域从声明<em>后面</em>的第一条语句开始，直到包含声明的最内层代码块的结尾。考虑下面的例子：

<pre>
     x = 10                -- 全局变量
     do                    -- 新代码块
       local x = x         -- 新“x”，值为10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一个代码块
         local x = x+1     -- 另一个“x”
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10（全局的）
</pre>

<p>
注意，在类似<code>local x = x</code>的声明中，新声明的<code>x</code>还不在作用域中，所以第二个<code>x</code> 引用外部的变量。

<p>
根据词法作用域规则，局部变量可被定义于它们作用域内的函数自由访问。被内部函数使用的局部变量在该函数内被称为<em>upvalue</em>或<em>外部局部变量（external local variable）</em>。

<p>
注意，每次执行<b>local</b>语句会定义新局部变量。考虑下面的例子：

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
循环内创建了十个闭包（即匿名函数的十个闭包）。每个闭包使用不同的<code>y</code>变量，然而它们共享同一个<code>x</code>。

<h2>2.7 - <a name="2.7">错误处理</a></h2>

<p>
因为Lua是种嵌入式扩展语言，其所有的操作都是从宿主程序中的C代码调用Lua库函数（见<a href="#lua_pcall"><code>lua_pcall</code></a>）开始的。Lua编译或执行时值要发生错误，控制权就会交还给C，后者可以采取适当的措施（比如打印错误消息）。

<p>
Lua代码可以通过调用函数<a href="#pdf-error"><code>error</code></a>显式地产生错误。如果需要在Lua中捕获错误，可用<a href="#pdf-pcall"><code>pcall</code></a>函数。

<h2>2.8 - <a name="2.8">元表（Metatable）</a></h2>

<p>
Lua中每个值都可具有<em>元表</em>。
<em>元表</em>是普通的Lua表，定义了原始值在某些特定操作下的行为。你可通过在值的原表中设置特定的字段来改变作用于该值的操作的某些行为特征。例如，当数字值作为加法的操作数时，Lua检查其元表中的<code>"__add"</code>字段是否有个函数。如果有，Lua调用它执行加法。

<p>
我们称元表中的键为<em>事件（event）</em>，称值为<em>元方法（metamethod）</em>。前述例子中的事件是<code>"add"</code>，元方法是执行加法的函数。

<p>
可透过函数<a href="#pdf-getmetatable"><code>getmetatable</code></a>查询任何值的元表。

<p>
可透过函数<a href="#pdf-setmetatable"><code>setmetatable</code></a>替换表的元表。不能从Lua中改变其他类型的元表（除了利用调试库）；必须使用C API才能做到。

<p>
表和完整的用户数据具有独立的元表（尽管多个表和用户数据可共享元表）。每种其他类型的所有值共享一个元表；即所有数字共享一个元表，字符串等也是。

<p>
元表控制对象的数学运算、顺序比较、连接、取长、和索引操作的行为。元表也能定义用户数据被垃圾收集时调用的函数。Lua给这些操作的每一个都关联了称为<em>事件</em>的特定键。当Lua对某值执行其中一个操作时，检查该值是否含有元表以及相应的事件。如果有，与该键关联的值（元方法）控制Lua如何完成操作。

<p>
元表控制后面列举的操作。每个操作由相应的名字标识。每个操作的键是由其名字前缀两个下划线“<code>__</code>”的字符串；例如，操作“加（add）”的键是字符串<code>"__add"</code>。这些操作的语义通过一个Lua函数描述解释器如何执行操作作了更好的说明。

<p>
下面显示的Lua代码只是说明性的；真实的行为被硬编码到解释器中，并且比这里的模拟更加高效。这些描述中的所有函数（<a href="#pdf-rawget"><code>rawget</code></a>、<a href="#pdf-tonumber"><code>tonumber</code></a>等等。）在<a href="#5.1">&sect;5.1</a>中描述。特别一提，要获取给定对象的元方法，我们使用表达式

<pre>
     metatable(obj)[event]
</pre><p>
它应被解读为

<pre>
     rawget(getmetatable(obj) or {}, event)
</pre><p>

就是说，访问一个元方法不会调用其他元方法，而且访问没有元表的对象不会失败（只是结果为<b>nil</b>）。

<ul>

<li><b>"add":</b> <code>+</code> 操作。

<p>
下面的<code>getbinhandler</code>函数定义Lua如何选择二元操作的处理程序。首先尝试第一操作数，如果它的类型没有定义该操作的处理程序，则尝试第二操作数。

<pre>
     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
</pre><p>
通过应用该函数，<code>op1 + op2</code>的行为是

<pre>
     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- 两操作数都是数字？
         return o1 + o2   -- ‘+’此处是‘add’的原语
       else  -- 至少一个操作数不是数字
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- 用两个操作数调用处理程序
           return (h(op1, op2))
         else  -- 没有可用的处理程序：缺省行为
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"sub":</b> <code>-</code> 操作。

行为类似于“add”操作。
</li>

<li><b>"mul":</b> <code>*</code> 操作。

行为类似于“add”操作。
</li>

<li><b>"div":</b> <code>/</code> 操作。

行为类似于“add”操作。
</li>

<li><b>"mod":</b> <code>%</code> 操作。

行为类似于“add”操作。以<code>o1 - floor(o1/o2)*o2</code>为操作原语。
</li>

<li><b>"pow":</b> <code>^</code> （取幂）操作。

行为类似于“add”操作，以函数<code>pow</code>（来自C数学库）为操作原语。
</li>

<li><b>"unm":</b> 一元<code>-</code>操作。

<pre>
     function unm_event (op)
       local o = tonumber(op)
       if o then  -- 操作数是数字？
         return -o  -- ‘-’此处是‘unm’的原语
       else  -- 操作数不是数字
         -- 尝试由操作数取得处理程序。
         local h = metatable(op).__unm
         if h then
           -- 用操作数调用处理程序
           return (h(op))
         else  -- 没有可用的处理程序：缺省行为
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"concat":</b> <code>..</code> （连接）操作。

<pre>
     function concat_event (op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- 字符串连接原语
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"len":</b> <code>#</code> 操作。

<pre>
     function len_event (op)
       if type(op) == "string" then
         return strlen(op)         -- 取字符串长度原语
       elseif type(op) == "table" then
         return #op                -- 取表长度原语
       else
         local h = metatable(op).__len
         if h then
           -- 用操作数调用处理程序
           return (h(op))
         else  -- 没有可用的处理程序：缺省行为
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
表长度的描述见<a href="#2.5.5">&sect;2.5.5</a>。
</li>

<li><b>"eq":</b> <code>==</code> 操作。

函数<code>getcomphandler</code>定义Lua如何选择比较操作符的元方法。只有待比较的两个对象类型和选定操作对应的元方法都相同，才会选择该元方法。

<pre>
     function getcomphandler (op1, op2, event)
       if type(op1) ~= type(op2) then return nil end
       local mm1 = metatable(op1)[event]
       local mm2 = metatable(op2)[event]
       if mm1 == mm2 then return mm1 else return nil end
     end
</pre><p>
“eq”事件定义如下：

<pre>
     function eq_event (op1, op2)
       if type(op1) ~= type(op2) then  -- 类型不同？
         return false   -- 对象不同
       end
       if op1 == op2 then   -- 相等原语？
         return true   -- 对象相同
       end
       -- 尝试元方法
       local h = getcomphandler(op1, op2, "__eq")
       if h then
         return (h(op1, op2))
       else
         return false
       end
     end
</pre><p>
<code>a ~= b</code>等价于<code>not (a == b)</code>。
</li>

<li><b>"lt":</b> <code>&lt;</code> 操作。

<pre>
     function lt_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt; op2   -- 数字比较
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt; op2   -- 词典顺序比较
       else
         local h = getcomphandler(op1, op2, "__lt")
         if h then
           return (h(op1, op2))
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
<code>a &gt; b</code>等价于<code>b &lt; a</code>。
</li>

<li><b>"le":</b> <code>&lt;=</code> 操作。

<pre>
     function le_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt;= op2   -- 数字比较
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt;= op2   -- 词典顺序比较
       else
         local h = getcomphandler(op1, op2, "__le")
         if h then
           return (h(op1, op2))
         else
           h = getcomphandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(&middot;&middot;&middot;)
           end
         end
       end
     end
</pre><p>
<code>a &gt;= b</code>等价于 <code>b &lt;= a</code>。注意，假定<code>a &lt;= b</code>等价于<code>not (b &lt; a)</code>，那么当没有“le”元方法时，Lua尝试“lt”。
</li>

<li><b>"index":</b> 索引访问<code>table[key]</code>。

<pre>
     function gettable_event (table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         return (h(table, key))     -- 调用处理程序
       else return h[key]           -- 对它重复上述操作
       end
     end
</pre><p>
</li>

<li><b>"newindex":</b> 索引赋值<code>table[key] = value</code>。

<pre>
     function settable_event (table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         h(table, key,value)           -- 调用处理程序
       else h[key] = value             -- 对它重复上述操作
       end
     end
</pre><p>
</li>

<li><b>"call":</b> 当Lua调用值时被调用。

<pre>
     function function_event (func, ...)
       if type(func) == "function" then
         return func(...)   -- 调用原语
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

</ul>

<h2>2.9 - <a name="2.9">环境</a></h2>

<p>
除了元表，线程、函数和用户数据类型的对象拥有与它们关联的其他表，称为它们<em>环境（environment）</em>。同元表一样，环境是常规表，而且多个对象可以共享同一环境。

<p>
被创建的线程共享创建者线程的环境。被创建的用户数据和C函数共享创建者C函数的环境。被创建的非嵌套的Lua函数（由<a href="#pdf-loadfile"><code>loadfile</code></a>、<a href="#pdf-loadstring"><code>loadstring</code></a>或<a href="#pdf-load"><code>load</code></a>创建）共享创建者线程的环境。被创建的嵌套的Lua函数共享创建者Lua函数的环境。

<p>
对Lua来说，与用户数据关联的环境没有意义。它只是为了方便程序员把表关联到用户数据的方便特性。

<p>
同线程关联的环境称为<em>全局环境（global environments）</em>。它们被用作由线程创建的线程和非嵌套的Lua函数的缺省环境，而且可为C代码直接访问（见<a href="#3.3">&sect;3.3</a>）。

<p>
与C函数关联的环境能被C代码直接访问（见<a href="#3.3">&sect;3.3</a>）。它被用作由其创建的其他C函数和用户数据的缺省环境。

<p>
同Lua函数关联的环境被用来解决函数内所有对全局变量的访问（见<a href="#2.3">&sect;2.3</a>）。它们被用作由其创建的嵌套的Lua函数的缺省环境。

<p>
可调用<a href="#pdf-setfenv"><code>setfenv</code></a>来改变Lua函数或当前运行的线程的环境。可调用<a href="#pdf-getfenv"><code>getfenv</code></a>获取Lua函数或当前运行的线程的环境。要操作其他对象的环境（用户数据、C函数、其他线程），必须使用C API。

<h2>2.10 - <a name="2.10">垃圾收集</a></h2>

<p>
Lua提供自动内存管理。这表示你无需担心新对象的内存分配以及当对象不再需要时的释放工作。Lua通过运行有时运行的<em>垃圾收集器（garbage collector）</em>收集所有的<em>死掉的对象</em>（即不能从Lua中访问的对象）来自动地管理内存。Lua用到的所有内存都被自动管理：表、用户数据、函数、线程、字符串，等等。

<p>
Lua实现了增量标记清除（mark-and-sweep）收集器。它用两个数字控制垃圾收集周期：<em>garbage-collector pause</em>和<em>garbage-collector step multiplier</em>。二者都用百分比点数作为单位（所以值100表示内部的值1）。

<p>
garbage-collector pause控制收集器在启动新一轮周期前等待多久。数值越大，收集器的活性越低。小于100意味着收集器在启动新周期前不会等待。值为200意味着收集器等已用内存总量翻倍时启动新周期。

<p>
step multiplier控制收集器对内存分配的相对速度。数值越大，收集器的活性越高，同时也增大了每步增量的尺寸。小于100的值使得收集器太慢并且可导致周期无法完成。缺省值200意味着收集器以内存分配的二倍速运行。

<p>
可调用C中的<a href="#lua_gc"><code>lua_gc</code></a>或Lua中的<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>改变这些数值。这些函数也能直接控制（比如停止和重启）收集器。

<h3>2.10.1 - <a name="2.10.1">垃圾收集元方法</a></h3>

<p>
可用C API为用户数据设置垃圾收集器元方法（见<a href="#2.8">&sect;2.8</a>）。这些元方法也称为<em>析构器（finalizer）</em>。析构器允许你协调Lua的垃圾收集和外部资源管理（比如关闭文件、网络或数据库连接，或释放你自己的内存）。

<p>
元表中带有<code>__gc</code>字段的无用用户数据不会被垃圾收集器立刻回收。代替的做法是，Lua将它们放进一个列表。回收之后，Lua对列表中的每个用户数据执行下面函数的等价操作：

<pre>
     function gc_event (udata)
       local h = metatable(udata).__gc
       if h then
         h(udata)
       end
     end
</pre>

<p>
在垃圾收集周期的最后，本周期收集的用户数据的析构器以它们创建的<em>反序</em>被调用。就是说，程序中最后创建的用户数据关联的析构器被第一个调用。用户数据本身只在下一次垃圾收集周期释放。

<h3>2.10.2 - <a name="2.10.2">弱引用表（Weak）</a></h3>

<p>
<em>弱引用表（Weak）</em>的元素都是<em>弱引用（weak reference）</em>。弱引用被垃圾收集器忽略（认为是无用的）。换句话说，如果某对象仅有的引用是弱引用，垃圾收集器会回收该对象。

<p>
弱引用表可能具有弱引用键、弱引用值或二者都有。具有弱引用键的表允许对其键的回收，但会阻止对其值进行回收。键和值都是弱引用的表允许对二者的回收。无论键或值被回收，整个键值对从表中移除。表的弱引用性由其元表的<code>__mode</code>字段控制。如果该字段是个包含‘<code>k</code>’的字符串，表中的键是弱引用的。如果含有‘<code>v</code>’，值是弱引用的。

<p>
把某个表用作元表后就不能修改其<code>__mode</code>字段的值了。否则，该元表控制的表的弱引用行为就是未定义的。

<h2>2.11 - <a name="2.11">协同例程（Coroutine）</a></h2>

<p>
Lua支持协同例程，也称为<em>协同式多线程（collaborative multithreading）</em>。Lua中的协程描绘对立的执行线程。不同于多线程系统中的线程，协程只能通过显式地调用中断（yield）函数暂停自身的执行。

<p>
调用<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>创建一个协程。它的唯一参数是协程的主函数。函数<code>create</code>只是创建一个新协程并返回指向它（<em>thread</em>类型的对象）的句柄；它并没启动协程执行。

<p>
首次调用<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>并传入由<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>返回的线程作为第一参数时，协程在其主函数的第一行启动运行。传入<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>的额外参数被传入协程的主函数。协程启动运行后会一直运行直到结束或<em>中断</em>.

<p>
协程有两种方式结束它的运行：正常的，当它的主函数返回（显式或隐式地，在最后指令之后）时；非正常的，发生未预防的错误。第一种情况下，<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>返回<b>true</b>，以及协程主函数返回的任何值。发生错误的情况下，<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>返回<b>false</b>以及一条错误消息。

<p>
协程通过调用<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>中断。当协程中断时，相应的<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>立刻返回，即使中断发生在嵌套的函数调用内部（即不在主函数中，而是主函数直接或间接调用的函数中）。中断的情况下，<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>也返回<b>true</b>，以及传入<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>的任何值。下次恢复同样的协程，它从被中断处继续运行，同时对<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>的调用返回的任何额外值作为参数传入<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>。

<p>
同<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>一样，函数<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>也创建一个协程，但是它返回一个恢复协程的函数而不是协程本身。传入该函数的任何参数成为<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>的额外参数。除了第一个（错误代码布尔值），<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>返回的值<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>也都返回。与<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>不同的是，<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>不会捕获错误；任何错误都被传播到调用者。

<p>
作为一个例子，考虑下面的代码：

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
            
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
运行时它会产生下面的输出：

<pre>
     co-body 1       10
     foo     2
     
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<h1>3 - <a name="3">应用编程接口</a></h1>

<p>
本节描述用于Lua的C API，即可用于宿主程序和Lua通信的C函数集合。所有API函数和相关的类型和常量在头文件<a name="pdf-lua.h"><code>lua.h</code></a>中声明。

<p>
即使当我们使用术语“函数”时，API中的任何设备可能改为宏提供。所有这些宏严格地只使用它们的每个参数一次（除了第一参数，它总是个Lua状态机），因此不要产生任何隐藏的副作用（side-effects）。

<p>
同多数C库一样，Lua API函数不会检查它们的参数的合法性和可靠性。可是，你可通过为文件<code>luaconf.h</code>中的宏<a name="pdf-luai_apicheck"><code>luai_apicheck</code></a>使用适当的定义编译Lua来改变这种行为。

<h2>3.1 - <a name="3.1">栈</a></h2>

<p>
Lua用一个<em>虚拟栈（virtual stack）</em>向或从C传值。该栈中的每个元素表示一个Lua值（<b>nil</b>、数字、字符串，等等）。

<p>
无论何时Lua调用C，被调用函数得到一个新栈，它与以前的栈和一直活动的C函数的栈都无关。该栈最初包含传入C函数的任何参数，并且它也是C函数压入要被返回到调用者的结果的地方（见<a href="#lua_CFunction"><code>lua_CFunction</code></a>）。

<p>
为了方便的目的，API中的多数查询操作并不遵循严格的栈规范。而是通过使用<em>index</em>可引用栈中的任何元素：正数索引表示<em>绝对的</em>栈位置（从1开始）；负数索引表示相对于栈顶的<em>偏移</em>。更明确地说，如果栈有<em>n</em>个元素，则索引1表示第一个元素（即第一个压入栈的元素），索引<em>n</em>表示最后的元素；索引-1也表示最后的元素（即栈顶的元素），索引<em>-n</em>表示第一个元素。如果索引处于1和栈顶之间（就是说如果<code>1 &le; abs(index) &le; top</code>）我们说它是<em>有效的</em>。
 

<h2>3.2 - <a name="3.2">栈尺寸</a></h2>

<p>
当你同Lua API交互时，你有责任确保可靠性。特别地，<em>你有责任控制栈溢出</em>。你可用函数<a href="#lua_checkstack"><code>lua_checkstack</code></a>增长栈尺寸。

<p>
无论何时Lua调用C，它确保至少<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>栈位置是可用的。<code>LUA_MINSTACK</code>被定义为20，所以通常不需要担心栈空间，除非你的代码循环将元素压栈。

<p>
多数查询函数接受的索引为可用的栈空间内的任何值，即一直到你通过<a href="#lua_checkstack"><code>lua_checkstack</code></a>设置的最大栈尺寸。
这样的索引称为<em>认可的索引</em>。<em>认可的索引</em>更正式地定义如下：

<pre>
     (index &lt; 0 &amp;&amp; abs(index) &lt;= top) ||
     (index &gt; 0 &amp;&amp; index &lt;= stackspace)
</pre><p>
注意0决不是认可的索引。

<h2>3.3 - <a name="3.3">伪索引</a></h2>

<p>
除非另有说明，任何接受有效索引的函数也能用<em>伪索引</em>调用，它们表示C代码可访问但是并不在栈中的某些Lua值。伪索引用于访问线程环境、函数环境、注册表和C函数的upvalue（见<a href="#3.4">&sect;3.4</a>）。

<p>
线程环境（其中存在全局变量）总是在伪索引<a name="pdf-LUA_GLOBALSINDEX"><code>LUA_GLOBALSINDEX</code></a>处。正运行的C函数的环境总在伪索引<a name="pdf-LUA_ENVIRONINDEX"><code>LUA_ENVIRONINDEX</code></a>处。

<p>
要访问和改变全局变量的值，你可在环境表上使用常规的表操作。例如，要访问一个全局变量的值，执行

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, varname);
</pre>

<h2>3.4 - <a name="3.4">C闭包</a></h2>

<p>
当一个C函数被创建时，它可能关联了一些值，这样创建了一个<em>C闭包</em>；这些值称为<em>upvalue</em>，并且不论何时调用，它们对函数都是可访问的（见<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>）。

<p>
只要一个C函数被调用，其upvalue就被定位在特定的伪索引处。这些伪索引由宏<a name="lua_upvalueindex"><code>lua_upvalueindex</code></a>产生。关联到函数的第一个值在位置<code>lua_upvalueindex(1)</code>处，依次类推。任何访问<code>lua_upvalueindex(<em>n</em>)</code>，其中<em>n</em>大于当前函数的upvalue的数量（但不大于256），产生一个可接受（但无效）的索引。

<h2>3.5 - <a name="3.5">注册表</a></h2>

<p>
Lua提供一个<em>registry</em>，它是个预定义表，可被任何C代码用来存储它需要存储的任何Lua值。该表总是定位于伪索引<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>处。任何C库都能存储数据到该表中，但是它应该小心地选择不同于其他库用到的键，以避免冲突。典型地，你应该在你的代码中使用含有你的库名的字符串或带有C对象地址的轻量级用户数据作为键。

<p>
注册表中的整数键被辅助库实现的引用机制使用，因此不应该用作其他目的。

<h2>3.6 - <a name="3.6">C错误处理</a></h2>

<p>
Lua在内部使用C的<code>longjmp</code>设备处理错误。（如果你用C++也可选择使用异常；见文件<code>luaconf.h</code>。）当Lua面临任何错误时（例如内存分配错误、类型错误、语法错误和运行时错误这样的），它<em>抛出（raise）</em>一个错误；即执行一个长跳转。<em>受保护的环境</em>使用<code>setjmp</code>设置一个还原点；发生任何错误会跳到最近（时间上）活动的还原点。

<p>
Lua中的多数函数可抛出错误，例如内存分配错误。每个函数的文档指出它能否抛出错误。

<p>
在C函数内可通过调用<a href="#lua_error"><code>lua_error</code></a>抛出错误。

<h2>3.7 - <a name="3.7">函数与类型</a></h2>

<p>
这儿我们按照字母顺序列出来自C API的所有函数和类型。每个函数有个类似这样的指示器：<span class="apii">[-o, +p, <em>x</em>]</span>

<p>
第一个字段，<code>o</code>，是函数出栈多少个元素。第二个字段，<code>p</code>，是函数入栈多少个元素。（所有的函数总是在将其参数出栈后将其结果入栈。）形如<code>x|y</code>的字段意思是函数可入栈（或出栈）<code>x</code>或<code>y</code>个元素，依赖实际情形；一个问号标记‘<code>?</code>’意思是我们不能通过察看其参数知道函数出栈/入栈多少元素（例如，它们可能依赖于栈中存储的情况）。第三个字段，<code>x</code>，告知函数是否可能抛出错误：'<code>-</code>' 意思是函数决不抛出任何错误；'<code>m</code>' 意思是函数可能抛出一个错误，只取决于内存不足；'<code>e</code>' 意思是函数可能抛出其他类型的错误；'<code>v</code>' 意思是函数可能故意抛出错误。

<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
这种类型的内存分配函数由Lua状态机使用。分配器函数必须提供类似<code>realloc</code>的功能，但是不必完全一样。它的参数是<code>ud</code>，一个由<a href="#lua_newstate"><code>lua_newstate</code></a>传入的不透明指针；<code>ptr</code>，一个指向即将被分配/重分配/释放的内存块的指针；<code>osize</code>，内存块原来的尺寸；<code>nsize</code>，内存块的新尺寸。当且仅当<code>osize</code>是0时<code>ptr</code>为<code>NULL</code>。当<code>nsize</code>是0时，分配器必须返回<code>NULL</code>；如果<code>osize</code>非0，它将会释放<code>ptr</code>指向的内存块。当<code>nsize</code>非0时，当且仅当分配器不能满足请求时返回<code>NULL</code>。当<code>nsize</code>非0且<code>osize</code>是0时，分配器应该表现的类似<code>malloc</code>。当<code>nsize</code>和<code>osize</code>非0时，分配器表现的类似<code>realloc</code>。Lua假定当<code>osize &gt;= nsize</code>时分配器决不失败。

<p>
这儿有个分配器函数的简单实现。它被辅助库中的被<a href="#luaL_newstate"><code>luaL_newstate</code></a>使用。

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
该代码假定<code>free(NULL)</code>不起作用而且<code>realloc(NULL, size)</code>等价于<code>malloc(size)</code>。ANSI C确保这两种行为。

<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
设置新的应急（panic）函数并返回前一个。

<p>
如果在任何受保护的环境外面发生了错误，Lua调用<em>应急函数</em>接着调用<code>exit(EXIT_FAILURE)</code>，从而退出宿主程序。你的应急函数可通过永不返回（例如执行一次长跳转）以避免这次退出。

<p>
应急函数可访问栈顶的错误消息。

<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
调用一个函数。

<p>
要调用函数必须使用下面的协议：首先，将要被调用的函数压栈；然后，将函数参数顺序压栈；即第一参数首先压栈。最后，调用<a href="#lua_call"><code>lua_call</code></a>；<code>nargs</code>是你压栈的参数数量。当函数被调用时所有参数以及函数值被弹出栈。当函数返回时其结果被压栈。结果被调整为<code>nresults</code>个，除非<code>nresults</code>是<a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>。在该情况下，来自函数的<em>所有</em>结果被压栈。Lua会确保返回值适合栈空间。函数结果被顺序压栈（第一个结果首先压栈），因而调用后最后一个结果在栈顶。

<p>
被调用函数内的任何错误会被向上传播（使用<code>longjmp</code>）。

<p>
下面的例子显示宿主程序可如何执行与该Lua代码等价的操作：

<pre>
     a = f("how", t.x, 14)
</pre><p>
这是C中的代码：

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, "f");          /* 要被调用的函数 */
     lua_pushstring(L, "how");                             /* 第1个参数 */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");            /* 要被索引的表 */
     lua_getfield(L, -1, "x");           /* 将t.x的结果压栈（第2个参数） */
     lua_remove(L, -2);                  /* 从栈中删除‘t’ */
     lua_pushinteger(L, 14);                               /* 第3个参数 */
     lua_call(L, 3, 1);               /* 以3个参数调用‘f’，返回1个结果 */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* 设置全局变量‘a’ */
</pre><p>
注意上面的代码是“对称的”：在其结尾，栈回到其初始配置。这是一种良好的编程习惯。

<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
用于C函数的类型。

<p>
为了与Lua恰当地通讯，C函数必须使用下面的协议，它定义了参数和结果的传递方式：C函数在其栈中以顺序的方式（第一参数被首先压栈）接收来自Lua的参数。所以，当函数开始时，<code>lua_gettop(L)</code>返回函数收到的参数个数。第一参数（如果存在）在索引1处，最后的参数在索引<code>lua_gettop(L)</code>处。要向Lua返回值，C函数只需要将它们顺序压栈（第一个结果被首先压栈），并返回结果的个数。栈中结果下面的任何其他值将被Lua恰当地丢弃。同Lua函数一样，被Lua调用的C函数也能返回多个结果。

<p>
作为例子，下面的函数接收可变数量的数字参数，并返回它们的平均数与总和：

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数的个数 */
       lua_Number sum = 0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第1个参数 */
       lua_pushnumber(L, sum);         /* 第2个参数 */
       return 2;                   /* 结果的个数 */
     }
</pre>

<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_checkstack (lua_State *L, int extra);</pre>

<p>
确保栈中存在至少<code>extra</code>个空闲栈槽位。如果栈不能增长到那个尺寸则返回假。本函数从不缩小栈；如果栈已经比新尺寸大则无变化。

<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
销毁给定Lua状态机中的全部对象（如果存在对应的垃圾收集元方法则调用它们），并释放该状态机占用的所有动态内存。在一些平台上，你可能不需要调用本函数，因为当宿主程序结束时，所有资源自然地被释放。另一方面，长期运行的程序，比如后台程序（daemon）或web服务器，可能需要在状态机不再需要时立刻释放它们，以避免增长过大。

<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
连接栈顶的<code>n</code>个值，弹出它们并将结果留在栈顶。如果<code>n</code>是1，结果就是栈上的单个值（即函数什么也不做）；如果<code>n</code>是0，结果是空字符串。连接操作依照Lua的常规语义执行（见<a href="#2.5.4">&sect;2.5.4</a>）。

<hr><h3><a name="lua_cpcall"><code>lua_cpcall</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</pre>

<p>
以保护模式调用C函数<code>func</code>。<code>func</code>的栈中只有一个元素，是个包含<code>ud</code>的轻量级用户数据。发生错误时，<a href="#lua_cpcall"><code>lua_cpcall</code></a>返回同<a href="#lua_pcall"><code>lua_pcall</code></a>一样的错误代码，以及栈顶的错误对象；否则返回0且不改变栈。<code>func</code>返回的所有值被丢弃。

<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
创建新的空表并将其压栈。新表预分配<code>narr</code>个数组元素和<code>nrec</code>个非数组元素的空闲空间。当你确切地知道表将由多少个元素时，预分配是非常有用的。否则，你可用函数<a href="#lua_newtable"><code>lua_newtable</code></a>。

<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_dump (lua_State *L, lua_Writer writer, void *data);</pre>

<p>
将函数转储为二进制代码单元。接收栈顶的Lua函数并产生二进制单元，如果后者被再次加载，得到与被转储的等价的函数。当产生单元的各部分时，<a href="#lua_dump"><code>lua_dump</code></a>用给定的<code>data</code>调用函数<code>writer</code>（见<a href="#lua_Writer"><code>lua_Writer</code></a>）来写出它们。

<p>
返回值是最后一次调用记录器（writer）返回的错误代码；0表示没有错误。

<p>
本函数不会将Lua函数从栈中弹出。

<hr><h3><a name="lua_equal"><code>lua_equal</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_equal (lua_State *L, int index1, int index2);</pre>

<p>
沿用Lua的<code>==</code>操作符的语义（即可能调用元方法），比较在可接受索引<code>index1</code>和<code>index2</code>中的两个值，如果相等则返回1。否则返回0。如果任何索引无效也返回0。

<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
产生一个Lua错误。错误消息（实际上可为任何类型的Lua值）必须在栈顶。本函数执行长跳转，因此从不返回。（见<a href="#luaL_error"><code>luaL_error</code></a>）。

<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
控制垃圾收集器。

<p>
本函数根据参数<code>what</code>的值执行若干任务：

<ul>

<li><b><code>LUA_GCSTOP</code>:</b> 停止垃圾收集器。
</li>

<li><b><code>LUA_GCRESTART</code>:</b> 重新启动垃圾收集器。
</li>

<li><b><code>LUA_GCCOLLECT</code>:</b> 执行一次完整的垃圾收集器周期。
</li>

<li><b><code>LUA_GCCOUNT</code>:</b> 返回Lua当前占用的内存总量（以Kbyte为单位）。
</li>

<li><b><code>LUA_GCCOUNTB</code>:</b> 返回Lua当前的内存用量的字节数除1024的余数。
</li>

<li><b><code>LUA_GCSTEP</code>:</b> 执行一步增量垃圾收集。步“长”由<code>data</code>以未指定的方式控制（值越大意味着步骤越多）。要控制步长，你必须实验性地调整<code>data</code>的值。如果该步完成了一个垃圾收集周期则函数返回1。
</li>

<li><b><code>LUA_GCSETPAUSE</code>:</b> 设置<code>data</code>作为收集器的<em>pause</em>（见<a href="#2.10">&sect;2.10</a>）的新值。返回pause的前一个值。
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>:</b> 设置<code>data</code>作为收集器的<em>step multiplier</em>（见<a href="#2.10">&sect;2.10</a>）的新值。返回step multiplier的前一个值。
</li>

</ul>

<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
返回给定状态机的内存分配函数。如果<code>ud</code>不为<code>NULL</code>，Lua将<a href="#lua_newstate"><code>lua_newstate</code></a>传入的不透明指针存入<code>*ud</code>。

<hr><h3><a name="lua_getfenv"><code>lua_getfenv</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_getfenv (lua_State *L, int index);</pre>

<p>
将给定索引处的值的环境表压栈。

<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
将<code>t[k]</code>的值压栈，其中<code>t</code>是给定的有效索引处的值。同Lua中一样，本函数可能触发用于“index”事件的元方法（见<a href="#2.8">&sect;2.8</a>）。

<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getglobal (lua_State *L, const char *name);</pre>

<p>
将全局变量<code>name</code>的值压栈。它被定义为宏：

<pre>
     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</pre>

<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
将给定的认可的索引处的值的元表压栈。如果索引无效，或者如果该值没有元表，本函数返回0且不会压栈任何东西。

<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>void lua_gettable (lua_State *L, int index);</pre>

<p>
将值<code>t[k]</code>压栈，其中<code>t</code>是指定的有效索引处的值，并且<code>k</code>是栈顶的值。

<p>
本函数将键出栈（将结果值放在它的位置）。同Lua中一样，本函数可能触发用于“index”事件的元方法（见<a href="#2.8">&sect;2.8</a>）。

<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
返回栈顶元素的索引。因为索引从1开始，该结果等于栈中元素的数量（所以0表示空栈）。

<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
将栈顶元素移入给定的有效索引，并将该索引上面的元素上移至开放空间。不能以伪索引调用，因为伪索引不是真实的栈位置。

<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ptrdiff_t lua_Integer;</pre>

<p>
被Lua API用来表示整型值的类型。

<p>
缺省是<code>ptrdiff_t</code>，它通常是机器能处理的最大的带符号整型。

<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值具有布尔类型则返回1，否则返回0。

<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是C函数则返回1，否则返回0。

<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是函数（C或Lua）则返回1，否则返回0。

<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是轻型用户数据则返回1，否则返回0。

<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是<b>nil</b>则返回1，否则返回0。

<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值不合法（即其引用当前栈外部的元素）则返回1，否则返回0。

<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值不合法（即其引用当前栈外部的元素）或该索引处的值是<b>nil</b>则返回1，否则返回0。

<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是数字或者可转为数字的字符串则返回1，否则返回0。

<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是字符串或数字（它总是可转为字符串）则返回1，否则返回0。

<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是表则返回1，否则返回0。

<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是线程则返回1，否则返回0。

<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是用户数据（完整的或轻型的）则返回1，否则返回0。

<hr><h3><a name="lua_lessthan"><code>lua_lessthan</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_lessthan (lua_State *L, int index1, int index2);</pre>

<p>
如果认可的索引<code>index1</code>处的值小于认可的索引<code>index2</code>处的值则返回1，该操作遵循Lua的<code>&lt;</code>操作符的语义（即可能调用元方法）。否则返回0。如果任何索引不合法也返回0。

<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</pre>

<p>
加载Lua代码单元。如果没有错误，<a href="#lua_load"><code>lua_load</code></a>将编译的单元作为Lua函数压栈。否则，将一条错误消息压栈。<a href="#lua_load"><code>lua_load</code></a>的返回值是：

<ul>

<li><b>0:</b> 没有错误；</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>:</b> 预编译期间的语法错误；</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b> 内存分配错误。</li>

</ul>

<p>
本函数只是载入单元；并不执行它。

<p>
<a href="#lua_load"><code>lua_load</code></a>自动地检测单元是文本还是二进制，进而加载它（见程序<code>luac</code>）。

<p>
<a href="#lua_load"><code>lua_load</code></a>函数使用用户提供的<code>reader</code>函数读取单元（见<a href="#lua_Reader"><code>lua_Reader</code></a>）。<code>data</code>参数是传入读取器函数的不透明值。

<p>
<code>chunkname</code>参数给单元提供名字，用于错误消息和调试信息（见<a href="#3.8">&sect;3.8</a>）。

<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
创建新的、独立的状态机。如果不能创建状态机则返回<code>NULL</code>（由于内存不足）。参数<code>f</code>是分配器函数；Lua通过该函数为状态机执行全部的内存分配操作。第二参数<code>ud</code>是个不透明的指针，在每次调用中Lua将其传入分配器。

<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
创建新的空表并将其压栈。它等价于<code>lua_createtable(L, 0, 0)</code>。

<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
创建新线程，将其压栈，并返回指向<a href="#lua_State"><code>lua_State</code></a>的指针，它表示该新线程。本函数返回的新状态机与初始状态机共享所有全局对象（例如表），但具有独立的执行栈。

<p>
没有关闭或销毁线程的显式函数。像任何Lua对象一样，线程受垃圾收集的支配。

<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
本函数分配新的给定尺寸的内存块，以块地址的方式将完整的用户数据压栈，并返回该地址。

<p>
Lua中的用户数据表示C值。<em>完整的用户数据</em>表示一块内存。它是个对象（如同表）：你必须创建它，它可以有自己的元表，而且当被收集时能被检测到。完整的用户数据只等于自己（依照原始的相等比较）。

<p>
当Lua用<code>gc</code>元方法收集完整的用户数据时，Lua调用该元方法并把用户数据标记为完成的。当该用户数据再次被收集时，Lua释放其对应的内存。

<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
从栈中弹出一个键，并从给定的索引处的表中弹出一个键-值对（给定键的“下一”对）。如果表中没有更多的元素，则<a href="#lua_next"><code>lua_next</code></a>返回0（且不会压栈任何东西）。

<p>
典型的遍历看起来像这样：

<pre>
     /* 表在栈中的索引‘t’处 */
     lua_pushnil(L);  /* 第一个键 */
     while (lua_next(L, t) != 0) {
       /* 使用‘键’（索引-2）和‘值’(索引-1） */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除‘值’；为下次迭代保留‘键’ */
       lua_pop(L, 1);
     }
</pre>

<p>
当遍历表时，不要直接对键调用<a href="#lua_tolstring"><code>lua_tolstring</code></a>，除非你知道键确实是字符串。回忆一下，<a href="#lua_tolstring"><code>lua_tolstring</code></a>会<em>改变</em>给定所引处的值；这会干扰下一次调用<a href="#lua_next"><code>lua_next</code></a>。

<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
Lua中的数字类型。缺省是双精度浮点数，但是能在<code>luaconf.h</code>中改变。

<p>
通过配置文件能改变Lua去操作其他的类型用作数字（例如单精度浮点数或长整型）。

<hr><h3><a name="lua_objlen"><code>lua_objlen</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>size_t lua_objlen (lua_State *L, int index);</pre>

<p>
返回给定的认可的索引处的值的“长度”：对于字符串，这是其长度；对于表，这是取长操作符（‘<code>#</code>’）的结果；对于用户数据，这是为其分配的内存块的尺寸；对于其他类型是0。

<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), <em>-</em>]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</pre>

<p>
在保护模式中调用函数。

<p>
<code>nargs</code>和<code>nresults</code>同<a href="#lua_call"><code>lua_call</code></a>中的有相同的含义。如果调用期间没有错误，<a href="#lua_pcall"><code>lua_pcall</code></a>的行为完全类似<a href="#lua_call"><code>lua_call</code></a>。然而，如果存在任何错误，<a href="#lua_pcall"><code>lua_pcall</code></a>捕捉它，将单个值压栈（错误消息），并返回错误代码。同<a href="#lua_call"><code>lua_call</code></a>一样，<a href="#lua_pcall"><code>lua_pcall</code></a>总是从栈中移除函数及其参数。

<p>
如果<code>errfunc</code>是0，则在栈上返回的错误消息就是原始的错误消息。否则,<code>errfunc</code>就是<em>错误处理器函数（error handler function）</em>的栈索引。（当前实现中，该索引不能是伪索引。）在发生运行时错误时，该函数将用错误消息调用，而且其返回值将变成栈上被<a href="#lua_pcall"><code>lua_pcall</code></a>返回的消息。

<p>
典型地，错误处理器函数用于向错误消息中增加更多调试信息，例如栈回溯。这种信息不能在<a href="#lua_pcall"><code>lua_pcall</code></a>返回后搜集，因为那时候栈已释放。

<p>
成功时<a href="#lua_pcall"><code>lua_pcall</code></a>函数返回0，或者下面的错误代码之一（在<code>lua.h</code>中定义）：

<ul>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>:</b> 运行时错误。
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b> 内存分配错误。对于这类错误，Lua不会调用错误处理器函数。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>:</b> 当运行错误处理器函数时的错误。
</li>

</ul>

<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>-</em>]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
从栈中弹出<code>n</code>个元素。

<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
把值<code>b</code>作为布尔值压栈。

<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
把新的C闭包压栈。

<p>
当C函数被创建时，它可以把一些值与自己关联，这样就创建了C闭包（见<a href="#3.4">&sect;3.4</a>）；接下来无论何时它被调用，这些值对该函数都是可访问的。要将值与C函数关联，首先这些值应当被压栈（当有多个值时第一个值首先压栈）。然后用参数<code>n</code>调用<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>来创建C函数并将其压栈，n表明应当把多少值关联到该函数。<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>也会将这些值从栈中弹出。

<p>
<code>n</code>的最大值是255。

<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
将C函数压栈。本函数接收一个指向C函数的指针并把一个<code>function</code>类型的Lua值压栈，当这种类型的函数被调用时，会调用相应的C函数。

<p>
任何要在Lua中注册的函数必须遵循正确的协议，以接收其参数并返回其结果（见<a href="#lua_CFunction"><code>lua_CFunction</code></a>）。

<p>
<code>lua_pushcfunction</code>被定义为宏：

<pre>
     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</pre>

<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
将格式化的字符串压栈并返回指向它的指针。它与C函数<code>sprintf</code>类似，但也有一些重要的区别：

<ul>

<li>
你不需要为结果分配空间：结果是Lua字符串且Lua会照看内存分配（以及通过垃圾收集解除分配）。
</li>

<li>
转换说明符非常的有限。没有标记、宽度或精度。转换说明符只能是'<code>%%</code>' （在字符串中插入一个'<code>%</code>'），'<code>%s</code>' （插入一个以0结尾的字符串，没有尺寸限制），'<code>%f</code>' （插入一个<a href="#lua_Number"><code>lua_Number</code></a>），'<code>%p</code>' （插入一个指针作为十六进制数），'<code>%d</code>' （插入一个<code>int</code>），以及'<code>%c</code>' （插入一个<code>int</code>作为字符）。
</li>

</ul>

<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
将一个值为<code>n</code>的数字压栈。

<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
将轻型用户数据压栈。

<p>
在Lua中用户数据表示C值。<em>轻型用户数据</em>表示一个指针。它是个值（就像数字）：你不用创建它，它没有单独的元表，而且它不会被回收（如同从不被创建）。带有相同的C地址的轻型用户数据相等。

<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
本宏等价于<a href="#lua_pushlstring"><code>lua_pushlstring</code></a>，但是只能当<code>s</code>是字面字符串时使用。在这些情况下，它自动地提供字符串长度。

<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
将<code>s</code>指向的尺寸为<code>len</code>的字符串压栈。Lua制造（或重用）给定字符串的内部拷贝，所以函数返回后<code>s</code>的内存立刻可被释放或重用。字符串可含有内嵌的0。

<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
将nil值压栈。

<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
将值为<code>n</code>的数字压栈。

<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushstring (lua_State *L, const char *s);</pre>

<p>
将<code>s</code>指向的以0结尾的字符串压栈。Lua制造（或重用）给定字符串的内部拷贝，所以函数返回后<code>s</code>的内存立刻可被释放或重用。字符串不可含有内嵌的0；假定它在首个0处结束。

<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
将<code>L</code>表示的线程压栈。如果该线程是其状态机的主线程则返回1。

<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
将给定的有效索引处的元素的拷贝压栈。

<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
等价于<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>，除了它接收一个<code>va_list</code>而不是可变数量的参数。

<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
如果认可的索引<code>index1</code>和<code>index2</code>处的两个值原生相等（即不调用元方法）则返回1。否则返回0。如果任何索引不合法也返回0。

<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>
<pre>void lua_rawget (lua_State *L, int index);</pre>

<p>
类似<a href="#lua_gettable"><code>lua_gettable</code></a>，但是执行一次原生访问（也就是不用元方法）。

<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_rawgeti (lua_State *L, int index, int n);</pre>

<p>
降值<code>t[n]</code>压栈，其中<code>t</code>是给定的有效索引处的值。访问是原生的；即不会调用元方法。

<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
类似<a href="#lua_settable"><code>lua_settable</code></a>，但是执行一次原生赋值（也就是不用元方法）。

<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, int n);</pre>

<p>
执行<code>t[n] = v</code>的等价操作，其中<code>t</code>是给定的有效索引处的值，<code>v</code>是栈顶的值。

<p>
本函数将值出栈。赋值是原生的；即不调用元方法。

<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
被<a href="#lua_load"><code>lua_load</code></a>使用的读取器函数。每次需要单元的另一段时，<a href="#lua_load"><code>lua_load</code></a>沿着它的<code>data</code>参数调用读取器。读取器必须返回一个的内存块的指针，其中含有单元的新代码段，并且设置<code>size</code>为块尺寸。块必须一直存在直到再次调用读取器函数。读取器必须返回<code>NULL</code>或设置<code>size</code>为0来指示单元结束。读取器函数可能返回大于0的任何尺寸的代码段。

<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);</pre>

<p>
设置C函数<code>f</code>为全局变量<code>name</code>的新值。它被定义为宏：

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>

<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
移除给定的有效索引处的元素，并将该索引上面的元素下移来填充空隙。不能用伪索引调用，因为伪索引不是真实的栈位置。

<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
将栈顶元素移动到给定的索引中（并弹出它），不会移动任何元素（因此替换给定位置的值）。

<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>int lua_resume (lua_State *L, int narg);</pre>

<p>
启动和恢复给定线程中的一个协程。

<p>
要启动一个协程，首先创建线程（见<a href="#lua_newthread"><code>lua_newthread</code></a>）；接着将主函数以及任何参数压到它的栈中；然后用<code>narg</code>指定参数个数来调用<a href="#lua_resume"><code>lua_resume</code></a>。当协程挂起或运行完成时该调用返回。当它返回时，栈中含有<a href="#lua_yield"><code>lua_yield</code></a>传入的所有值，或主体函数返回的所有值。如果协程中断则<a href="#lua_resume"><code>lua_resume</code></a>返回<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>，如果运行无误结束则返回0，或者在发生错误时返回错误代码（见<a href="#lua_pcall"><code>lua_pcall</code></a>）。发生错误时，栈未被释放，所以可对它使用调试API。错误消息位于栈顶。要重新启动协程，你只需把要从<code>yield</code>传出的结果放到它的栈上，然后调用<a href="#lua_resume"><code>lua_resume</code></a>。

<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
把给定状态机的分配器函数换成带用户数据<code>ud</code>的<code>f</code>。

<hr><h3><a name="lua_setfenv"><code>lua_setfenv</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>int lua_setfenv (lua_State *L, int index);</pre>

<p>
从栈中弹出一个表并把它设为给定索引处的值的新环境。如果给定索引处的值既不是函数又不是线程也不是用户数据，<a href="#lua_setfenv"><code>lua_setfenv</code></a>返回0。否则返回1。

<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
执行<code>t[k] = v</code>的等价操作，其中<code>t</code>是给定的有效索引处的值，<code>v</code>是栈顶的值。

<p>
本函数从栈中弹出值。同Lua中一样，本函数可能触发“newindex”事件的元方法（见<a href="#2.8">&sect;2.8</a>）。

<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
从栈中弹出一个值并将其设为全局变量<code>name</code>的新值。它被定义为宏：

<pre>
     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</pre>

<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
从栈中弹出一个表并将其设为给定的认可的索引处的值的新元表。

<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
执行<code>t[k] = v</code>的等价操作，其中<code>t</code>是给定的有效索引处的值，<code>v</code>是栈顶的值，<code>k</code>正好是栈顶下面的值。

<p>
本函数将键和值都弹出栈。同Lua中一样，本函数可能触发“newindex”事件的元方法（见<a href="#2.8">&sect;2.8</a>）。

<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
接受任何认可的索引或0，并将栈顶设为该值。如果新栈顶比旧的大，则新元素用<b>nil</b>填充。如果<code>index</code> 是0，则移除所有栈元素。

<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
保持一个Lua解释器的完整状态机的不透明结构。Lua库是完全可重入的：没有全局变量。关于状态机的所有信息保持在该结构中。

<p>
一个指向该状态机的指针必须作为第一参数传入库中的所有函数，除了<a href="#lua_newstate"><code>lua_newstate</code></a>，它从头创建Lua状态机。

<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
返回线程<code>L</code>的状态。

<p>
对于正常的线程状态可为0，如果线程发生错误而结束则为错误代码，或者如果线程挂起则为<a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a>。

<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的Lua值转换为C布尔值（0或1）。同Lua中的所有测试一样，对于任何不同于<b>false</b>和<b>nil</b>的Lua值，<a href="#lua_toboolean"><code>lua_toboolean</code></a>返回1；否则返回0。当用不合法的索引调用时也返回0。（如果你要只接受真正的布尔值，使用<a href="#lua_isboolean"><code>lua_isboolean</code></a>测试值的类型。）

<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的值转换为C函数。那个值必须是个C函数，否则返回<code>NULL</code>。

<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的Lua值转换为带符号整数类型<a href="#lua_Integer"><code>lua_Integer</code></a>。该Lua值必须是数字或可转换为数字的字符串（见<a href="#2.2.1">&sect;2.2.1</a>）；否则<a href="#lua_tointeger"><code>lua_tointeger</code></a>返回0。

<p>
如果该数字不是整数，它会被以某种未指定的方式被截断。

<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
把给定的认可的索引处的Lua值转换为C字符串。如果<code>len</code>不是<code>NULL</code>，也会用字符串长度设置<code>*len</code>。该Lua值必须是字符串或数字；否则，本函数返回<code>NULL</code>。如果该值是数字，则<a href="#lua_tolstring"><code>lua_tolstring</code></a>也会<em>改变栈中的实际值为字符串</em>。（当在表遍历期间<a href="#lua_tolstring"><code>lua_tolstring</code></a>被用于键时，这个改变会干扰<a href="#lua_next"><code>lua_next</code></a>。）

<p>
<a href="#lua_tolstring"><code>lua_tolstring</code></a>返回个指向Lua状态机内部的字符串的完全调整的指针。这个字符串总是在其最后字符后有个0（‘<code>\0</code>’）（同C中一样），但是其体内可含有其他的0。因为Lua具有垃圾收集，所以无法担保<a href="#lua_tolstring"><code>lua_tolstring</code></a>返回的指针在相应的值从栈中移除后仍然有效。

<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的Lua值转换为C类型<a href="#lua_Number"><code>lua_Number</code></a>（见<a href="#lua_Number"><code>lua_Number</code></a>）。该Lua值必须是数字或可转为数字的字符串（见<a href="#2.2.1">&sect;2.2.1</a>）；否则<a href="#lua_tonumber"><code>lua_tonumber</code></a>返回0。

<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的值转换为普通的C指针（<code>void*</code>）。该值可为用户数据、表、线程或函数；否则<a href="#lua_topointer"><code>lua_topointer</code></a>返回<code>NULL</code>。不同的对象将给出不同的指针。没有方法可以把指针转回其原始值。

<p>
典型地，本函数只用于调试信息。

<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
等价于<code>len</code>等于<code>NULL</code>时的<a href="#lua_tolstring"><code>lua_tolstring</code></a>。

<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
把给定的认可的索引处的值转换为Lua线程（用<code>lua_State*</code>表示）。该值必须为线程；否则，本函数返回<code>NULL</code>。

<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
如果给定的认可的索引处的值是完整的用户数据，则返回其块地址。如果是轻型用户数据，返回其指针。否则返回<code>NULL</code>。

<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
返回给定的认可的索引处的值的类型，或者对不合法的索引返回<code>LUA_TNONE</code>（即指向“空”栈位置的索引）。<a href="#lua_type"><code>lua_type</code></a>返回的类型在<code>lua.h</code>中定义，被编码为下面的常量：
<code>LUA_TNIL</code>、<code>LUA_TNUMBER</code>、<code>LUA_TBOOLEAN</code>、<code>LUA_TSTRING</code>、<code>LUA_TTABLE</code>、<code>LUA_TFUNCTION</code>、<code>LUA_TUSERDATA</code>、<code>LUA_TTHREAD</code>和<code>LUA_TLIGHTUSERDATA</code>。

<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const char *lua_typename  (lua_State *L, int tp);</pre>

<p>
返回由值<code>tp</code>编码的类型名，tp必须是<a href="#lua_type"><code>lua_type</code></a>的返回值的其中一个。

<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
由<a href="#lua_dump"><code>lua_dump</code></a>使用的记录器函数的类型。<a href="#lua_dump"><code>lua_dump</code></a>沿着要被写入的缓冲区（<code>p</code>）调用本函数，同时传入缓冲区尺寸（<code>sz</code>）和提供给<a href="#lua_dump"><code>lua_dump</code></a>的<code>data</code>参数。每次调用会产生单元的另一段代码。

<p>
记录器返回错误代码：0表示没错误；任何其他值表示错误并阻止<a href="#lua_dump"><code>lua_dump</code></a>再次调用记录器。

<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
在<em>同一个</em>全局状态机的不同线程间交换值。

<p>
本函数从栈<code>from</code>中弹出<code>n</code>个值并把它们压入栈<code>to</code>中。

<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>int lua_yield  (lua_State *L, int nresults);</pre>

<p>
中断一个协程。

<p>
本函数只应当作为C函数的返回表达式调用，如下：

<pre>
     return lua_yield (L, nresults);
</pre><p>
当C函数以那种方式调用<a href="#lua_yield"><code>lua_yield</code></a>时，当前运行的协程挂起，并且启动该协程的<a href="#lua_resume"><code>lua_resume</code></a>调用返回。参数<code>nresults</code>是作为结果传给<a href="#lua_resume"><code>lua_resume</code></a>的来自栈中的值的数量。

<h2>3.8 - <a name="3.8">调试接口</a></h2>

<p>
Lua没有内置的调试装备。取而代之的是，它依靠函数和<em>hook</em>提供特定接口。该接口允许构造不同类型的调试器、profiler和其他的需要来自解释器“内部信息”的工具。

<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) upvalue的数量 */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 专用部分 */
  <em>其他字段</em>
} lua_Debug;</pre>

<p>
用于持有关于活动函数的信息的不同事项的结构。<a href="#lua_getstack"><code>lua_getstack</code></a>只填充本结构的专用部分，留作后用。要用有用的信息填充<a href="#lua_Debug"><code>lua_Debug</code></a>的其他字段，调用<a href="#lua_getinfo"><code>lua_getinfo</code></a>。

<p>
<a href="#lua_Debug"><code>lua_Debug</code></a>的字段具有下面的含义：

<ul>

<li><b><code>source</code>:</b> 如果函数在字符串中定义，则<code>source</code>就是那个字符串。如果函数在文件中定义，则<code>source</code>以‘<code>@</code>’开头后跟文件名。
</li>

<li><b><code>short_src</code>:</b> 一个<code>source</code>的“可打印”版本，将用于错误消息中。
</li>

<li><b><code>linedefined</code>:</b> 函数定义开始的行号。
</li>

<li><b><code>lastlinedefined</code>:</b> 函数定义结束的行号。
</li>

<li><b><code>what</code>:</b> 如果函数是Lua函数则为字符串<code>"Lua"</code>，如果是C函数则为<code>"C"</code>，如果是单元的主体部分则为<code>"main"</code>，并且如果是执行了尾调用的函数则为
<code>"tail"</code>。最后一种情况，Lua没有关于函数的其他信息。
</li>

<li><b><code>currentline</code>:</b> 给定函数正执行的当前行。当没有行信息可用时，<code>currentline</code>被设为-1。
</li>

<li><b><code>name</code>:</b> 给定函数的合适的名字。因为Lua函数是第一类值，所以它们没有固定的名字：一些函数可为多个全局变量的值，然而其他的可只存储于一个表字段中。函数<code>lua_getinfo</code>检查函数是如何被调用的以找到合适的名字。如果找不到，则<code>name</code>被设为<code>NULL</code>。
</li>

<li><b><code>namewhat</code>:</b> 解释<code>name</code>字段。依据函数被如何调用，<code>namewhat</code>的值可为<code>"global"</code>、<code>"local"</code>、<code>"method"</code>、<code>"field"</code>、<code>"upvalue"</code>或<code>""</code>（空字符串）。（当看似没有其他选项可用时Lua使用空串。）
</li>

<li><b><code>nups</code>:</b> 函数的upvalue的数量。
</li>

</ul>

<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
返回当前的hook函数。

<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
返回当前的hook计数。

<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
返回当前的hook掩码。

<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
返回关于特定的函数或函数调用的信息。

<p>
要得到关于函数调用的信息，参数<code>ar</code>必须是有效的活动记录（activation record），它被之前的<a href="#lua_getstack"><code>lua_getstack</code></a>调用填充，或者作为hook的参数（见<a href="#lua_Hook"><code>lua_Hook</code></a>）。

<p>
要得到关于函数的信息，将它压栈并让字符串<code>what</code>以字符‘<code>&gt;</code>’开头。（那种情况下，<code>lua_getinfo</code>弹出栈顶的函数。）例如，要知道想函数<code>f</code>在哪一行定义，可编写下面的代码：

<pre>
     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* 得到全局的‘f’ */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
字符串<code>what</code>中的每个字符选取结构<code>ar</code>中某些要填充的字段或要被压栈的某个值：

<ul>

<li><b>'<code>n</code>':</b> 填充字段<code>name</code>和<code>namewhat</code>；
</li>

<li><b>'<code>S</code>':</b> 填充字段<code>source</code>、<code>short_src</code>、<code>linedefined</code>、<code>lastlinedefined</code>和<code>what</code>；
</li>

<li><b>'<code>l</code>':</b> 填充字段<code>currentline</code>；
</li>

<li><b>'<code>u</code>':</b> 填充字段<code>nups</code>；
</li>

<li><b>'<code>f</code>':</b> 把正在给定的级别运行的函数压栈；
</li>

<li><b>'<code>L</code>':</b> 把一个表压栈，其索引是函数的有效行的编号。（<em>有效行</em>是与一些代码关联的行，即可以放置断点的行。无效的行包括空行和注释。）
</li>

</ul>

<p>
出错时本函数返回0（例如，<code>what</code>有无效选项）。

<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
获得给定的活动记录的一个局部变量的信息。参数<code>ar</code>必须是有效的活动记录，它被之前的<a href="#lua_getstack"><code>lua_getstack</code></a>调用填充，或者作为hook的参数（见<a href="#lua_Hook"><code>lua_Hook</code></a>）。索引<code>n</code>选取要检阅哪个局部变量（1是第一个参数或活动的局部变量，以此类推，直到最后一个活动的局部变量）。<a href="#lua_getlocal"><code>lua_getlocal</code></a>将变量的值压栈并返回其名字。

<p>
‘<code>(</code>’（开圆括号）开头的变量表示内部变量（循环控制变量、临时变量和C函数局部变量）。

<p>
当索引比活动的局部变量的数量大时返回<code>NULL</code>（且不压栈任何东西）。

<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
得到关于解释器运行时的栈信息。

<p>
本函数用执行于给定级别的函数的<em>活动记录</em>的标识符填充部分<a href="#lua_Debug"><code>lua_Debug</code></a>结构。0级是当前运行的函数，而<em>n+1</em>级是调用<em>n</em>级的函数。无错误时<a href="#lua_getstack"><code>lua_getstack</code></a>返回1；当以超过栈深度的级别调用时返回0。

<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
得到闭包的一个upvalue的信息。（对于Lua函数，upvalue是函数用到因而被包含在其闭包内的外部局部变量。）<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>得到索引<code>n</code>处的upvalue，将其值压栈并返回其名。<code>funcindex</code>指向栈中的闭包。（upvalue没有特定的顺序，因为它们在整个函数中从头至尾都是活动的，所以它们以任意顺序被编号。）

<p>
当索引比upvalue的数量大时返回<code>NULL</code>（且不压栈任何东西）。对于C函数，本函数用空串<code>""</code>作为所有upvalue的名字。

<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
调试的hook函数类型。

<p>
当hook被调用时，其<code>ar</code>参数将其字段<code>event</code>设为触发该hook的特定事件。Lua用下面的常量标识这些事件：<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>、<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>、<a name="pdf-LUA_HOOKTAILRET"><code>LUA_HOOKTAILRET</code></a>、<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>和<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。此外，对于行事件，也会设置字段<code>currentline</code>。要得到<code>ar</code>中其他字段的值，hook必须调用<a href="#lua_getinfo"><code>lua_getinfo</code></a>。对于返回事件，<code>event</code>可以是普通值<code>LUA_HOOKRET</code>或<code>LUA_HOOKTAILRET</code>。对于后者，Lua将模拟从执行了尾调用的函数中的返回；这种情况下，调用<a href="#lua_getinfo"><code>lua_getinfo</code></a>是无用的。

<p>
当Lua运行hook时，它禁止其他的hook调用。因此，如果hook回调Lua来执行函数或单元，该次执行不带任何hook调用。

<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
设置调试的hook函数。

<p>
参数<code>f</code>是hook函数。<code>mask</code>规定发生哪个事件时hook将被调用：它由常量<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>、<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>、<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>和<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>按位或组成。
只当掩码含有<code>LUA_MASKCOUNT</code>时，<code>count</code>参数才有意义。对于每个事件，hook如下面解释的那样被调用：

<ul>

<li><b>call hook:</b> 当解释器调用函数时被调用。hook在Lua刚进入新函数后、在函数得到其参数前被调用。
</li>

<li><b>return hook:</b> 当解释器从函数返回时被调用。hook在Lua正要离开函数前被调用。你不能访问要被函数返回的值。
</li>

<li><b>line hook:</b> 当解释器将要开始新行代码的执行或跳回到代码中（甚至是同一行）时被调用。（该事件只在Lua正执行Lua函数时发生。）
</li>

<li><b>count hook:</b> 在解释器执行每<code>count</code>条指令后被调用。（该事件只在Lua正执行Lua函数时发生。）
</li>

</ul>

<p>
通过设定<code>mask</code>为0禁用hook。

<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>
<pre>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
设置给定的活动记录的一个局部变量的值。参数<code>ar</code>和<code>n</code>与<a href="#lua_getlocal"><code>lua_getlocal</code></a>中一样（见<a href="#lua_getlocal"><code>lua_getlocal</code></a>）。<a href="#lua_setlocal"><code>lua_setlocal</code></a>把栈顶的值赋给变量并返回其名字。它也将值从栈中弹出。

<p>
当索引超过活动的局部变量的数量时返回<code>NULL</code>（且不出栈任何东西）。

<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
设置闭包的upvalue的值。它把栈顶的值赋给upvalue并返回其名字。它也把值从栈中弹出。参数<code>funcindex</code>和<code>n</code>同<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>中一样（见<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>）。

<p>
当索引超过upvalue的数量时返回<code>NULL</code>（且不出栈任何东西）。

<h1>4 - <a name="4">辅助库</a></h1>

<p>
<em>辅助库</em>为连接C和Lua提供若干便利的函数。基础API为C和Lua间的所有交互提供基本功能，而辅助库为一些通用任务提供高级功能。

<p>
所有来自辅助库的函数在头文件<code>lauxlib.h</code>中定义并具有前缀<code>luaL_</code>。

<p>
辅助库中的所有函数建立于基础API的顶层，所以该API做不了的它们也不提供。

<p>
辅助库中的一些函数用于检查C函数的参数。它们的名字总是<code>luaL_check*</code>或<code>luaL_opt*</code>。如果未满足检查条件，所有这些函数会抛出错误。因为错误消息是为参数格式化的（例如“<code>bad argument #1</code>”），所以不能把这些函数用于其它栈值。

<h2>4.1 - <a name="4.1">函数与类型</a></h2>

<p>
这儿我们以字母顺序列出来自辅助库的所有函数和类型。

<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
把字符<code>c</code>添加到缓冲器<code>B</code>（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。

<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
把<code>s</code>指向的长度为<code>l</code>的字符串添加到缓冲器<code>B</code>（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。字符串可含有内嵌的0。

<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
把先前拷贝到缓冲区（见<a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>）的长为<code>n</code>的字符串添加到缓冲器<code>B</code>（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。

<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
把<code>s</code>指向的0结尾的字符串添加到缓冲器<code>B</code>（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。字符串不可包含内嵌的0。

<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
把栈顶的值添加到缓冲器<code>B</code>（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。弹出该值。

<p>
这是仅有能（且必须）用栈上的一个额外元素调用的关于字符串缓冲器的函数，该元素是要被添加到缓冲器的值。

<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</pre>

<p>
检查<code>cond</code>是否为真。如果不是，则抛出带下面的消息的错误，其中<code>func</code>是取自调用栈：

<pre>
     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>

<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</pre>

<p>
抛出带下面的消息的错误，其中<code>func</code>是取自调用栈：

<pre>
     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>

<p>
本函数决不返回，但是像<code>return luaL_argerror(<em>args</em>)</code>这样是用在C函数中的习惯用法。

<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>字符串缓冲器</em>类型。

<p>
字符串缓冲器允许C代码逐段地构建Lua字符串。其使用模式如下：

<ul>

<li>首先声明<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>类型的变量<code>b</code>。</li>

<li>接着调用<code>luaL_buffinit(L, &amp;b)</code>初始化它。</li>

<li>然后调用<code>luaL_add*</code>函数把字符串片断添加到缓冲器。</li>

<li>通过调用<code>luaL_pushresult(&amp;b)</code>结束。该调用把最终的字符串放在栈顶。</li>

</ul>

<p>
在字符串缓冲器的常规操作期间，它占用的栈槽数量不固定。所以，使用缓冲器时，你不能假定知道栈顶在哪儿。只要用法是对称的，你就能在连续的对缓冲器操作的调用之间使用栈；就是说，当你调用缓冲器操作时，栈处于前一个缓冲器操作后立刻得到的水平。（该规则的唯一例外是<a href="#luaL_addvalue"><code>luaL_addvalue</code></a>。）调用<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>之后，栈回到缓冲器被初始化时的水平，加上栈顶的最终字符串。

<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
初始化缓冲器<code>B</code>。本函数不分配任何空间；缓冲器必须已被声明为变量（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。

<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
调用一个元方法。

<p>
如果索引<code>obj</code>处的对象具有元表且该元表具有字段<code>e</code>，本函数调用该字段并传入该对象为其唯一参数。这种情况下，本函数返回1并将该调用返回的值压栈。如果没有元表或没有元方法，本函数返回0（不将任何值压栈）。

<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int narg);</pre>

<p>
检查函数是否在位置<code>narg</code>处有个任意类型（包括<b>nil</b>）的参数。

<hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkint (lua_State *L, int narg);</pre>

<p>
检查函数参数<code>narg</code>是否数字并把该数转型为<code>int</code>返回。

<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int narg);</pre>

<p>
检查函数参数<code>narg</code>是否数字并把该数转型为<a href="#lua_Integer"><code>lua_Integer</code></a>返回。

<hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_checklong (lua_State *L, int narg);</pre>

<p>
检查函数参数<code>narg</code>是否数字并把该数转型为<code>long</code>返回。

<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</pre>

<p>
检查函数参数<code>narg</code>是否字符串并返回它；如果<code>l</code>不是<code>NULL</code>则用字符串的长度填充它。

<p>
本函数用<a href="#lua_tolstring"><code>lua_tolstring</code></a>得到其结果，所以那个函数的所有变换和警告也适用于此处。

<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int narg);</pre>

<p>
检查函数参数<code>narg</code>是否数字并返回它。

<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
检查函数参数<code>narg</code>是否字符串并且在数组<code>lst</code>（必须是NULL结尾的）中搜索它。返回数组中发现该字符串的地方的索引。如果该参数不是字符串或没被找到则引发错误。

<p>
如果<code>def</code>不是<code>NULL</code>，当参数<code>narg</code>不存在或为<b>nil</b>时，函数用<code>def</code>作为缺省值。

<p>
这是个把字符串映射到C枚举的有用函数。（Lua库中的通常约定是用字符串代替数字来选取选项。）

<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
增长栈尺寸到<code>top + sz</code>个元素，如果不能增长到那个尺寸则引发错误。<code>msg</code>是加入错误消息的补充文本。

<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int narg);</pre>

<p>
检查函数参数<code>narg</code>是否字符串并返回它。

<p>
本函数用<a href="#lua_tolstring"><code>lua_tolstring</code></a>取得其结果，所以那个函数的所有变换和警告也适用于此处。

<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int narg, int t);</pre>

<p>
检查函数参数<code>narg</code>是否具有类型<code>t</code>。用于类型<code>t</code>的编码见<a href="#lua_type"><code>lua_type</code></a>。

<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</pre>

<p>
检查函数参数<code>narg</code>是否<code>tname</code>类型的用户数据（见<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。

<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
载入并运行给定文件。它被定义为下面的宏：

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果没有错误则返回0，发生错误时返回1。

<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
载入并运行给定的字符串。它被定义为下面的宏：

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果没有错误则返回0，发生错误时返回1。

<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
引发一个错误。错误消息格式由<code>fmt</code>以及任何额外参数指定，且遵循同<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>一样的规则。如果错误发生的文件名和行号可用，它也在消息开头添加该信息。

<p>
本函数从不返回，但是在C函数中<code>return luaL_error(<em>args</em>)</code>是个习惯用法。

<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
把来自索引<code>obj</code>处的对象的元表的字段<code>e</code>压栈。如果对象没有元表或其元表没有该字段，则返回0且不会压栈任何东西。

<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
把与注册表中的名字<code>tname</code>相关联的元表压栈。（见<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。

<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
通过把出现的任何字符串<code>p</code>替换为字符串<code>r</code>来创建字符串<code>s</code>的拷贝。把结果字符串压栈并返回它。

<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
载入缓冲器并作为一个Lua单元。本函数用<a href="#lua_load"><code>lua_load</code></a>来加载缓冲器中由<code>buff</code>指向且长度为<code>sz</code>的单元。

<p>
本函数返回同<a href="#lua_load"><code>lua_load</code></a>一样的结果。<code>name</code>是单元名字，用于调试信息和错误消息。

<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
载入文件作为一个Lua单元。本函数用<a href="#lua_load"><code>lua_load</code></a>来载入名为<code>filename</code>的文件中的单元。如果<code>filename</code>是<code>NULL</code>，则从标准输入载入。文件中的第一行如果以<code>#</code>开头则被忽略。

<p>
本函数返回同<a href="#lua_load"><code>lua_load</code></a>一样的结果，除了有个额外的错误代码<a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>，用于不能打开/读取文件的情况。

<p>
同<a href="#lua_load"><code>lua_load</code></a>一样，本函数只载入单元；不会运行它。

<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
载入字符串作为一个Lua单元。本函数用<a href="#lua_load"><code>lua_load</code></a>来载入以0结尾的字符串<code>s</code>中的单元。

<p>
本函数返回同<a href="#lua_load"><code>lua_load</code></a>一样的结果。

<p>
本函数只载入单元，这也同<a href="#lua_load"><code>lua_load</code></a>一样；不会运行它。

<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
如果注册表已经有了键<code>tname</code>则返回0。否则，创建将用作用户数据的元表的新表，把它同键<code>tname</code>一起加入注册表，并且返回1。

<p>
两种情况都把注册表中与<code>tname</code>相关联的最终值压栈。

<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
创建新的Lua状态机。它用基于标准C的<code>realloc</code>函数的分配器调用<a href="#lua_newstate"><code>lua_newstate</code></a>，然后设置一个在发生重大错误时向标准错误输出打印一条错误消息的应急函数（见<a href="#lua_atpanic"><code>lua_atpanic</code></a>）。

<p>
返回新的状态机，如果发生内存分配错误则返回<code>NULL</code>。

<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
打开所有的标准Lua库到给定的状态机中。

<hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_optint (lua_State *L, int narg, int d);</pre>

<p>
如果函数参数<code>narg</code>是数字，则把该数字转型为<code>int</code>返回。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</pre>

<p>
如果函数参数<code>narg</code>是数字，则把该数字转型为<a href="#lua_Integer"><code>lua_Integer</code></a>返回。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_optlong (lua_State *L, int narg, long d);</pre>

<p>
如果函数参数<code>narg</code>是数字，则把该数字转型为<code>long</code>返回。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</pre>

<p>
如果函数参数<code>narg</code>是字符串则返回它。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<p>
如果<code>l</code>不为<code>NULL</code>，则用结果的长度填充位置<code>*l</code>。

<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</pre>

<p>
如果函数参数<code>narg</code>是数字则返回它。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</pre>

<p>
如果函数参数<code>narg</code>是字符串则返回它。如果该参数不存在或为<b>nil</b>则返回<code>d</code>。否则引发错误。

<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
返回尺寸为<a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>的空间的地址，你能把要被加入缓冲器<code>B</code>的字符串拷贝到其中（见<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。在把字符串拷贝到该空间中以后，你必须用字符串的尺寸调用<a href="#luaL_addsize"><code>luaL_addsize</code></a>来把它加入缓冲器中。

<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
结束对缓冲器<code>B</code>的使用，把最终字符串留在栈顶。

<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
在索引<code>t</code>处的表中为栈顶的对象创建一个<em>引用（reference）</em>并返回（而且弹出该对象）。

<p>
引用是唯一的整数键。只要你不手工向表<code>t</code>中加入整数键，<a href="#luaL_ref"><code>luaL_ref</code></a>保证它返回的键的唯一性。你可通过调用<code>lua_rawgeti(L, t, r)</code>取回被<code>r</code>引用的对象。函数<a href="#luaL_unref"><code>luaL_unref</code></a>释放引用及其关联的对象。

<p>
如果栈顶的对象是<b>nil</b>，<a href="#luaL_ref"><code>luaL_ref</code></a>返回常量<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>。常量<a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a>被确保与<a href="#luaL_ref"><code>luaL_ref</code></a>返回的任何引用都不同。

<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
用于要被<a href="#luaL_register"><code>luaL_register</code></a>注册的函数数组的类型。<code>name</code>是函数名，<code>func</code>是函数指针。任何<a href="#luaL_Reg"><code>luaL_Reg</code></a>数组必须以<code>name</code>和<code>func</code>都为<code>NULL</code>的标记项结尾。

<hr><h3><a name="luaL_register"><code>luaL_register</code></a></h3><p>
<span class="apii">[-(0|1), +1, <em>m</em>]</span>
<pre>void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</pre>

<p>
打开一个库。

<p>
当以<code>libname</code>等于<code>NULL</code>调用时，它只是注册列表<code>l</code>中的所有函数（见<a href="#luaL_Reg"><code>luaL_Reg</code></a>）到栈顶的表中。

<p>
当以非空的<code>libname</code>调用时，<code>luaL_register</code>创建新表<code>t</code>，把它设为全局变量<code>libname</code>的值，和<code>package.loaded[libname]</code>的值，并把列表<code>l</code>中的所有函数注册到该表。如果<code>package.loaded[libname]</code>中或变量<code>libname</code>中有个表，则重用该表而不是创建一个新的。

<p>
无论如何函数都把表留在栈顶。

<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
返回给定索引处的值的类型名。

<hr><h3><a name="luaL_typerror"><code>luaL_typerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_typerror (lua_State *L, int narg, const char *tname);</pre>

<p>
用类似下面的消息产生一个错误：

<pre>
     <em>location</em>: bad argument <em>narg</em> to '<em>func</em>' (<em>tname</em> expected, got <em>rt</em>)
</pre><p>
其中<code><em>location</em></code>由<a href="#luaL_where"><code>luaL_where</code></a>产生，<code><em>func</em></code>是当前函数名，且<code><em>rt</em></code>是实际参数的类型名。

<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
解除来自索引<code>t</code>处的表的引用<code>ref</code>（见<a href="#luaL_ref"><code>luaL_ref</code></a>）。该项从表中删除，所以被引用的对象可被回收。引用<code>ref</code>也被释放以备再次使用。

<p>
如果<code>ref</code>是<a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>或<a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>，<a href="#luaL_unref"><code>luaL_unref</code></a>什么也不做。

<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
把调用栈中<code>lvl</code>级的控制的当前位置的字符串标识压栈。典型地，该字符串具有如下格式：

<pre>
     <em>单元名</em>:<em>当前行</em>:
</pre><p>
0级是正在运行的函数，1级是调用正在运行函数的函数，依次类推。

<p>
本函数用于为错误消息构建前缀。

<h1>5 - <a name="5">标准库</a></h1>

<p>
Lua标准库提供直接通过C API实现的有用的函数。其中一些函数提供语言的核心服务（例如<a href="#pdf-type"><code>type</code></a>和<a href="#pdf-getmetatable"><code>getmetatable</code></a>）；其他的提供对“外”访问服务（例如I/O）；还有一些能用Lua自身实现，但是非常有用或者有关键的性能要求以致需要C实现（例如<a href="#pdf-table.sort"><code>table.sort</code></a>）。

<p>
所有库通过官方C API实现并且作为独立的C 模块提供。当前Lua拥有如下标准库：

<ul>

<li>基础库；</li>包括协程子程序库；

<li>打包库；</li>

<li>字符串操作；</li>

<li>表操作；</li>

<li>数学运算函数（sin、log等等）；</li>

<li>输入输出；</li>

<li>操作系统设备；</li>

<li>调试设备。</li>

</ul><p>
除了基础库和打包库，每个库提供其所有函数作为一个全局表的字段或作为其对象的方法。

<p>
要访问这些库，C宿主程序应该调用<a href="#luaL_openlibs"><code>luaL_openlibs</code></a>函数，它打开所有的标准库。另外，可以分别打开他们，方法是调用<a name="pdf-luaopen_base"><code>luaopen_base</code></a>（用于基础库）、<a name="pdf-luaopen_package"><code>luaopen_package</code></a>（用于打包库）、<a name="pdf-luaopen_string"><code>luaopen_string</code></a>（用于字符串库）、<a name="pdf-luaopen_table"><code>luaopen_table</code></a>（用于表库）、<a name="pdf-luaopen_math"><code>luaopen_math</code></a>（用于数学运算库）、<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (用于I/O库)、<a name="pdf-luaopen_os"><code>luaopen_os</code></a>（用于操作系统库）和<a name="pdf-luaopen_debug"><code>luaopen_debug</code></a>（用于调试库）。
这些函数在<a name="pdf-lualib.h"><code>lualib.h</code></a>中声明并且不能直接调用：你必须像任何其他的C函数一样调用他们，例如，通过使用<a href="#lua_call"><code>lua_call</code></a>。

<h2>5.1 - <a name="5.1">基础函数</a></h2>

<p>
基础库给Lua提供一些核心函数。如果你的程序中没有包含该库，你需要仔细检查是否需要为一些它的设备提供实现。

<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>
当参数<code>v</code>的值为假（例如<b>nil</b>或<b>false</b>）时放出一个错误；否则，返回它的所有参数。<code>message</code>是条错误消息；忽略时，缺省为“assertion failed!”。

<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage (opt [, arg])</code></a></h3>

<p>
该函数是垃圾收集器的通用接口。它根据第一参数提供不同的功能，<code>opt</code>：

<ul>

<li><b>"stop":</b> 停止垃圾收集器。
</li>

<li><b>"restart":</b> 重新启动垃圾收集器。
</li>

<li><b>"collect":</b> 执行一个完整的垃圾收集周期。
</li>

<li><b>"count":</b> 返回Lua中已用内存总量（以Kbyte为单位）。
</li>

<li><b>"step":</b> 执行一个垃圾收集step。step“尺寸”由<code>arg</code>（值越大意味着越多的step）以一种未指定的方式控制。如果要控制step尺寸，必须以实验的方式调整<code>arg</code>的值。如果step完成一个收集周期则返回<b>true</b>。
</li>

<li><b>"setpause":</b> 设置收集器的<em>pause</em>（见<a href="#2.10">&sect;2.10</a>）的新值为<code>arg</code>。返回前一个<em>pause</em>值。
</li>

<li><b>"setstepmul":</b> 设置收集器的<em>step multiplier</em>（见<a href="#2.10">&sect;2.10</a>）的新值为<code>arg</code>。返回前一个<em>tep</em>值。
</li>

</ul>

<p>
<hr><h3><a name="pdf-dofile"><code>dofile (filename)</code></a></h3>
打开命名文件并将其内容作为一个Lua单元执行。当空参调用时，<code>dofile</code>执行标准输入（<code>stdin</code>）的内容。返回单元返回的所有值。在发生错误的情况下，<code>dofile</code>将错误传播到其调用者（即<code>dofile</code>不是运行于保护模式）。

<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
终止最近的受保护的函数调用并返回<code>message</code>作为错误消息。函数<code>error</code>决不返回。

<p>
通常，<code>error</code>在消息的开头增加关于错误位置的信息。<code>level</code>参数指定如何获得错误位置。
用级别1（缺省的）时，错误位置是<code>error</code>函数被调用处。级别2指向调用<code>error</code>的函数的调用处。传递级别0避免向消息附加错误位置信息。

<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
持有全局环境的全局变量（非函数）（即<code>_G._G = _G</code>）。Lua自身并不使用该变量；改变其值不影响任何环境，反之亦然。（使用<a href="#pdf-setfenv"><code>setfenv</code></a>来改变环境。）

<p>
<hr><h3><a name="pdf-getfenv"><code>getfenv ([f])</code></a></h3>
返回函数的当前环境。<code>f</code>可以是Lua函数或指定调用栈级别的数字：级别1是调用<code>getfenv</code>的函数。如果给出的函数不是Lua函数或者<code>f</code>为0，<code>getfenv</code>返回全局环境。<code>f</code>缺省为1。

<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>

<p>
如果<code>object</code>没有元表，返回<b>nil</b>。否则，如果对象的元表具有<code>"__metatable"</code>字段，返回关联的值。否则返回给定对象的元表。

<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>

<p>
返回三个值：迭代器函数、表<code>t</code>和0，所以结构

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
将迭代键值对（<code>1,t[1]</code>）、（<code>2,t[2]</code>）、&middot;&middot;&middot;，直到第一个不存在于表中的整数键。

<p>
<hr><h3><a name="pdf-load"><code>load (func [, chunkname])</code></a></h3>

<p>
通过用<code>func</code>函数获取代码片的方式载入单元。对<code>func</code>的每次调用必须返回一个与先前的结果串联的字符串。返回空串、<b>nil</b>或无值告知单元结束。

<p>
如果没有错误，将编译的单元作为函数返回；否则返回<b>nil</b>以及错误消息。被返回的函数的环境是全局环境。

<p>
<code>chunkname</code>作为单元名用于错误消息和调试信息。当省略时，缺省委“<code>=(load)</code>”。

<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename])</code></a></h3>

<p>
与<a href="#pdf-load"><code>load</code></a>类似，但是从文件<code>filename</code>中获取单元，如果未给出文件名则从标准输入获取。

<p>
<hr><h3><a name="pdf-loadstring"><code>loadstring (string [, chunkname])</code></a></h3>

<p>
与<a href="#pdf-load"><code>load</code></a>类似，但是从给定的字符串获得单元。

<p>
要载入并运行给定的字符串，使用惯用法：

<pre>
     assert(loadstring(s))()
</pre>

<p>
当省略时，<code>chunkname</code>缺省为给定的字符串。

<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>

<p>
允许程序遍历标的所有字段。它的第一参数是表，第二参数是该表中的索引。<code>next</code>返回表的下一个索引及其关联的值。当以<b>nil</b>作为第二参数调用时，<code>next</code>返回初始索引和关联的值。当以最后的索引调用或以<b>nil</b>调用空表时，<code>next</code>返回<b>nil</b>。如果省略第二参数，它被解释为<b>nil</b>。特别地，可用<code>next(t)</code>测试表是否为空。

<p>
索引被列举的顺序是未指定的，<em>即使是数字索引</em>。（要以数字顺序遍历表，使用数字<b>for</b>或<a href="#pdf-ipairs"><code>ipairs</code></a>函数。）

<p>
如果在遍历期间给表中不存在的字段赋任意值，则<code>next</code>的行为是<em>未定义的</em>。然而，你可以修改已经存在的字段。特别地，你可以清空已经存在的字段。

<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>

<p>
返回三个值：<a href="#pdf-next"><code>next</code></a>函数、表<code>t</code>和<b>nil</b>，所以结构

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
将迭代表<code>t</code>的所有键-值对。

<p>
参阅函数<a href="#pdf-next"><code>next</code></a>关于其遍历期间对表修改的警告。

<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f, arg1, &middot;&middot;&middot;)</code></a></h3>

<p>
用给定参数以<em>保护模式（protected mode）</em>调用函数<code>f</code>。这意味着<code>f</code>内的任何错误都不被传播；代替的做法是，<code>pcall</code>捕获错误并返回一个状态码。它的第一结果是状态码（布尔），如果调用成功无误则为true。在这种情况下，<code>pcall</code>也在第一结果之后返回来自调用的所有结果。在任何错误的情况下，<code>pcall</code>返回<b>false</b>以及错误消息。

<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
接受任意数量的参数，打印它们的值到<code>标准输出（stdout）</code>，方式是利用<a href="#pdf-tostring"><code>tostring</code></a>函数将他们转换为字符串。<code>print</code>不是打算给格式化的输出使用的，而是作为一种快速显示值的方式，特别是对调试。对于格式化的输出，使用<a href="#pdf-string.format"><code>string.format</code></a>。

<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
检查<code>v1</code>与<code>v2</code>是否相等，不会调用任何元方法。返回布尔值。

<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
获取<code>table[index]</code>的实际值，不会调用任何元方法。<code>table</code>必须是个表；<code>index</code>可以是任何值。

<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
设置<code>table[index]</code>的实际值为<code>value</code>，不会调用任何元方法。<code>table</code>必须是个表，<code>index</code>可以是任何非<b>nil</b>值，并且<code>value</code>可以是任何Lua值。

<p>
该函数返回<code>表</code>。

<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>

<p>
如果<code>index</code>是数字，返回参数数字<code>index</code>之后的所有参数。否则，<code>index</code>必须是字符串<code>"#"</code>，并且<code>select</code>返回它收到的而外参数的总数。

<p>
<hr><h3><a name="pdf-setfenv"><code>setfenv (f, table)</code></a></h3>

<p>
设置给定函数要用的环境。<code>f</code>可以是Lua函数或栈中指定级别的函数：级别1是调用<code>setfenv</code>的函数。<code>setfenv</code>返回给定的函数。

<p>
作为特例，当<code>f</code>为0时<code>setfenv</code>改变当前运行线程的环境。在该情况下，<code>setfenv</code>不返回值。

<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>

<p>
为给定表设置元表。（你不能从Lua中改变其他类型的元表，只能从C中。）如果<code>metatable</code>为空<b>nil</b>，移除给定表的元表。如果原始元表具有<code>"__metatable"</code>字段，产生一个错误。

<p>
该函数返回<code>表</code>。

<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>
尝试将参数转换为数字。如果参数已经是数字或可转换为数字的字符串，则<code>tonumber</code>返回该数字；否则返回<b>nil</b>。

<p>
可选参数指定如何解释数字的基数。基数可以是2和36之间的任何整数，也包括它们。在高于10的基数中，字母'<code>A</code>'（大小写皆可）表示10，'<code>B</code>'表示11，依次类推，直到'<code>Z</code>'表示35。在基数为10（缺省）时，数字可有小数部分，也可有可选的指数部分（见<a href="#2.1">&sect;2.1</a>）。其他基数只接受无符号整数。

<p>
<hr><h3><a name="pdf-tostring"><code>tostring (e)</code></a></h3>
接受任意类型的参数并以合理的格式将其转换为字符串。对于完全控制数字如何转换，使用<a href="#pdf-string.format"><code>string.format</code></a>。

<p>
如果<code>e</code>的元表有<code>"__tostring"</code>字段，则<code>tostring</code>以<code>e</code>为参数调用相应的值，并用调用的结果为其结果。

<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
返回其仅有参数的类型，编码为一个字符串。该函数的可能结果是"<code>nil</code>"（字符串，不是值<b>nil</b>）、"<code>number</code>"、"<code>string</code>"、"<code>boolean</code>"、"<code>table</code>"、"<code>function</code>"、"<code>thread</code>"和"<code>userdata</code>"。

<p>
<hr><h3><a name="pdf-unpack"><code>unpack (list [, i [, j]])</code></a></h3>
返回给定标的元素。该函数等价于

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
除了上面的代码只能用在元素数量固定的情况。缺省时，<code>i</code>是1而<code>j</code>是列表的长度，就像取长操作符（见<a href="#2.5.5">&sect;2.5.5</a>）定义的那样。

<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
保存含有当前解释器版本的字符串的全局变量（非函数）。该变量的当前内容是“<code>Lua 5.1</code>”。

<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, err)</code></a></h3>

<p>
该函数类似<a href="#pdf-pcall"><code>pcall</code></a>，除了可以设置新的错误处理器。

<p>
<code>xpcall</code>用<code>err</code>作为错误处理器，在保护模式中调用函数<code>f</code>。<code>f</code>内的错误不被传播；代替做法是，<code>xpcall</code>捕获错误，以原始错误对象调用<code>err</code>函数，并返回一个状态码。它的第一结果是状态码（布尔值），如果调用成功无误则为true。在该情况下，<code>xpcall</code>也在该第一结果后面返回来自调用的所有结果。在错误的情况下，<code>xpcall</code>返回<b>false</b>以及来自<code>err</code>的结果。

<h2>5.2 - <a name="5.2">协程操作</a></h2>

<p>
涉及协程的操作由基础库的一个子库组成，并且出现在表<a name="pdf-coroutine"><code>coroutine</code></a>内。关于协程的全面描述见<a href="#2.11">&sect;2.11</a>。

<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>

<p>
用<code>f</code>主体创建一个新协程。<code>f</code>必须是Lua函数。返回该新协程，它是类型为“<code>thread</code>”的对象。

<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>

<p>
启动或继续协程<code>co</code>的执行。首次恢复协程时，它启动运行协程主体。值<code>val1</code>, &middot;&middot;&middot;是传入主体函数的参数。如果协程被中断了，<code>resume</code>重新启动它；值<code>val1</code>, &middot;&middot;&middot;是从yield传来的结果。

<p>
如果协程运行无误，<code>resume</code>返回<b>true</b>以及传入<code>yield</code>（如果协程中断）的任何值或由主体函数（如果协程结束）返回的任何值。如果有任何错误，<code>resume</code>返回<b>false</b>以及错误消息。

<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>

<p>
返回运行的协程，或者当被主线程调用时返回<b>nil</b>。

<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>

<p>
返回协程<code>co</code>的状态，以字符串的方式：如果协程正在运行（即是它调用了<code>status</code>）则为“<code>running</code>”；如果协程被<code>yield</code>调用暂停或还未启动运行则为“<code>suspended</code>”；如果协程是活动的但不在运行中（即它恢复了另一个协程）则为“<code>normal</code>”；如果协程结束了它的主体函数或出错停止则为<code>"dead"</code>。

<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>

<p>
用<code>f</code>主体创建一个新协程。<code>f</code>必须是Lua函数。返回一个函数，每次调用它会恢复协程。传入该函数的任何参数都作为<code>resume</code>的额外参数。返回值同<code>resume</code>相同，除了第一个布尔值。在发生错误情况下传播错误。

<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>

<p>
暂停调用者协程的执行。协程不能正在运行C函数、元方法或迭代器。<code>yield</code>的任何参数被传为<code>resume</code>的结果。

<h2>5.3 - <a name="5.3">模块</a></h2>

<p>
打包库为在Lua中加载和创建模块提供基础设备。它直接导出两个函数到全局环境中：<a href="#pdf-require"><code>require</code></a>和<a href="#pdf-module"><code>module</code></a>。其他东西都导出到表<a name="pdf-package"><code>package</code></a>中。

<p>
<hr><h3><a name="pdf-module"><code>module (name [, &middot;&middot;&middot;])</code></a></h3>

<p>
创建一个模块。如果在<code>package.loaded[name]</code>中有个表，该表就是模块。否则，如果有个给定名字的全局表<code>t</code>，该表就是模块。否则创建新表<code>t</code>并把它设为全局<code>name</code>和<code>package.loaded[name]</code>的值。该函数也用给定的名字初始化<code>t._NAME</code>，用模块（<code>t</code>自身）设置<code>t._M</code>，并用包名设置<code>t._PACKAGE</code>（完整模块名减去最后部分；见下）。最后，<code>module</code>设置<code>t</code>为当前函数的新环境和<code>package.loaded[name]</code>的新值，因此<a href="#pdf-require"><code>require</code></a>返回<code>t</code>。

<p>
如果<code>name</code>是个复合名字（即用点号分隔的几个部分），<code>module</code>为每个部分创建（或重用，如果它们已经存在）表。例如，如果<code>name</code>是<code>a.b.c</code>，则<code>module</code>在全局<code>a</code>的字段<code>b</code>的字段<code>c</code>中存储模块表。

<p>
该函数可接受模块名后可选的<em>options</em>，其中每个选项是要加入模块的函数。

<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>

<p>
加载给定模块。该函数先浏览表<a href="#pdf-package.loaded"><code>package.loaded</code></a>确认<code>modname</code>是否已经加载了。如果是，<code>require</code>返回存储在<code>package.loaded[modname]</code>中的值。否则，它尝试为模块找到一个<em>加载器（loader）</em>。

<p>
数组<a href="#pdf-package.loaders"><code>package.loaders</code></a>指示<code>require</code>如何寻找加载器。通过改变该数组，我们可以改变<code>require</code>如何寻找模块。下面的解释基于<a href="#pdf-package.loaders"><code>package.loaders</code></a>的缺省配置。

<p>
<code>require</code>首先查询<code>package.preload[modname]</code>。如果它有值，该值（应是个函数）就是加载器。否则<code>require</code>使用存储在<a href="#pdf-package.path"><code>package.path</code></a>中的路径搜索一个Lua加载器。如果那也失败了，它用存储在<a href="#pdf-package.cpath"><code>package.cpath</code></a>中的路径搜索一个C加载器。如果也失败了，它尝试一个<em>一体化（all-in-one）</em>加载器（见<a href="#pdf-package.loaders"><code>package.loaders</code></a>）。

<p>
一旦找到，<code>require</code>用单个参数<code>modname</code>调用这个加载器。如果加载器返回任何值，<code>require</code>把返回值赋给<code>package.loaded[modname]</code>。如果加载器不返回值而且没有赋给<code>package.loaded[modname]</code>任何值，<code>require</code>把<b>true</b>赋给该条目。在任何情况下，<code>require</code>返回<code>package.loaded[modname]</code>的最终值。

<p>
如果加载或运行模块时发生任何错误，或者如果不能为模块找到任何加载器，<code>require</code>导致一个错误。

<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>

<p>
该路径被<a href="#pdf-require"><code>require</code></a>用于搜索一个C加载器。

<p>
Lua用同初始化Lua路径<a href="#pdf-package.path"><code>package.path</code></a>一样的方式初始化C路径<a href="#pdf-package.cpath"><code>package.cpath</code></a>，利用环境变量<a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>或一个定义在<code>luaconf.h</code>中的缺省路径。

<p>

<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>

<p>
被<a href="#pdf-require"><code>require</code></a>用来控制已经加载了哪些模块。当你require一个模块<code>modname</code>而且<code>package.loaded[modname]</code>不为假时，<a href="#pdf-require"><code>require</code></a>只是返回存储在那儿的值。

<p>
<hr><h3><a name="pdf-package.loaders"><code>package.loaders</code></a></h3>

<p>
被<a href="#pdf-require"><code>require</code></a>用来控制如何加载模块的表。

<p>
该表的每个条目是个<em>搜索器函数（searcher function）</em>。当查找模块时，<a href="#pdf-require"><code>require</code></a>按照升序逐个调用这些搜索器，并用模块名（传给<a href="#pdf-require"><code>require</code></a>的参数）作为它的唯一参数。该函数可返回另一个函数（模块<em>加载器</em>）或一条解释为何没找到模块的字符串（或<b>nil</b>，如果没话可说）。Lua用四个函数初始化该表。

<p>
第一个搜索器只是在表<a href="#pdf-package.preload"><code>package.preload</code></a>中查找加载器。

<p>
第二个搜索器（把模块）作为Lua库使用存储于<a href="#pdf-package.path"><code>package.path</code></a>中的路径查找加载器。路径是由分号分隔的一系列<em>模板（template）</em>。对每个模板，搜索器将模板中的每个问号改为<code>filename</code>，后者是模块名，它的每个点号都被替换为“目录分隔符（directory separator）”（例如Unix中的<code>/</code>）；然后它将尝试打开合成的文件名。因此，例如，如果Lua路径是字符串

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
对模块<code>foo</code>的Lua文件的搜索将尝试按顺序打开文件<code>./foo.lua</code>、<code>./foo.lc</code>和<code>/usr/local/foo/init.lua</code>。

<p>
第三个搜索器（把模块）作为C库用变量<a href="#pdf-package.cpath"><code>package.cpath</code></a>给出的路径查找加载器。例如，如果C路径是字符串

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
对模块<code>foo</code>的搜索将尝试按顺序打开文件<code>./foo.so</code>、<code>./foo.dll</code>和<code>/usr/local/foo/init.so</code>。一旦找到C库，该搜索器首先用动态链接设备链接应用和库。然后尝试在库内查找一个将用作加载器的C函数。该C函数的名字是“<code>luaopen_</code>”同模块名的拷贝连接得到的字符串，模块名的每个点号被下划线替换。此外，如果模块名有个连字符，它的直到（并且包括）第一个连字符的前缀被移除。例如，如果模块名是<code>a.v1-b.c</code>，函数名将是<code>luaopen_b_c</code>。

<p>
第四个搜索器尝试一个<em>一体化加载器</em>。它在C路径中为给定模块的根名搜索库。例如，当请求<code>a.b.c</code>时，它将为<code>a</code>搜索C库。如果找到了，在其中为子模块查找打开函数；在我们的例子中是<code>luaopen_a_b_c</code>。利用该设备，包可以将若干C子模块打包在单个库中，其中的每个子模块持有自己的原始打开函数。

<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>

<p>
把C库<code>libname</code>动态链接到宿主程序。在库内查找函数<code>funcname</code>并作为C函数返回。（所以，<code>funcname</code>必须遵循协议（见<a href="#lua_CFunction"><code>lua_CFunction</code></a>））。

<p>
这是个低级函数。它完全绕过包和模块系统。不像<a href="#pdf-require"><code>require</code></a>，它不执行任何陆路径搜索也不会自动地增加扩展名。<code>libname</code>必须是C库的完全文件名，如果需要还包括路径和扩展名。<code>funcname</code>必须是确切的C库导出的名字（依赖C编译器和链接器）。

<p>
该函数不被ANSI C支持。同样，它只在某些平台可用（Windows、Linux、Mac OS X、Solaris、BSD，以及支持<code>dlfcn</code>标准的其他Unix系统）。

<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>

<p>
该路径被<a href="#pdf-require"><code>require</code></a>用来搜索一个Lua加载器。

<p>
Lua在启动时用环境变量<a name="pdf-LUA_PATH"><code>LUA_PATH</code></a>的值初始化该变量，或者如果该环境变量未定义则用定义在<code>luaconf.h</code>中的缺省路径。环境变量的值中的任何“<code>;;</code>”都被替换为缺省路径。

<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>

<p>
用于特定模块存储加载器的表。（见<a href="#pdf-require"><code>require</code></a>）。

<p>
<hr><h3><a name="pdf-package.seeall"><code>package.seeall (module)</code></a></h3>

<p>
为<code>module</code>设置元表，其<code>__index</code>字段引用全局变量，所以该模块继承全局变量的值。将要被用作函数<a href="#pdf-module"><code>module</code></a>的一个选项。

<h2>5.4 - <a name="5.4">字符串操作</a></h2>

<p>
该库为字符串操作提供常规函数，例如查找和抽取子串以及模式匹配。在Lua中索引字符串时，第一个字符在位置1（不像C是在0处）。索引允许为负数，被解释为从字符串末尾往回索引。因此，最后一个字符在-1位置，依此类推。

<p>
字符串库在表<a name="pdf-string"><code>string</code></a>内提供所有函数。它也给字符串设置元表，其中的<code>__index</code>字段指向<code>string</code>表。因此，你可以使用面向对象风格的字符串函数。例如，<code>string.byte(s, i)</code>可写为<code>s:byte(i)</code>。

<p>
字符串库采取单字节字符编码方式。

<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
返回字符<code>s[i]</code>, <code>s[i+1]</code>, &middot;&middot;&middot;, <code>s[j]</code>的内部数字代码。<code>i</code>缺省为1；<code>j</code>缺省为<code>i</code>。

<p>
注意数字代码不一定是跨平台可移植的。

<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
接受0获多个整数。返回一个字符串，其长度等于参数个数，其中的每个字符的内部数字代码等于相应的参数。

<p>
注意数字代码不一定是跨平台可移植的。

<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function)</code></a></h3>

<p>
返回给定函数的二进制表示的字符串，之后在其上应用<a href="#pdf-loadstring"><code>loadstring</code></a>返回函数的拷贝。<code>function</code>必须是不带upvalueLua函数。

<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>
在字符串<code>s</code>中查找<code>pattern</code>的第一个匹配。如果找到则返回它开始和结束处在<code>s</code>中的索引；否则，返回<b>nil</b>。可选的第三参数<code>init</code>是数字，指定从哪儿开始搜索；其缺省值是1并且可为负数。如果<b>真</b>值作为可选的第四参数<code>plain</code>，则关闭模式匹配设备，所以函数执行无格式的“查找子串”操作，<code>pattern</code>中的字符并不被认为是“魔术的（magic）”。注意，如果给出了<code>plain</code>，则<code>init</code>也必须给出。

<p>
如果模式具有捕获（capture），则在成功的匹配中被捕获的值也在两个索引后面返回。

<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>
Returns a formatted version of its variable number of arguments
following the description given in its first argument (which must be a string).
格式字符串遵循同<code>printf</code>族标准C函数同样的规则。仅有的区别是不支持<code>*</code>、<code>l</code>、<code>L</code>、<code>n</code>、<code>p</code>和<code>h</code>等选项/修饰符，而且有个额外选项<code>q</code>。<code>q</code>选项以可安全地为Lua解释器读取的适当形式格式化字符串：字符串被写在双引号之间，而且字符串中的所有双引号、换行、内嵌的0和反斜杠被恰当地转义。例如，调用

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
产生字符串：

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
选项<code>c</code>、<code>d</code>、<code>E</code>、<code>e</code>、<code>f</code>,
<code>g</code>、<code>G</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>X</code>和<code>x</code>都预期得到数字作为参数，然而<code>q</code>和<code>s</code>期望得到字符串。

<p>
该函数不接受含有内嵌的0的字符串值，除了作为<code>q</code>选项的参数。

<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
返回一个迭代器函数，每次调用返回来自<code>pattern</code>的下一个捕获，从字符串<code>s</code>开头直到结尾。如果<code>pattern</code>没指定捕获则每次调用产生整个匹配。

<p>
作为例子，下面的循环

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
将迭代来自字符串<code>s</code>的所有单词，每行打印一个。下一个例子从给定的字符串收集所有的<code>键=值</code>对放在表中：

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "^(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
对于该函数，模式起始处的‘<code>^</code>’不能作为锚点，因为这会阻止迭代。

<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
返回<code>s</code>的拷贝，其中出现的所有（或前<code>n</code>个，如果指定）<code>pattern</code>被替换为<code>repl</code>——可以是字符串、表或函数，指定的替换串。<code>gsub</code>也返回出现的匹配的总数作为第二个值。

<p>
如果<code>repl</code>是字符串，它的值被用作替换式。字符<code>%</code>用作转义字符：<code>repl</code>中的任何形如<code>%<em>n</em></code>的序列代表第<em>n</em>个捕获的子串（见下面），其中<em>n</em>在1和9之间。序列<code>%0</code>代表整个匹配。序列<code>%%</code>代表单个<code>%</code>。

<p>
如果<code>repl</code>是表，则对于每个匹配，用第一个捕获作为键查询表；如果模式未指定捕获，则整个匹配被用作键。

<p>
如果<code>repl</code>是函数，则每次匹配发生时都按顺序传入所有捕获的子串作为参数调用该函数；如果模式没指定捕获，则整个匹配作为单个参数传入。

<p>
如果表查询或函数调用返回的结果是个字符串或数字，则被用作替换串；否则，如果是<b>false</b>或<b>nil</b>，则不发生替换（即原始匹配被保持在字符串中）。

<p>
这里有一些例子：

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.1"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.1.tar.gz"
</pre>

<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
接受字符串并返回其长度。空串<code>""</code>长度为0。内嵌的0被计算在内，所以<code>"a\000bc\000"</code>长度为5。

<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
接受字符串并返回其所有大写字母变为小写的拷贝。所有其他字符不变。大写字母的定义依赖于当前locale。

<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
在字符串<code>s</code>中查找<code>pattern</code>的首次<em>匹配</em>。如果找到一个，则返回来自模式的捕获；否则返回<b>nil</b>。如果<code>pattern</code>未指定捕获则返回整个匹配。可选的第三个参数<code>init</code>是数字，指定从哪儿开始搜索；其缺省值是1并且可为负。

<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n)</code></a></h3>
返回字符串<code>s</code>的<code>n</code>个拷贝拼接字符串。

<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
返回字符串<code>s</code>的颠倒的字符串。

<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
返回<code>s</code>的子串，它起始于<code>i</code>并延续到<code>j</code>；<code>i</code>和<code>j</code>可为负数。如果省略<code>j</code>，则它被假定为-1（同字符串长度一样）。特别地，调用<code>string.sub(s,1,j)</code>返回<code>s</code>长为<code>j</code>的前缀，而且<code>string.sub(s, -i)</code>返回<code>s</code>长为<code>i</code>的后缀。

<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
接受字符串并返回其所有小写字母变为大写的拷贝。所有其他字符不变。小写字母的定义依赖于当前locale。

<h3>5.4.1 - <a name="5.4.1">模式</a></h3>

<h4>字符类（Character Class）：</h4><p>
一个<em>字符类</em>被用于表示一组字符。允许用下面的组合描述字符类：

<ul>

<li><b><em>x</em>:</b> （此处<em>x</em>不是<em>魔术字符</em><code>^$()%.[]*+-?</code>中的一个）表示字符<em>x</em>本身。
</li>

<li><b><code>.</code>:</b> （一个点）表示所有字符。</li>

<li><b><code>%a</code>:</b> 表示所有字母。</li>

<li><b><code>%c</code>:</b> 表示所有控制字符。</li>

<li><b><code>%d</code>:</b> 表示所有十进制数字。</li>

<li><b><code>%l</code>:</b> 表示所有小写字母。</li>

<li><b><code>%p</code>:</b> 表示所有标点符号。</li>

<li><b><code>%s</code>:</b> 表示所有空白字符。</li>

<li><b><code>%u</code>:</b> 表示所有大写字母。</li>

<li><b><code>%w</code>:</b> 表示所有字母数字字符。</li>

<li><b><code>%x</code>:</b> 表示所有十六进制数字。</li>

<li><b><code>%z</code>:</b> 表示0值字符。</li>

<li><b><code>%<em>x</em></code>:</b> （此处<em>x</em>是任何非字母数字字符）表示字符<em>x</em>。这是转义魔术字符的标准方式。当被用于在模式中表示自身时，任何标点符号（甚至非魔术的）都能前缀一个‘<code>%</code>’。
</li>

<li><b><code>[<em>set</em>]</code>:</b> 表示<em>set</em>中的所有字符的联合构成的分类。通过用‘<code>-</code>’分隔截止字符可以指定某个范围的字符。上面描述的所有种类的<code>%</code><em>x</em>都可用作<em>set</em>的部件。<em>set</em>中的所有其他字符表示它们自身。例如<code>[%w_]</code>（或<code>[_%w]</code>）表示所有字母数字字符和下划线，<code>[0-7]</code>表示八进制数字，<code>[0-7%l%-]</code>表示八进制数字和小写字母以及‘<code>-</code>’字符。

<p>
字符范围和字符类之间的相互作用是未定义的。因此类似<code>[%a-z]</code>或<code>[a-%%]</code>的模式没有意义。
</li>

<li><b><code>[^<em>set</em>]</code>:</b> 表示<em>set</em>的补集，其中的<em>set</em>在上面解释了。
</li>

</ul><p>
所有单字母表示的字符类（<code>%a</code>、<code>%c</code>，等等），相应的大写字母表示该字符类的补集。例如，<code>%S</code>表示所有非空白符。

<p>
字母、空白和其他字符组合的定义依赖于当前locale。特别地，字符类<code>[a-z]</code>可能不等于<code>%l</code>。

<h4>模式项（Pattern Item）:</h4><p> <em>模式项</em>可为

<ul>

<li>
单个字符类，它匹配该类中的任意单个字符；
</li>

<li>
后跟‘<code>*</code>’的单个字符类，它匹配该类中的0或多个字符。这些重复项将总是匹配最长的可能序列；
</li>

<li>
后跟‘<code>+</code>’的单个字符类，它匹配该类中的1或多个字符。这些重复项将总是匹配最长的可能序列；
</li>

<li>
后跟‘<code>-</code>’的单个字符类，它也匹配该类中的0或多个字符。与‘<code>*</code>’不同，这些重复项将总是匹配<em>最短的</em>可能序列；
</li>

<li>
后跟‘<code>?</code>’的单个字符类，它匹配出现0或1次该类中的字符；
</li>

<li>
<code>%<em>n</em></code>，其中<em>n</em>在1和9之间；这种项匹配一个等价于捕获的字符串的第<em>n</em>个子串（见下面）；
</li>

<li>
<code>%b<em>xy</em></code>其中<em>x</em>和<em>y</em>是两个不同的字符；这种项匹配始于<em>x</em>终于<em>y</em>的字符串，并且<em>x</em>和<em>y</em>是<em>对称的</em>。这表示，如果一个人从左到右读字符串，对<em>x</em>计数为<em>+1</em>，对<em>y</em>计数为<em>-1</em>，结尾的<em>y</em>是第一个遇到计数为0的<em>y</em> 。例如，项<code>%b()</code>匹配带有平衡的圆括号的表达式。
</li>

</ul>

<h4>模式（Pattern）:</h4><p> <em>模式</em>是一系列的模式项。在模式开头的‘<code>^</code>’将匹配固定在源串的开头。 在模式结尾的‘<code>$</code>’将匹配固定在源串的结尾。在其他位置上，‘<code>^</code>’和‘<code>$</code>’没有特殊含义，表示它们自身。

<h4>捕获（Captures）:</h4><p> 模式可以含有括在圆括号内的子模式；它们描述<em>捕获</em>。当成功进行一个匹配，源串中匹配捕获的子串被存储（<em>捕获</em>）以便将来使用。捕获根据它们的左圆括号进行编号。例如，在模式<code>"(a*(.)%w(%s*))"</code>中，字符串的匹配<code>"a*(.)%w(%s*)"</code>的部分作为第一个捕获被存储（因此被编号为1）；匹配“<code>.</code>”的字符被捕获并编号为2，匹配“<code>%s*</code>”的部分被编号为3。

<p>
作为一种特殊情况，空捕获<code>()</code>捕获当前字符串位置（一个数字）。例如，如果我们把模式<code>"()aa()"</code>用于字符串<code>"flaaap"</code>，将有两个捕获：3和5。

<p>
模式不能含有内嵌的0。使用<code>%z</code>代替。

<h2>5.5 - <a name="5.5">表操作</a></h2><p>
该库为表操作处理提供常规函数。它在表<a name="pdf-table"><code>table</code></a>内提供其所有函数。

<p>
表中的多数函数假定给定的表表示数组或列表。对于这些函数，当我们谈到表的“长度”时，我们意指取长操作符的结果。

<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (table [, sep [, i [, j]]])</code></a></h3>
给定一个数组，其所有元素是字符串或数字，返回<code>table[i]..sep..table[i+1] &middot;&middot;&middot; sep..table[j]</code>。<code>sep</code>的缺省值是空字符串，<code>i</code>的缺省值是1，<code>j</code>的缺省值是表的长度。如果<code>i</code>比<code>j</code>大，返回空字符串。

<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (table, [pos,] value)</code></a></h3>

<p>
在表<code>table</code>的<code>pos</code>位置插入元素<code>value</code>，如果需要将其他元素上移到开放空间。<code>pos</code>的缺省值是<code>n+1</code>，其中<code>n</code>是表的长度（见<a href="#2.5.5">&sect;2.5.5</a>），所以调用<code>table.insert(t,x)</code>在表<code>t</code>结尾插入<code>x</code>。

<p>
<hr><h3><a name="pdf-table.maxn"><code>table.maxn (table)</code></a></h3>

<p>
返回给定表的最大正数索引，如果没有正数索引则返回0。（该函数执行一次整个表的线性遍历来做这个工作。）

<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (table [, pos])</code></a></h3>

<p>
从<code>table</code>中删除在位置<code>pos</code>处的元素，如果需要会下移其他元素以缩紧空格。返回被删除的值。<code>pos</code>的缺省值是表的长度<code>n</code>，所以调用<code>table.remove(t)</code>删除表<code>t</code>的最后一个元素。

<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (table [, comp])</code></a></h3>
从<code>table[1]</code>到<code>table[n]</code>将表元素排序为给定顺序的<em>适当位置</em>，其中<code>n</code>是表的长度。如果给出了<code>comp</code>，它必须是个函数，接受两个表元素并当第一个小于第二个时返回true（所以排序后<code>not comp(a[i+1],a[i])</code>将为true）。如果未给出<code>comp</code>，则使用标准的Lua操作符<code>&lt;</code>代替。

<p>
排序算法不稳定；就是说，被指定顺序认为相等的元素可能被排序改变相对位置。

<h2>5.6 - <a name="5.6">数学运算函数</a></h2>

<p>
该库是标准C数学库的接口。它在表<a name="pdf-math"><code>math</code></a>中提供所有函数。

<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>

<p>
返回<code>x</code>的绝对值。

<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>

<p>
返回<code>x</code>（弧度）的反余弦值。

<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>

<p>
返回<code>x</code>（弧度）的反正弦值。

<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (x)</code></a></h3>

<p>
返回<code>x</code>（弧度）的反正切值。

<p>
<hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)</code></a></h3>

<p>
返回<code>y/x</code>（弧度）的反正切值，但用两个参数的正负号找到结果的象限。（它也能正确地处理<code>x</code>为0的情况。）

<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>

<p>
返回大于或等于<code>x</code>的最小整数。

<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>

<p>
返回<code>x</code>（假定用弧度）反余弦值。

<p>
<hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)</code></a></h3>

<p>
返回<code>x</code>的双曲余弦值。

<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>

<p>
返回角<code>x</code>（以弧度给出）的角度值。

<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>

<p>
返回值<em>e<sup>x</sup></em>。

<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>

<p>
返回小于或等于<code>x</code>的最大整数。

<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>

<p>
返回<code>x</code>被<code>y</code>除的余数，向0的方向对商四舍五入。

<p>
<hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)</code></a></h3>

<p>
返回<code>m</code>和<code>e</code>使得<em>x = m2<sup>e</sup></em>，<code>e</code>是整数，<code>m</code>的绝对值在<em>[0.5, 1)</em>区间内（当<code>x</code>是0时则为0）。

<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>

<p>
值<code>HUGE_VAL</code>，大于或等于其他数字值。

<p>
<hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)</code></a></h3>

<p>
返回<em>m2<sup>e</sup></em>（<code>e</code>应为整数）。

<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x)</code></a></h3>

<p>
返回<code>x</code>的自然对数。

<p>
<hr><h3><a name="pdf-math.log10"><code>math.log10 (x)</code></a></h3>

<p>
返回<code>x</code>以10为底的对数。

<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>

<p>
返回其参数中的最大值。

<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>

<p>
返回其参数中的最小值。

<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>

<p>
返回两个数，<code>x</code>的正数部分和小数部分。

<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>

<p>
值<em>pi</em>。

<p>
<hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)</code></a></h3>

<p>
返回<em>x<sup>y</sup></em>。（也能用表达式<code>x^y</code>计算该值。）

<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>

<p>
返回角<code>x</code>（以角度给出）的弧度值。

<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>

<p>
该函数是ANSI C提供的简单的伪随机产生器函数<code>rand</code>的接口。（不担保其统计特性。）

<p>
当不带参数调用时，返回<em>[0,1)</em>区间内的一致的伪随机实数。当带一个整数<code>m</code>调用时，返回<em>[1, m]</em>区间内的一致的伪随机实数。当带两个整数<code>m</code>和<code>n</code>调用时，返回<em>[m, n]</em>区间内的一致的伪随机实数。

<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>

<p>
设置<code>x</code>为伪随机产生器的“种子”：相等的种子产生相等的数字序列。

<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>

<p>
返回<code>x</code>（假定用弧度）的正弦值。

<p>
<hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)</code></a></h3>

<p>
返回<code>x</code>的双曲正弦值。

<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>

<p>
返回<code>x</code>的平方根。（也能用表达式<code>x^0.5</code>计算该值。）

<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>

<p>
返回<code>x</code>（假定用弧度）的正切值。

<p>
<hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)</code></a></h3>

<p>
返回<code>x</code>的双曲正切值。

<h2>5.7 - <a name="5.7">输入输出设备</a></h2>

<p>
I/O库提供两种不同风格的文件处理。第一种使用隐式文件描述符；即提供操作设置缺省的输入文件和缺省的输出文件，并且所有输入/输出操作都用在这些缺省文件上。第二中风格使用显式的文件描述符。

<p>
当使用隐式文件描述符时，所有操作通过表<a name="pdf-io"><code>io</code></a>提供。当使用显式文件描述符时，操作<a href="#pdf-io.open"><code>io.open</code></a>返回一个文件描述符，然后所有操作作为它的方法提供。

<p>
表<code>io</code>也提供三个预定义的文件描述符，具有来自于C的通常含义：<a name="pdf-io.stdin"><code>io.stdin</code></a>、<a name="pdf-io.stdout"><code>io.stdout</code></a>和<a name="pdf-io.stderr"><code>io.stderr</code></a>。I/O库从不关闭这些文件。

<p>
除非另作说明，否则所有I/O在函数失败时返回<b>nil</b>（以及一条错误消息作为第二结果和一个依赖系统的错误代码作为第三结果）并在成功时返回不同于<b>nil</b>的某个值。

<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>

<p>
相当于<code>file:close()</code>。不带<code>file</code>则关闭缺省的输出文件。

<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>

<p>
相当于<code>file:flush</code>，作用于缺省得输出文件。

<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>

<p>
用文件名调用时，它打开该命名文件（以文本模式），并设置其句柄为缺省的输入文件。用文件句柄调用时，它只是设置该文件句柄为缺省的输入文件。不带参数调用时，它返回当前的缺省的输入文件。

<p>
在错误的情况下，该函数抛出错误而不是返回错误代码。

<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename])</code></a></h3>

<p>
以读取模式打开给定的文件名并返回一个迭代函数，每次调用会返回来自文件的新行。因此，结构

<pre>
     for line in io.lines(filename) do <em>body</em> end
</pre><p>
会迭代文件的所有行。当迭代函数监测到文件结尾时，返回<b>nil</b>（以结束循环）并自动关闭文件。

<p>
调用<code>io.lines()</code>（不带参数）等价于<code>io.input():lines()</code>；即迭代缺省输入文件的所有行。该情况下当循环结束时不会关闭文件。

<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>

<p>
该函数以字符串<code>mode</code>指定的模式打开文件。它返回新文件句柄，或者错误时返回<b>nil</b>以及一条错误消息。

<p>
<code>mode</code>字符串可为下面的任意一个：

<ul>
<li><b>"r":</b> 读模式（缺省）；</li>
<li><b>"w":</b> 写模式；</li>
<li><b>"a":</b> 附加模式；</li>
<li><b>"r+":</b> 更新模式，保留所有以前的数据；</li>
<li><b>"w+":</b> 更新模式，擦除所有以前的数据；</li>
<li><b>"a+":</b> 附加更新模式，保留所有以前的数据，只允许在文件结尾写。</li>
</ul><p>
<code>mode</code>字符串也可在结尾有个‘<code>b</code>’，在某些系统中需要它以二进制模式打开文件。该字符串恰是用在标准C函数<code>fopen</code>中的。

<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>

<p>
类似<a href="#pdf-io.input"><code>io.input</code></a>，但操作的是缺省输出文件。

<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>

<p>
在独立进程中打开程序<code>prog</code>并返回文件句柄，可用它从该程序中读取数据（如果<code>mode</code>是<code>"r"</code>，缺省）或向该程序写入数据（如果<code>mode</code>是<code>"w"</code>）。

<p>
该函数是系统依赖的而且并非可用于所有平台。

<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>

<p>
等价于<code>io.input():read</code>。

<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>

<p>
返回一个临时文件的句柄。该文件以更新模式打开，并在程序结束时自动删除。

<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>

<p>
检查<code>obj</code>是否可用的文件句柄。如果是打开的文件句柄则返回字符串<code>"file"</code>，如果是打开的文件句柄则返回<code>"closed file"</code>，或者如果不是文件句柄则返回<b>nil</b> if <code>obj</code>。

<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>

<p>
等价于<code>io.output():write</code>。

<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>

<p>
关闭<code>file</code>。注意，当其句柄被垃圾收集时，文件被自动关闭，但那需要不可预知的漫长时间才会发生。

<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>

<p>
把任何已写数据存入<code>file</code>。

<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines ()</code></a></h3>

<p>
返回迭代器函数，每次调用返回来自文件的新行。因此，结构

<pre>
     for line in file:lines() do <em>body</em> end
</pre><p>
会迭代文件的所有行。（与<a href="#pdf-io.lines"><code>io.lines</code></a>不同，当循环结束时该函数不会关闭文件。）

<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>

<p>
依照给定格式读取文件<code>file</code>，该格式制定要读取什么。对于每种格式，该函数返回读取得字符串（或数字），或者如果不能读取指定格式的数据则返回<b>nil</b>。当不带格式调用时，它用读取整个下一行的缺省格式（见下面）。

<p>
可用格式是

<ul>

<li><b>"*n":</b> 读取一个数字；这是返回数字而非字符串的唯一格式。
</li>

<li><b>"*a":</b> 从当前位置开始读取整个文件。在文件结尾时返回空串。
</li>

<li><b>"*l":</b>
读取下一行（跳过行尾），在文件结尾时返回<b>nil</b>。这是缺省格式。
</li>

<li><b><em>number</em>:</b> 读取字符串直到该数量的字符串，在文件结尾时返回<b>nil</b>。如果数字是0，它什么也不读并返回空串，或在文件结尾时返回<b>nil</b>。
</li>

</ul>

<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence] [, offset])</code></a></h3>

<p>
设置和获取由文件开头开始量度的文件位置，目标位置由<code>offset</code>加字符串<code>whence</code>指定的基点给出。如下：

<ul>
<li><b>"set":</b> 基点是位置0（文件开头）；</li>
<li><b>"cur":</b> 基点是当前位置；</li>
<li><b>"end":</b> 基点是文件结尾；</li>
</ul><p>
成功返回由文件开头开始亮度以字节为单位的最终文件位置。失败则返回<b>nil</b>以及一个描述错误的字符串。

<p>
<code>whence</code>的缺省值是<code>"cur"</code>，<code>offset</code>是0。因此调用<code>file:seek()</code>返回当前文件位置而不改变它；调用<code>file:seek("set")</code>设置位置到文件开头（并返回0）；调用<code>file:seek("end")</code>设置位置到文件结尾，并返回其尺寸。

<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>

<p>
设置输出文件的缓冲模式。有三种可用模式：

<ul>

<li><b>"no":</b> 无缓冲；任何输出操作的结果立刻出现。
</li>

<li><b>"full":</b> 完全缓冲；只在缓冲区满时（或者当你显式<code>flush</code>文件（见<a href="#pdf-io.flush"><code>io.flush</code></a>））执行输出操作。
</li>

<li><b>"line":</b> 行缓冲；缓冲输出直到输出了换行或有来自某些特定文件（例如终端设备）的任何输入。
</li>

</ul><p>
对于最后两种情况，<code>size</code>指定缓冲区大小，以字节为单位。缺省是个适当的大小。

<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>

<p>
将每个参数的值写入<code>file</code>。参数必须是字符串或数字。要写其他值，在<code>write</code>之前使用<a href="#pdf-tostring"><code>tostring</code></a>或<a href="#pdf-string.format"><code>string.format</code></a>。

<h2>5.8 - <a name="5.8">操作系统设备</a></h2>

<p>
该库通过表<a name="pdf-os"><code>os</code></a>实现。

<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>

<p>
返回程序已用的CPU时间的近似值，以秒为单位。

<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>

<p>
返回含有日期和时间的字符串或表，依据给定字符串<code>format</code>格式化。

<p>
如果存在参数<code>time</code>，这是要被格式化的时间（对该值的描述间<a href="#pdf-os.time"><code>os.time</code></a>函数）。否则，<code>date</code>格式化当前时间。

<p>
如果<code>format</code>以‘<code>!</code>’开头，则日期被格式化为CUT（Coordinated Universal Time）。在该可选的字符后，如果<code>format</code>是字符串“<code>*t</code>”，则<code>date</code>返回带有下面的字段的表：<code>year</code> （四位数字），<code>month</code> （1--12），<code>day</code> （1--31），<code>hour</code> （0--23），<code>min</code> （0--59），<code>sec</code> （0--61），<code>wday</code> （一周中的第几天，周日是1），<code>yday</code> （年中的第几天）和<code>isdst</code> （日光节约时间标记，布尔值）。

<p>
如果<code>format</code>不是<code>*t</code>”，则<code>date</code>返回日期字符串，依据同C函数<code>strftime</code>一样的规则格式化。

<p>
当不带参数调用时，<code>date</code>返回一个合理的日期和时间表示，依赖于主机系统和当前locale（就是说，<code>os.date()</code>等价于<code>os.date("%c")</code>）。

<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>

<p>
返回从时间<code>t1</code>到时间<code>t2</code>的秒数。在POSIX、Windows和一些其他系统中，该值恰是<code>t2</code><em>-</em><code>t1</code>。

<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>

<p>
该函数等价于C函数<code>system</code>。它传入<code>command</code>给操作系统的shell执行。它返回一个依赖系统的状态码。如果省略<code>command</code>，则如果shell可用会返回非0值否则否则返回0。

<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code])</code></a></h3>

<p>
调用C函数<code>exit</code>结束宿主程序，可带个可选的<code>code</code>。<code>code</code>的缺省值是成功代码。

<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>

<p>
返回进程环境变量<code>varname</code>的值，如果变量未定义则返回<b>nil</b>。

<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>

<p>
删除给定名字的文件或目录。要删除的目录必须为空。如果失败，该函数返回<b>nil</b>以及一条描述错误的字符串。

<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>

<p>
把名为<code>oldname</code>文件或目录重命名为<code>newname</code>。如果失败，该函数返回<b>nil</b>以及一条描述错误的字符串。

<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>

<p>
设置程序的当前locale。<code>locale</code>是个指定locale的字符串；<code>category</code>是可选的字符串，描述了要变更哪个类别：<code>"all"</code>、<code>"collate"</code>、<code>"ctype"</code>、<code>"monetary"</code>、<code>"numeric"</code>或<code>"time"</code>；缺省 category 是<code>"all"</code>。函数返回新locale的名字，如果请求不被认可则返回<b>nil</b>。

<p>
如果<code>locale</code>是空字符串，当前locale被设为定义了本地locale的实现。如果<code>locale</code>是字符串“<code>C</code>”，当前locale被设为标准的C locale。

<p>
当以<b>nil</b>作为第一参数调用时，该函数只返回给定类别的当前locale的名字。

<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>

<p>
当无参调用时返回当前时间，或者返回表示了给定表指定的日期和时间的时间。该表必须具有字段<code>year</code>、<code>month</code>和<code>day</code>，并且可以具有字段<code>hour</code>、<code>min</code>、<code>sec</code>和<code>isdst</code>（对于这些字段的描述，见<a href="#pdf-os.date"><code>os.date</code></a>函数）。

<p>
返回值是个数字，它的含义依赖于你的系统。在POSIX、Windows和某些其他系统中，该数计数自某个给定起始时间（epoch）以来的秒数。在其他系统中，含义是未指定的，而且<code>time</code>返回的数字只能用作<code>date</code>和<code>difftime</code>的参数。

<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>

<p>
返回一个带文件名的字符串，该名字可被用于临时文件。文件在使用前必须显式地打开，并且必须在不再需要时显式地删除。

<p>
在某些系统上（POSIX），该函数也创建那个名字的文件以避免安全风险。（其他人可能在获取名字和创建文件之间的时间内创建带有错误权限的该文件。）你还必须打开该文件来使用它以及删除它（即使你没用它）。

<p>
如果可能，你也许更喜欢使用<a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>，它在程序结束时自动删除文件。

<h2>5.9 - <a name="5.9">调试库</a></h2>

<p>
该库向Lua程序提供调试接口功能。使用该库时你应该异常小心。这儿提供的函数应该专门用于调试和类似的任务，比如profiling。请忍住把它们用作一般编程工具的诱惑：它们非常的慢。而且，这些函数中的一些违反了关于Lua代码的某些假定（例如，函数的局部变量不能从外面访问，或者，用户数据的元表不能被Lua代码改变）并且因此会损害其他的安全代码。

<p>
该库的所有函数在表<a name="pdf-debug"><code>debug</code></a>中提供。所有操作一个线程的函数具有可选的第一参数，它是被操作的线程。缺省总是当前线程。

<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>

<p>
进入同用户的交互模式，运行用户输入的每个字符串。使用简单的命令和其他调试设备，用户能够检查全局和局部变量，改变它们的值，计算表达式，等等。只含有单词<code>cont</code>的行终止该函数，这样调用者继续它的执行。

<p>
注意，<code>debug.debug</code>的命令不是任何函数的内部词汇，因此没有对本地变量的直接访问。

<p>
<hr><h3><a name="pdf-debug.getfenv"><code>debug.getfenv (o)</code></a></h3>
返回对象<code>o</code>的环境。

<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>

<p>
返回线程的当前hook设定，作为三个值：当前hook函数、当前hook掩码和当前hook计数（由函数<a href="#pdf-debug.sethook"><code>debug.sethook</code></a>设置）。

<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] function [, what])</code></a></h3>

<p>
返回带有函数信息的表。你可直接给出函数，或者给出一个数字作为<code>function</code>的值，它表示给定线程的调用栈中运行于级别<code>function</code>的函数：级别0是当前函数（<code>getinfo</code>自己）；级别1是调用<code>getinfo</code>的函数；依次类推。如果<code>function</code>是个比活动的函数数量大的数字，则<code>getinfo</code>返回<b>nil</b>。

<p>
返回的表可包含<a href="#lua_getinfo"><code>lua_getinfo</code></a>返回的所有字段，字符串<code>what</code>描述要填充的字段。<code>what</code>默认获取所有可用信息，除了有效行的表。如果提供，选项‘<code>f</code>’增加名为<code>func</code>的字段，值为函数自己。如果存在，选项‘<code>L</code>’增加名为<code>activelines</code>的字段，值为有效行的表。

<p>
例如，表达式<code>debug.getinfo(1,"n").name</code>返回一个表，其中含有当前函数的名字——如果可以找到合理的名字；表达式<code>debug.getinfo(print)</code>返回带有函数<a href="#pdf-print"><code>print</code></a>的所有可用信息的表。

<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] level, local)</code></a></h3>

<p>
该函数返回栈中<code>level</code>级处的函数的索引为<code>local</code>的局部变量的名字和值。（第一个参数或局部变量索引为1，依次类推，直到最后一个活动的局部变量。）如果没有给定索引的局部变量，该函数返回<b>nil</b>，并且当以超出范围的<code>level</code>调用时抛出错误。（可调用<a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a>来检查级别是否有效。）

<p>
以‘<code>(</code>’（开圆括号）开头的变量名表示内部变量（循环控制变量、临时变量和C函数局部变量）。

<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (object)</code></a></h3>

<p>
返回给定对象<code>object</code>的元表，或者如果没有元表返回<b>nil</b>。

<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>

<p>
返回注册表（见<a href="#3.5">&sect;3.5</a>）。

<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (func, up)</code></a></h3>

<p>
该函数返回函数<code>func</code>的索引为<code>up</code>的upvalue的名字和值。如果没有给定索引的upvalue则返回<b>nil</b>。

<p>
<hr><h3><a name="pdf-debug.setfenv"><code>debug.setfenv (object, table)</code></a></h3>

<p>
设置给定<code>object</code>的环境为给定的<code>table</code>。返回<code>object</code>。

<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>

<p>
设置给定函数作为hook。字符串<code>mask</code>和数字<code>count</code>描述hook何时被调用。字符串掩码可具有下面带有给定含义的字符：

<ul>
<li><b><code>"c"</code>:</b> 每次Lua调用函数时hook被调用；</li>
<li><b><code>"r"</code>:</b> 每次Lua从函数返回时hook被调用；</li>
<li><b><code>"l"</code>:</b> 每次Lua进入代码的新行时hook被调用。</li>
</ul><p>
带非0的<code>count</code>时，hook在每<code>count</code>条指令后被调用。

<p>
当无参调用时，<a href="#pdf-debug.sethook"><code>debug.sethook</code></a>关闭hook。

<p>
当hook被调用时，其第一参数是描述触发其调用的事件的字符串：<code>"call"</code>、<code>"return"</code>（或<code>"tail return"</code>，当模拟从尾调用中返回时）、<code>"line"</code>和<code>"count"</code>。对于行事件，hook也获得新行数为其第二参数。在hook内部，你可以级别2调用<code>getinfo</code>来获得正运行的函数的信息（级别0是函数<code>getinfo</code>并且级别1是hook函数），除非事件是<code>"tail return"</code>。该情况下，Lua只是模拟返回，而且调用<code>getinfo</code>将返回无效数据。

<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>

<p>
该函数把栈中<code>level</code>级函数中索引为<code>local</code>的局部变量赋值为<code>value</code>。如果没有给定索引的局部变量则返回<b>nil</b>，并且当以超出范围的<code>level</code>调用时抛出错误。（你可调用<code>getinfo</code>检查级别是否有效。）否则返回局部变量的名字。

<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (object, table)</code></a></h3>

<p>
设置给定<code>object</code>的元表为给定<code>table</code>（可为<b>nil</b>）。

<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (func, up, value)</code></a></h3>

<p>
该函数给<code>func</code>函数中索引为<code>up</code>的upvalue赋值<code>value</code>。如果没有给定索引的upvalue则返回<b>nil</b>。否则返回upvalue的名字。

<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message] [, level])</code></a></h3>

<p>
返回带有调用栈的回溯的字符串。可选的字符串<code>message</code>被附加到回溯的开头。可选的数字<code>level</code>表明在哪个级别开始回溯（缺省是1，调用<code>traceback</code>的函数）。

<h1>6 - <a name="6">单独使用Lua</a></h1>

<p>
虽然Lua被设计为要嵌入宿主C程序的扩展式语言，它也常被用作独立的语言。随标准分发包提供了Lua作为独立语言的解释器，简单地称为<code>lua</code>。该独立解释器包括含有调试库的所有标准库。
它的用法是：

<pre>
     lua [options] [script [args]]
</pre><p>
选项是：

<ul>
<li><b><code>-e <em>stat</em></code>:</b> 执行字符串<em>stat</em>；</li>
<li><b><code>-l <em>mod</em></code>:</b> “require”<em>mod</em>；</li>
<li><b><code>-i</code>:</b> 运行<em>script</em>后进入交互模式；</li>
<li><b><code>-v</code>:</b> 输出版本信息；</li>
<li><b><code>--</code>:</b> 终止处理选项；</li>
<li><b><code>-</code>:</b> 将<code>stdin</code>作为文件执行并终止处理选项。</li>
</ul><p>
在处理它的选项之后，<code>lua</code>传入给定的<em>args</em>作为字符串参数并运行给定<em>script</em>。当无参调用时，<code>lua</code>行为同标准输入（<code>stdin</code>）是终端时的<code>lua -v -i</code>一样，否则同<code>lua -</code>一样。

<p>
在运行任何参数前，解释器检查环境变量<a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>。如果它的格式是<code>@<em>filename</em></code>，则<code>lua</code>执行这个文件。否则，<code>lua</code>执行字符串自身。

<p>
除了<code>-i</code>所有选项被顺序处理。例如，类似这样的调用

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
将首先设置<code>a</code>为1，然后输出<code>a</code>的值（‘<code>1</code>’），并且最后不带参数运行文件<code>script.lua</code>。（此处<code>$</code>是shell提示符。你的提示符可能不同。）

<p>
在运行脚本（文件）以前，<code>lua</code>收集命令行中的所有参数放在称为<code>arg</code>的全局表中。脚本名被存储在索引0处，脚本名后的第一参数定位于索引1，依次类推。（即解释器名以及选项被定位于负数索引。例如，在调用

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
中，解释器首先运行文件<code>a.lua</code>，然后创建一个表

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
最后运行文件<code>b.lua</code>。脚本以<code>arg[1]</code>, <code>arg[2]</code>, &middot;&middot;&middot;为参数被调用；也能用可变参数表达式‘<code>...</code>’访问这些参数。

<p>
在交互模式中，如果你写了一条未完成的语句，解释器通过发出一个不同的提示符等待其完成。

<p>
如果全局变量<a name="pdf-_PROMPT"><code>_PROMPT</code></a>包含一个字符串，则其值被用作提示符。类似地，如果全局变量<a name="pdf-_PROMPT2"><code>_PROMPT2</code></a>包含一个字符串，其值被用作辅助提示符（在未完成的语句间提示）。因此，两个提示符能通过在命令行上或任何Lua程序中给<code>_PROMPT</code>赋值直接改变。见下一个例子：

<pre>
     $ lua -e"_PROMPT='myprompt&gt; '" -i
</pre><p>
（外层的引号对用于shell，内层的用于Lua。）注意<code>-i</code>的用处是进入交互模式。否则，程序会在给<code>_PROMPT</code>赋值后安静地终止。

<p>
要允许Lua用作Unix系统中的脚本解释器，如果（代码）单元的第一行以<code>#</code>开头，独立的解释器跳过会跳过它。因此。Lua脚本可通过使用<code>chmod +x</code>和下面的<code>#!</code>形式被做成可执行程序：

<pre>
     #!/usr/local/bin/lua
</pre><p>
（当然，你的机器中Lua解释器的位置可能不同。如果<code>lua</code>在你的<code>PATH</code>中，则

<pre>
     #!/usr/bin/env lua
</pre><p>
是更具移植性的解决方式。）

<h1>7 - <a name="7">与之前版本的不兼容</a></h1>

<p>
我们在这儿列出了当你将程序从Lua 5.0迁移到Lua 5.1时可能发现的不兼容。你能用适当的选项（见文件<code>luaconf.h</code>）编译Lua以避免大多数不兼容。然而，在下一版Lua中所有这些不兼容选项将被移除。

<h2>7.1 - <a name="7.1">语言变化</a></h2>
<ul>

<li>
可变参数系统从含有附加参数的表的伪参数<code>arg</code>改为可变参数表达式。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_VARARG</code>。）
</li>

<li>
在<b>for</b>语句的隐式变量的作用域方面以及对于<b>repeat</b>语句有细微的改动。
</li>

<li>
长字符串/长注释语法（<code>[[<em>string</em>]]</code>）不允许嵌套。这些情况下可用新语法（<code>[=[<em>string</em>]=]</code>）。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_LSTR</code>。）
</li>

</ul>

<h2>7.2 - <a name="7.2">库的变化</a></h2>
<ul>

<li>
函数<code>string.gfind</code>重命名为<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_GFIND</code>。）
</li>

<li>
当<a href="#pdf-string.gsub"><code>string.gsub</code></a>以函数为其第三参数调用时，只要该函数返回<b>nil</b>或<b>false</b>，则替换串是整个匹配而不是空串。
</li>

<li>
不赞成使用函数<code>table.setn</code>。函数<code>table.getn</code>对应新的取长操作符（<code>#</code>）；使用操作符代替函数。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_GETN</code>。）
</li>

<li>
函数<code>loadlib</code>重命名为<a href="#pdf-package.loadlib"><code>package.loadlib</code></a>。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_LOADLIB</code>。）
</li>

<li>
函数<code>math.mod</code>重命名为<a href="#pdf-math.fmod"><code>math.fmod</code></a>。（见<code>luaconf.h</code>中的编译时选项<code>LUA_COMPAT_MOD</code>。）
</li>

<li>
不赞成使用函数<code>table.foreach</code>和<code>table.foreachi</code>。可用for循环<code>pairs</code>或<code>ipairs</code>代替。
</li>

<li>
由于新模块系统，函数<a href="#pdf-require"><code>require</code></a>中有实质的改变。然而，新行为很大程度上兼容旧的，除了<code>require</code>从<a href="#pdf-package.path"><code>package.path</code></a>获取路径而不是从<code>LUA_PATH</code>。
</li>

<li>
函数<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>具有不同的参数。不赞成使用函数<code>gcinfo</code>；使用<code>collectgarbage("count")</code>代替。
</li>

</ul>

<h2>7.3 - <a name="7.3">API变化</a></h2>
<ul>

<li>
<code>luaopen_*</code>函数（打开库）不能像常规C函数那样直接调用。它们必须像Lua函数那样通过Lua调用。
</li>

<li>
<code>lua_open</code>函数被<a href="#lua_newstate"><code>lua_newstate</code></a>取代以允许用户设置内存分配函数。你能用来自标准库的<a href="#luaL_newstate"><code>luaL_newstate</code></a>创建带标准分配函数（基于<code>realloc</code>）的状态机。
</li>

<li>
不赞成使用函数<code>luaL_getn</code>和<code>luaL_setn</code>（来自辅助库）。使用<a href="#lua_objlen"><code>lua_objlen</code></a>代替<code>luaL_getn</code>，并且没有<code>luaL_setn</code>的替代物。
</li>

<li>
函数<code>luaL_openlib</code>被<a href="#luaL_register"><code>luaL_register</code></a>取代。
</li>

<li>
现在，当给定值不是预期类型的用户数据时，函数<code>luaL_checkudata</code>抛出错误。（在Lua 5.0中返回<code>NULL</code>。）
</li>

</ul>

<h1>8 - <a name="8">Lua的完整语法</a></h1>

<p>
这儿是用扩展BNF描述的Lua的完整语法。（它没有说明操作符优先级。）

<pre>

	chunk ::= {stat [`<b>;</b>&acute;]} [laststat [`<b>;</b>&acute;]]

	block ::= chunk

	stat ::=  varlist `<b>=</b>&acute; explist | 
		 functioncall | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name `<b>=</b>&acute; exp `<b>,</b>&acute; exp [`<b>,</b>&acute; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [`<b>=</b>&acute; explist] 

	laststat ::= <b>return</b> [explist] | <b>break</b>

	funcname ::= Name {`<b>.</b>&acute; Name} [`<b>:</b>&acute; Name]

	varlist ::= var {`<b>,</b>&acute; var}

	var ::=  Name | prefixexp `<b>[</b>&acute; exp `<b>]</b>&acute; | prefixexp `<b>.</b>&acute; Name 

	namelist ::= Name {`<b>,</b>&acute; Name}

	explist ::= {exp `<b>,</b>&acute;} exp

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Number | String | `<b>...</b>&acute; | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `<b>(</b>&acute; exp `<b>)</b>&acute;

	functioncall ::=  prefixexp args | prefixexp `<b>:</b>&acute; Name args 

	args ::=  `<b>(</b>&acute; [explist] `<b>)</b>&acute; | tableconstructor | String 

	function ::= <b>function</b> funcbody

	funcbody ::= `<b>(</b>&acute; [parlist] `<b>)</b>&acute; block <b>end</b>

	parlist ::= namelist [`<b>,</b>&acute; `<b>...</b>&acute;] | `<b>...</b>&acute;

	tableconstructor ::= `<b>{</b>&acute; [fieldlist] `<b>}</b>&acute;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `<b>[</b>&acute; exp `<b>]</b>&acute; `<b>=</b>&acute; exp | Name `<b>=</b>&acute; exp | exp

	fieldsep ::= `<b>,</b>&acute; | `<b>;</b>&acute;

	binop ::= `<b>+</b>&acute; | `<b>-</b>&acute; | `<b>*</b>&acute; | `<b>/</b>&acute; | `<b>^</b>&acute; | `<b>%</b>&acute; | `<b>..</b>&acute; | 
		 `<b>&lt;</b>&acute; | `<b>&lt;=</b>&acute; | `<b>&gt;</b>&acute; | `<b>&gt;=</b>&acute; | `<b>==</b>&acute; | `<b>~=</b>&acute; | 
		 <b>and</b> | <b>or</b>

	unop ::= `<b>-</b>&acute; | <b>not</b> | `<b>#</b>&acute;

</pre>

<p>

<HR>
<SMALL>
最近更新：巴西利亚时间2008/08/18 周一 13:25:46
</SMALL>
<!--
Last change: revised for Lua 5.1.3
-->

</body></html>
