
lua_load
[-0, +1, -] 

int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);
Loads a Lua chunk. If there are no errors, lua_load pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message. The return values of lua_load are: 

0: no errors; 
LUA_ERRSYNTAX: syntax error during pre-compilation; 
LUA_ERRMEM: memory allocation error. 
This function only loads a chunk; it does not run it. 

lua_load automatically detects whether the chunk is text or binary, and loads it accordingly (see program luac). 

The lua_load function uses a user-supplied reader function to read the chunk (see lua_Reader). The data argument is an opaque value passed to the reader function. 

The chunkname argument gives a name to the chunk, which is used for error messages and in debug information (see §3.8). 

--------------------------------------------------------------------------------

lua_load
[-0, +1, -] 

int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);
加载一个Lua块。
如果没有错误，lua_load把编译好的块作为一个Lua函数压入栈顶。
否则，它把错误信息压入栈中。
lua_load的返回值有：
0: 无错误; 
LUA_ERRSYNTAX: 在预编译时出现语法错误； 
LUA_ERRMEM: 内存分配错误。
这个函数值能加载一个块；它不会运行这个函数。
lua_load自动检测块是文本格式还是二进制格式，并且相应进行加载（见程序luac）。
lua_load函数使用一个用户提供的读入器函数读入块（见lua_Reader）。
data参数是一个传递给读入器函数的不透明值。
chunkname参数给块起名，用于错误信息以及调试信息（见§3.8）。 



--------------------------------------------------------------------------------

lua_newstate
[-0, +0, -] 

lua_State *lua_newstate (lua_Alloc f, void *ud);
Creates a new, independent state. Returns NULL if cannot create the state (due to lack of memory). The argument f is the allocator function; Lua does all memory allocation for this state through this function. The second argument, ud, is an opaque pointer that Lua simply passes to the allocator in every call. 

--------------------------------------------------------------------------------

lua_newstate
[-0, +0, -] 

lua_State *lua_newstate (lua_Alloc f, void *ud);
创建一个新的，独立的状态。
如果无法创建状态则返回NULL（因为缺少内存）。
参数f是分配器函数；Lua通过这个函数为这个状态执行所有内存分配。
第二个参数ud是一个不透明的指针。Lua简单地在每次调用时把它传递给分配器函数。


--------------------------------------------------------------------------------

lua_newtable
[-0, +1, m] 

void lua_newtable (lua_State *L);
Creates a new empty table and pushes it onto the stack. It is equivalent to lua_createtable(L, 0, 0). 

--------------------------------------------------------------------------------
（注：TODO）

lua_newtable
[-0, +1, m] 

void lua_newtable (lua_State *L);
创建新的空表并将其压栈。它等价于lua_createtable(L, 0, 0)。 


--------------------------------------------------------------------------------

lua_newthread
[-0, +1, m] 

lua_State *lua_newthread (lua_State *L);
Creates a new thread, pushes it on the stack, and returns a pointer to a lua_State that represents this new thread. The new state returned by this function shares with the original state all global objects (such as tables), but has an independent execution stack. 

There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object. 

--------------------------------------------------------------------------------
（注：TODO）

lua_newthread
[-0, +1, m] 

lua_State *lua_newthread (lua_State *L);
创建新线程，将其压栈，并返回指向lua_State的指针，它表示该新线程。本函数返回的新状态机与初始状态机共享所有全局对象（例如表），但具有独立的执行栈。 

没有关闭或销毁线程的显式函数。像任何Lua对象一样，线程受垃圾收集的支配。 


--------------------------------------------------------------------------------

lua_newuserdata
[-0, +1, m] 

void *lua_newuserdata (lua_State *L, size_t size);
This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. 

Userdata represent C values in Lua. A full userdata represents a block of memory. It is an object (like a table): you must create it, it can have its own metatable, and you can detect when it is being collected. A full userdata is only equal to itself (under raw equality). 

When Lua collects a full userdata with a gc metamethod, Lua calls the metamethod and marks the userdata as finalized. When this userdata is collected again then Lua frees its corresponding memory. 

--------------------------------------------------------------------------------
（注：TODO）

lua_newuserdata
[-0, +1, m] 

void *lua_newuserdata (lua_State *L, size_t size);
本函数分配新的给定尺寸的内存块，以块地址的方式将完整的用户数据压栈，并返回该地址。 

Lua中的用户数据表示C值。完整的用户数据表示一块内存。它是个对象（如同表）：你必须创建它，它可以有自己的元表，而且当被收集时能被检测到。完整的用户数据只等于自己（依照原始的相等比较）。 

当Lua用gc元方法收集完整的用户数据时，Lua调用该元方法并把用户数据标记为完成的。当该用户数据再次被收集时，Lua释放其对应的内存。 


--------------------------------------------------------------------------------

lua_next
[-1, +(2|0), e] 

int lua_next (lua_State *L, int index);
Pops a key from the stack, and pushes a key-value pair from the table at the given index (the "next" pair after the given key). If there are no more elements in the table, then lua_next returns 0 (and pushes nothing). 

A typical traversal looks like this: 

     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }

While traversing a table, do not call lua_tolstring directly on a key, unless you know that the key is actually a string. Recall that lua_tolstring changes the value at the given index; this confuses the next call to lua_next. 

--------------------------------------------------------------------------------
（注：TODO）

lua_next
[-1, +(2|0), e] 

int lua_next (lua_State *L, int index);
从栈中弹出一个键，并从给定的索引处的表中弹出一个键-值对（给定键的“下一”对）。如果表中没有更多的元素，则lua_next返回0（且不会压栈任何东西）。 

典型的遍历看起来像这样： 

     /* 表在栈中的索引‘t’处 */
     lua_pushnil(L);  /* 第一个键 */
     while (lua_next(L, t) != 0) {
       /* 使用‘键’（索引-2）和‘值’(索引-1） */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除‘值’；为下次迭代保留‘键’ */
       lua_pop(L, 1);
     }

当遍历表时，不要直接对键调用lua_tolstring，除非你知道键确实是字符串。回忆一下，lua_tolstring会改变给定所引处的值；这会干扰下一次调用lua_next。 


--------------------------------------------------------------------------------

lua_Number
typedef double lua_Number;
The type of numbers in Lua. By default, it is double, but that can be changed in luaconf.h. 

Through the configuration file you can change Lua to operate with another type for numbers (e.g., float or long). 

--------------------------------------------------------------------------------
（注：TODO）

lua_Number
typedef double lua_Number;
Lua中的数字类型。缺省是双精度浮点数，但是能在luaconf.h中改变。 

通过配置文件能改变Lua去操作其他的类型用作数字（例如单精度浮点数或长整型）。 


--------------------------------------------------------------------------------

lua_objlen
[-0, +0, -] 

size_t lua_objlen (lua_State *L, int index);
Returns the "length" of the value at the given acceptable index: for strings, this is the string length; for tables, this is the result of the length operator ('#'); for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0. 

--------------------------------------------------------------------------------
（注：TODO）
lua_objlen
[-0, +0, -] 

size_t lua_objlen (lua_State *L, int index);
返回给定的认可的索引处的值的“长度”：对于字符串，这是其长度；对于表，这是取长操作符（‘#’）的结果；对于用户数据，这是为其分配的内存块的尺寸；对于其他类型是0。 


--------------------------------------------------------------------------------

lua_pcall
[-(nargs + 1), +(nresults|1), -] 

int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
Calls a function in protected mode. 

Both nargs and nresults have the same meaning as in lua_call. If there are no errors during the call, lua_pcall behaves exactly like lua_call. However, if there is any error, lua_pcall catches it, pushes a single value on the stack (the error message), and returns an error code. Like lua_call, lua_pcall always removes the function and its arguments from the stack. 

If errfunc is 0, then the error message returned on the stack is exactly the original error message. Otherwise, errfunc is the stack index of an error handler function. (In the current implementation, this index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error message and its return value will be the message returned on the stack by lua_pcall. 

Typically, the error handler function is used to add more debug information to the error message, such as a stack traceback. Such information cannot be gathered after the return of lua_pcall, since by then the stack has unwound. 

The lua_pcall function returns 0 in case of success or one of the following error codes (defined in lua.h): 

LUA_ERRRUN: a runtime error. 
LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the error handler function. 
LUA_ERRERR: error while running the error handler function. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pcall
[-(nargs + 1), +(nresults|1), -] 

int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
在保护模式中调用函数。 

nargs和nresults同lua_call中的有相同的含义。如果调用期间没有错误，lua_pcall的行为完全类似lua_call。然而，如果存在任何错误，lua_pcall捕捉它，将单个值压栈（错误消息），并返回错误代码。同lua_call一样，lua_pcall总是从栈中移除函数及其参数。 

如果errfunc是0，则在栈上返回的错误消息就是原始的错误消息。否则,errfunc就是错误处理器函数（error handler function）的栈索引。（当前实现中，该索引不能是伪索引。）在发生运行时错误时，该函数将用错误消息调用，而且其返回值将变成栈上被lua_pcall返回的消息。 

典型地，错误处理器函数用于向错误消息中增加更多调试信息，例如栈回溯。这种信息不能在lua_pcall返回后搜集，因为那时候栈已释放。 

成功时lua_pcall函数返回0，或者下面的错误代码之一（在lua.h中定义）： 

LUA_ERRRUN: 运行时错误。 
LUA_ERRMEM: 内存分配错误。对于这类错误，Lua不会调用错误处理器函数。 
LUA_ERRERR: 当运行错误处理器函数时的错误。 


--------------------------------------------------------------------------------

lua_pop
[-n, +0, -] 

void lua_pop (lua_State *L, int n);
Pops n elements from the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pop
[-n, +0, -] 

void lua_pop (lua_State *L, int n);
从栈中弹出n个元素。 


--------------------------------------------------------------------------------

lua_pushboolean
[-0, +1, -] 

void lua_pushboolean (lua_State *L, int b);
Pushes a boolean value with value b onto the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushboolean
[-0, +1, -] 

void lua_pushboolean (lua_State *L, int b);
把值b作为布尔值压栈。 


--------------------------------------------------------------------------------

lua_pushcclosure
[-n, +1, m] 

void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
Pushes a new C closure onto the stack. 

When a C function is created, it is possible to associate some values with it, thus creating a C closure (see §3.4); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values should be pushed onto the stack (when there are multiple values, the first value is pushed first). Then lua_pushcclosure is called to create and push the C function onto the stack, with the argument n telling how many values should be associated with the function. lua_pushcclosure also pops these values from the stack. 

The maximum value for n is 255. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushcclosure
[-n, +1, m] 

void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
把新的C闭包压栈。 

当C函数被创建时，它可以把一些值与自己关联，这样就创建了C闭包（见§3.4）；接下来无论何时它被调用，这些值对该函数都是可访问的。要将值与C函数关联，首先这些值应当被压栈（当有多个值时第一个值首先压栈）。然后用参数n调用lua_pushcclosure来创建C函数并将其压栈，n表明应当把多少值关联到该函数。lua_pushcclosure也会将这些值从栈中弹出。 

n的最大值是255。 


--------------------------------------------------------------------------------

lua_pushcfunction
[-0, +1, m] 

void lua_pushcfunction (lua_State *L, lua_CFunction f);
Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type function that, when called, invokes the corresponding C function. 

Any function to be registered in Lua must follow the correct protocol to receive its parameters and return its results (see lua_CFunction). 

lua_pushcfunction is defined as a macro: 

     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)

--------------------------------------------------------------------------------
（注：TODO）

lua_pushcfunction
[-0, +1, m] 

void lua_pushcfunction (lua_State *L, lua_CFunction f);
将C函数压栈。本函数接收一个指向C函数的指针并把一个function类型的Lua值压栈，当这种类型的函数被调用时，会调用相应的C函数。 

任何要在Lua中注册的函数必须遵循正确的协议，以接收其参数并返回其结果（见lua_CFunction）。 

lua_pushcfunction被定义为宏： 

     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)

--------------------------------------------------------------------------------

lua_pushfstring
[-0, +1, m] 

const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the C function sprintf, but has some important differences: 

You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection). 
The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '%%' (inserts a '%' in the string), '%s' (inserts a zero-terminated string, with no size restrictions), '%f' (inserts a lua_Number), '%p' (inserts a pointer as a hexadecimal numeral), '%d' (inserts an int), and '%c' (inserts an int as a character). 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushfstring
[-0, +1, m] 

const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
将格式化的字符串压栈并返回指向它的指针。它与C函数sprintf类似，但也有一些重要的区别： 

你不需要为结果分配空间：结果是Lua字符串且Lua会照看内存分配（以及通过垃圾收集解除分配）。 
转换说明符非常的有限。没有标记、宽度或精度。转换说明符只能是'%%' （在字符串中插入一个'%'），'%s' （插入一个以0结尾的字符串，没有尺寸限制），'%f' （插入一个lua_Number），'%p' （插入一个指针作为十六进制数），'%d' （插入一个int），以及'%c' （插入一个int作为字符）。 


--------------------------------------------------------------------------------

lua_pushinteger
[-0, +1, -] 

void lua_pushinteger (lua_State *L, lua_Integer n);
Pushes a number with value n onto the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushinteger
[-0, +1, -] 

void lua_pushinteger (lua_State *L, lua_Integer n);
将一个值为n的数字压栈。 

--------------------------------------------------------------------------------

lua_pushlightuserdata
[-0, +1, -] 

void lua_pushlightuserdata (lua_State *L, void *p);
Pushes a light userdata onto the stack. 

Userdata represent C values in Lua. A light userdata represents a pointer. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to "any" light userdata with the same C address. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushlightuserdata
[-0, +1, -] 

void lua_pushlightuserdata (lua_State *L, void *p);
将轻型用户数据压栈。 

在Lua中用户数据表示C值。轻型用户数据表示一个指针。它是个值（就像数字）：你不用创建它，它没有单独的元表，而且它不会被回收（如同从不被创建）。带有相同的C地址的轻型用户数据相等。 


--------------------------------------------------------------------------------

lua_pushliteral
[-0, +1, m] 

void lua_pushliteral (lua_State *L, const char *s);
This macro is equivalent to lua_pushlstring, but can be used only when s is a literal string. In these cases, it automatically provides the string length. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushliteral
[-0, +1, m] 

void lua_pushliteral (lua_State *L, const char *s);
本宏等价于lua_pushlstring，但是只能当s是字面字符串时使用。在这些情况下，它自动地提供字符串长度。 

--------------------------------------------------------------------------------

lua_pushlstring
[-0, +1, m] 

void lua_pushlstring (lua_State *L, const char *s, size_t len);
Pushes the string pointed to by s with size len onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at s can be freed or reused immediately after the function returns. The string can contain embedded zeros. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushlstring
[-0, +1, m] 

void lua_pushlstring (lua_State *L, const char *s, size_t len);
将s指向的尺寸为len的字符串压栈。Lua制造（或重用）给定字符串的内部拷贝，所以函数返回后s的内存立刻可被释放或重用。字符串可含有内嵌的0。 


--------------------------------------------------------------------------------

lua_pushnil
[-0, +1, -] 

void lua_pushnil (lua_State *L);
Pushes a nil value onto the stack. 

--------------------------------------------------------------------------------

lua_pushnil
[-0, +1, -] 

void lua_pushnil (lua_State *L);
压入一个空值进堆栈。 

--------------------------------------------------------------------------------

lua_pushnumber
[-0, +1, -] 

void lua_pushnumber (lua_State *L, lua_Number n);
Pushes a number with value n onto the stack. 

--------------------------------------------------------------------------------

lua_pushnumber
[-0, +1, -] 

void lua_pushnumber (lua_State *L, lua_Number n);
压入一个拥有值n的数字进堆栈。

--------------------------------------------------------------------------------

lua_pushstring
[-0, +1, m] 

void lua_pushstring (lua_State *L, const char *s);
Pushes the zero-terminated string pointed to by s onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at s can be freed or reused immediately after the function returns. The string cannot contain embedded zeros; it is assumed to end at the first zero. 


--------------------------------------------------------------------------------

lua_pushstring
[-0, +1, m] 

void lua_pushstring (lua_State *L, const char *s);
压入一个s指向的零结束字符串进堆栈。
Lua制造（或重用）所给字符串的一个内部拷贝，所以s指向的内存可以在函数返回后立刻被释放或重用。
这个字符串不可以包含内嵌零；假设第一个零为结束。

--------------------------------------------------------------------------------

lua_pushthread
[-0, +1, -] 

int lua_pushthread (lua_State *L);
Pushes the thread represented by L onto the stack. Returns 1 if this thread is the main thread of its state. 


--------------------------------------------------------------------------------
lua_pushthread
[-0, +1, -] 

int lua_pushthread (lua_State *L);
把L代表的线程压入栈中。
如果这个线程是状态的主线程则返回1。

--------------------------------------------------------------------------------

lua_pushvalue
[-0, +1, -] 

void lua_pushvalue (lua_State *L, int index);
Pushes a copy of the element at the given valid index onto the stack. 
--------------------------------------------------------------------------------

lua_pushvalue
[-0, +1, -] 

void lua_pushvalue (lua_State *L, int index);
把所给合法index处的元素的拷贝压入栈内。


--------------------------------------------------------------------------------

lua_pushvfstring
[-0, +1, m] 

const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);
Equivalent to lua_pushfstring, except that it receives a va_list instead of a variable number of arguments. 


--------------------------------------------------------------------------------

lua_pushvfstring
[-0, +1, m] 

const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);
等效于lua_pushfstring，除了接收一个va_list以代替参数个数。

--------------------------------------------------------------------------------

lua_rawequal
[-0, +0, -] 

int lua_rawequal (lua_State *L, int index1, int index2);
Returns 1 if the two values in acceptable indices index1 and index2 are primitively equal (that is, without calling metamethods). Otherwise returns 0. Also returns 0 if any of the indices are non valid. 

--------------------------------------------------------------------------------

lua_rawequal
[-0, +0, -] 

int lua_rawequal (lua_State *L, int index1, int index2);
如果两个所接收的索引index1和index2处的值原生相等（即不调用元方法），则返回1。
否则，返回0。
如果任意索引不合法，也返回0。

--------------------------------------------------------------------------------

lua_rawget
[-1, +1, -] 

void lua_rawget (lua_State *L, int index);
Similar to lua_gettable, but does a raw access (i.e., without metamethods). 

--------------------------------------------------------------------------------

lua_rawget
[-1, +1, -] 

void lua_rawget (lua_State *L, int index);
类似于lua_gettable，但执行原生访问(例如，没有元方法） 

--------------------------------------------------------------------------------

lua_rawgeti
[-0, +1, -] 

void lua_rawgeti (lua_State *L, int index, int n);
Pushes onto the stack the value t[n], where t is the value at the given valid index. The access is raw; that is, it does not invoke metamethods. 


--------------------------------------------------------------------------------

lua_rawgeti
[-0, +1, -] 

void lua_rawgeti (lua_State *L, int index, int n);
把t[n]的值压入栈中，其中t是所给合法Index处的值。
访问是原生的，不执行元方法

--------------------------------------------------------------------------------

lua_rawset
[-2, +0, m] 

void lua_rawset (lua_State *L, int index);
Similar to lua_settable, but does a raw assignment (i.e., without metamethods). 

--------------------------------------------------------------------------------
（注：TODO）

lua_rawset
[-2, +0, m] 

void lua_rawset (lua_State *L, int index);
类似lua_settable，但是执行一次原生赋值（也就是不用元方法）。 


--------------------------------------------------------------------------------

lua_rawseti
[-1, +0, m] 

void lua_rawseti (lua_State *L, int index, int n);
Does the equivalent of t[n] = v, where t is the value at the given valid index and v is the value at the top of the stack. 

This function pops the value from the stack. The assignment is raw; that is, it does not invoke metamethods. 

--------------------------------------------------------------------------------
（注：TODO）

lua_rawseti
[-1, +0, m] 

void lua_rawseti (lua_State *L, int index, int n);
执行t[n] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值。 

本函数将值出栈。赋值是原生的；即不调用元方法。 


--------------------------------------------------------------------------------


lua_Reader
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);
The reader function used by lua_load. Every time it needs another piece of the chunk, lua_load calls the reader, passing along its data parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set size to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return NULL or set size to zero. The reader function may return pieces of any size greater than zero. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Reader
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);
被lua_load使用的读取器函数。每次需要单元的另一段时，lua_load沿着它的data参数调用读取器。读取器必须返回一个的内存块的指针，其中含有单元的新代码段，并且设置size为块尺寸。块必须一直存在直到再次调用读取器函数。读取器必须返回NULL或设置size为0来指示单元结束。读取器函数可能返回大于0的任何尺寸的代码段。 


--------------------------------------------------------------------------------

lua_register
[-0, +0, e] 

void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);
Sets the C function f as the new value of global name. It is defined as a macro: 

     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))

--------------------------------------------------------------------------------
（注：TODO）

lua_register
[-0, +0, e] 

void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);
设置C函数f为全局变量name的新值。它被定义为宏： 

     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))

--------------------------------------------------------------------------------

lua_remove
[-1, +0, -] 

void lua_remove (lua_State *L, int index);
Removes the element at the given valid index, shifting down the elements above this index to fill the gap. Cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 

--------------------------------------------------------------------------------
（注：TODO）

lua_remove
[-1, +0, -] 

void lua_remove (lua_State *L, int index);
移除给定的有效索引处的元素，并将该索引上面的元素下移来填充空隙。不能用伪索引调用，因为伪索引不是真实的栈位置。 

--------------------------------------------------------------------------------

lua_replace
[-1, +0, -] 

void lua_replace (lua_State *L, int index);
Moves the top element into the given position (and pops it), without shifting any element (therefore replacing the value at the given position). 

--------------------------------------------------------------------------------
（注：TODO）

lua_replace
[-1, +0, -] 

void lua_replace (lua_State *L, int index);
将栈顶元素移动到给定的索引中（并弹出它），不会移动任何元素（因此替换给定位置的值）。 


--------------------------------------------------------------------------------

lua_resume
[-?, +?, -] 

int lua_resume (lua_State *L, int narg);
Starts and resumes a coroutine in a given thread. 

To start a coroutine, you first create a new thread (see lua_newthread); then you push onto its stack the main function plus any arguments; then you call lua_resume, with narg being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to lua_yield, or all values returned by the body function. lua_resume returns LUA_YIELD if the coroutine yields, 0 if the coroutine finishes its execution without errors, or an error code in case of errors (see lua_pcall). In case of errors, the stack is not unwound, so you can use the debug API over it. The error message is on the top of the stack. To restart a coroutine, you put on its stack only the values to be passed as results from yield, and then call lua_resume. 

--------------------------------------------------------------------------------
（注：TODO）

lua_resume
[-?, +?, -] 

int lua_resume (lua_State *L, int narg);
启动和恢复给定线程中的一个协程。 

要启动一个协程，首先创建线程（见lua_newthread）；接着将主函数以及任何参数压到它的栈中；然后用narg指定参数个数来调用lua_resume。当协程挂起或运行完成时该调用返回。当它返回时，栈中含有lua_yield传入的所有值，或主体函数返回的所有值。如果协程中断则lua_resume返回LUA_YIELD，如果运行无误结束则返回0，或者在发生错误时返回错误代码（见lua_pcall）。发生错误时，栈未被释放，所以可对它使用调试API。错误消息位于栈顶。要重新启动协程，你只需把要从yield传出的结果放到它的栈上，然后调用lua_resume。 

--------------------------------------------------------------------------------

lua_setallocf
[-0, +0, -] 

void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
Changes the allocator function of a given state to f with user data ud. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setallocf
[-0, +0, -] 

void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
把给定状态机的分配器函数换成带用户数据ud的f。 


--------------------------------------------------------------------------------

lua_setfenv
[-1, +0, -] 

int lua_setfenv (lua_State *L, int index);
Pops a table from the stack and sets it as the new environment for the value at the given index. If the value at the given index is neither a function nor a thread nor a userdata, lua_setfenv returns 0. Otherwise it returns 1. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setfenv
[-1, +0, -] 

int lua_setfenv (lua_State *L, int index);
从栈中弹出一个表并把它设为给定索引处的值的新环境。如果给定索引处的值既不是函数又不是线程也不是用户数据，lua_setfenv返回0。否则返回1。 


--------------------------------------------------------------------------------

lua_setfield
[-1, +0, e] 

void lua_setfield (lua_State *L, int index, const char *k);
Does the equivalent to t[k] = v, where t is the value at the given valid index and v is the value at the top of the stack. 

This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the "newindex" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_setfield
[-1, +0, e] 

void lua_setfield (lua_State *L, int index, const char *k);
执行t[k] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值。 

本函数从栈中弹出值。同Lua中一样，本函数可能触发“newindex”事件的元方法（见§2.8）。 


--------------------------------------------------------------------------------

lua_setglobal
[-1, +0, e] 

void lua_setglobal (lua_State *L, const char *name);
Pops a value from the stack and sets it as the new value of global name. It is defined as a macro: 

     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)

--------------------------------------------------------------------------------
（注：TODO）

lua_setglobal
[-1, +0, e] 

void lua_setglobal (lua_State *L, const char *name);
从栈中弹出一个值并将其设为全局变量name的新值。它被定义为宏： 

     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)

--------------------------------------------------------------------------------

lua_setmetatable
[-1, +0, -] 

int lua_setmetatable (lua_State *L, int index);
Pops a table from the stack and sets it as the new metatable for the value at the given acceptable index. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setmetatable
[-1, +0, -] 

int lua_setmetatable (lua_State *L, int index);
从栈中弹出一个表并将其设为给定的认可的索引处的值的新元表。 


--------------------------------------------------------------------------------

lua_settable
[-2, +0, e] 

void lua_settable (lua_State *L, int index);
Does the equivalent to t[k] = v, where t is the value at the given valid index, v is the value at the top of the stack, and k is the value just below the top. 

This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the "newindex" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_settable
[-2, +0, e] 

void lua_settable (lua_State *L, int index);
执行t[k] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值，k正好是栈顶下面的值。 

本函数将键和值都弹出栈。同Lua中一样，本函数可能触发“newindex”事件的元方法（见§2.8）。 


--------------------------------------------------------------------------------

lua_settop
[-?, +?, -] 

void lua_settop (lua_State *L, int index);
Accepts any acceptable index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with nil. If index is 0, then all stack elements are removed. 

--------------------------------------------------------------------------------

lua_settop
[-?, +?, -] 

void lua_settop (lua_State *L, int index);
接受任意可接受的索引，或者0，把栈顶设置在此索引上。
如果新的栈顶大于原有的，那么新创建的元素被填充为空。
如果索引为0，那么所有堆栈元素都会被删除。 

--------------------------------------------------------------------------------

lua_State
typedef struct lua_State lua_State;
Opaque structure that keeps the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is kept in this structure. 

A pointer to this state must be passed as the first argument to every function in the library, except to lua_newstate, which creates a Lua state from scratch. 

--------------------------------------------------------------------------------
lua_State
typedef struct lua_State lua_State;

保存整个Lua解析器状态（机）的不透明的结构。
Lua库（注：这里应该指C API）是完全可重入的：它没有全局变量。
关于状态的所有信息被保存在这个结构中。
指向这种状态的指针必须作为库里每一个库函数的第一个参数传递，除了从最开始创建一个Lua状态的lua_newstate以外。

--------------------------------------------------------------------------------

lua_status
[-0, +0, -] 

int lua_status (lua_State *L);
Returns the status of the thread L. 

The status can be 0 for a normal thread, an error code if the thread finished its execution with an error, or LUA_YIELD if the thread is suspended. 


--------------------------------------------------------------------------------

lua_status
[-0, +0, -] 

int lua_status (lua_State *L);
返回线程L的状态值。
线程正常时状态值为0，线程遇到错误而结束它的执行则返回一个错误码，线程挂起（暂停）则返回LUA_YIELD。

--------------------------------------------------------------------------------

lua_toboolean
[-0, +0, -] 

int lua_toboolean (lua_State *L, int index);
Converts the Lua value at the given acceptable index to a C boolean value (0 or 1). Like all tests in Lua, lua_toboolean returns 1 for any Lua value different from false and nil; otherwise it returns 0. It also returns 0 when called with a non-valid index. (If you want to accept only actual boolean values, use lua_isboolean to test the value's type.) 

--------------------------------------------------------------------------------

lua_toboolean
[-0, +0, -] 

int lua_toboolean (lua_State *L, int index);
把所给可接受的索引处的Lua值转换为C的布尔值(0或1)。
好像Lua的所有测试那样，对于任何不是false和nil的值lua_toboolean返回1；否则返回0。
它在用非法索引调用时也返回0。
（如果你只想接收实际的布尔值，使用lua_isboolean来检查值类型）

--------------------------------------------------------------------------------


lua_tocfunction
[-0, +0, -] 

lua_CFunction lua_tocfunction (lua_State *L, int index);
Converts a value at the given acceptable index to a C function. That value must be a C function; otherwise, returns NULL. 


--------------------------------------------------------------------------------

lua_tocfunction
[-0, +0, -] 

lua_CFunction lua_tocfunction (lua_State *L, int index);
把所给可接受索引处的值转换为C函数。
那个值必须是C函数，否则返回NULL。


--------------------------------------------------------------------------------

lua_tointeger
[-0, +0, -] 

lua_Integer lua_tointeger (lua_State *L, int index);
Converts the Lua value at the given acceptable index to the signed integral type lua_Integer. The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tointeger returns 0. 

If the number is not an integer, it is truncated in some non-specified way. 

--------------------------------------------------------------------------------
lua_tointeger
[-0, +0, -] 

lua_Integer lua_tointeger (lua_State *L, int index);
把所给可接受索引处的值转换为带符号的整型lua_Integer。
Lua值必须是一个数或者可转为数的字符串（参考§2.2.1），否则，lua_tointeger返回0。
如果数不是整数，会以不确定的方式被剪切。

--------------------------------------------------------------------------------

lua_tolstring
[-0, +0, m] 

const char *lua_tolstring (lua_State *L, int index, size_t *len);
Converts the Lua value at the given acceptable index to a C string. If len is not NULL, it also sets *len with the string length. The Lua value must be a string or a number; otherwise, the function returns NULL. If the value is a number, then lua_tolstring also changes the actual value in the stack to a string. (This change confuses lua_next when lua_tolstring is applied to keys during a table traversal.) 

lua_tolstring returns a fully aligned pointer to a string inside the Lua state. This string always has a zero ('\0') after its last character (as in C), but can contain other zeros in its body. Because Lua has garbage collection, there is no guarantee that the pointer returned by lua_tolstring will be valid after the corresponding value is removed from the stack. 

--------------------------------------------------------------------------------

lua_tolstring
[-0, +0, m] 

const char *lua_tolstring (lua_State *L, int index, size_t *len);
把所给可接受索引处的值转换为C的字符串。
如果len不是NULL，也可以设置*len为字符串长度。
Lua值不许是一个字符串或数。否则，这个函数返回NULL。
如果值是数，那么lua_tolstring还会改变堆栈的实际值为字符串。
（当lua_tolstring应用到表遍历的键中，这种改变会混淆lua_next。）
lua_tolstring返回一个完全对齐的指向Lua状态内部的字符串的指针。
因为Lua有垃圾回收，所以不保证lua_tolstring所返回的指针在相应值从堆栈中删除后仍合法。

--------------------------------------------------------------------------------

lua_tonumber
[-0, +0, -] 

lua_Number lua_tonumber (lua_State *L, int index);
Converts the Lua value at the given acceptable index to the C type lua_Number (see lua_Number). The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tonumber returns 0. 


--------------------------------------------------------------------------------

lua_tonumber
[-0, +0, -] 

lua_Number lua_tonumber (lua_State *L, int index);
把所给可接受索引处的值转换为C类型lua_Number（参考lua_Number）。
Lua值必须为一个数或可以转换为数的字符串（参考§2.2.1）；否则，lua_tonumber返回0。

--------------------------------------------------------------------------------

lua_topointer
[-0, +0, -] 

const void *lua_topointer (lua_State *L, int index);
Converts the value at the given acceptable index to a generic C pointer (void*). The value can be a userdata, a table, a thread, or a function; otherwise, lua_topointer returns NULL. Different objects will give different pointers. There is no way to convert the pointer back to its original value. 

Typically this function is used only for debug information. 

--------------------------------------------------------------------------------

lua_topointer
[-0, +0, -] 

const void *lua_topointer (lua_State *L, int index);
把所给可接受索引处的值转换为泛型的C指针（void*）。
这个值可以是用户定义数据，表，线程，或者是函数；否则，lua_topointer返回NULL。
不同的对象会给出不同的指针。
没有方法可以把指针转换回它原有值。
特别地这个函数仅用于调试信息。

--------------------------------------------------------------------------------

lua_tostring
[-0, +0, m] 

const char *lua_tostring (lua_State *L, int index);
Equivalent to lua_tolstring with len equal to NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_tostring
[-0, +0, m] 

const char *lua_tostring (lua_State *L, int index);
等价于len等于NULL时的lua_tolstring。 


--------------------------------------------------------------------------------

lua_tothread
[-0, +0, -] 

lua_State *lua_tothread (lua_State *L, int index);
Converts the value at the given acceptable index to a Lua thread (represented as lua_State*). This value must be a thread; otherwise, the function returns NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_tothread
[-0, +0, -] 

lua_State *lua_tothread (lua_State *L, int index);
把给定的认可的索引处的值转换为Lua线程（用lua_State*表示）。该值必须为线程；否则，本函数返回NULL。 


--------------------------------------------------------------------------------

lua_touserdata
[-0, +0, -] 

void *lua_touserdata (lua_State *L, int index);
If the value at the given acceptable index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_touserdata
[-0, +0, -] 

void *lua_touserdata (lua_State *L, int index);
如果给定的认可的索引处的值是完整的用户数据，则返回其块地址。如果是轻型用户数据，返回其指针。否则返回NULL。 


--------------------------------------------------------------------------------

lua_type
[-0, +0, -] 

int lua_type (lua_State *L, int index);
Returns the type of the value in the given acceptable index, or LUA_TNONE for a non-valid index (that is, an index to an "empty" stack position). The types returned by lua_type are coded by the following constants defined in lua.h: LUA_TNIL, LUA_TNUMBER, LUA_TBOOLEAN, LUA_TSTRING, LUA_TTABLE, LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD, and LUA_TLIGHTUSERDATA. 

--------------------------------------------------------------------------------
（注：TODO）

lua_type
[-0, +0, -] 

int lua_type (lua_State *L, int index);
返回给定的认可的索引处的值的类型，或者对不合法的索引返回LUA_TNONE（即指向“空”栈位置的索引）。lua_type返回的类型在lua.h中定义，被编码为下面的常量： LUA_TNIL、LUA_TNUMBER、LUA_TBOOLEAN、LUA_TSTRING、LUA_TTABLE、LUA_TFUNCTION、LUA_TUSERDATA、LUA_TTHREAD和LUA_TLIGHTUSERDATA。 


--------------------------------------------------------------------------------

lua_typename
[-0, +0, -] 

const char *lua_typename  (lua_State *L, int tp);
Returns the name of the type encoded by the value tp, which must be one the values returned by lua_type. 

--------------------------------------------------------------------------------
（注：TODO）

lua_typename
[-0, +0, -] 

const char *lua_typename  (lua_State *L, int tp);
返回由值tp编码的类型名，tp必须是lua_type的返回值的其中一个。 


--------------------------------------------------------------------------------

lua_Writer
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);
The type of the writer function used by lua_dump. Every time it produces another piece of chunk, lua_dump calls the writer, passing along the buffer to be written (p), its size (sz), and the data parameter supplied to lua_dump. 

The writer returns an error code: 0 means no errors; any other value means an error and stops lua_dump from calling the writer again. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Writer
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);
由lua_dump使用的记录器函数的类型。lua_dump沿着要被写入的缓冲区（p）调用本函数，同时传入缓冲区尺寸（sz）和提供给lua_dump的data参数。每次调用会产生单元的另一段代码。 

记录器返回错误代码：0表示没错误；任何其他值表示错误并阻止lua_dump再次调用记录器。 

--------------------------------------------------------------------------------

lua_xmove
[-?, +?, -] 

void lua_xmove (lua_State *from, lua_State *to, int n);
Exchange values between different threads of the same global state. 

This function pops n values from the stack from, and pushes them onto the stack to. 

--------------------------------------------------------------------------------

lua_xmove
[-?, +?, -] 

void lua_xmove (lua_State *from, lua_State *to, int n);
交换相同全局状态中不同线程的值。
这个函数从堆栈from中弹出n个值，然后把它们压入堆栈to。

--------------------------------------------------------------------------------

lua_yield
[-?, +?, -] 

int lua_yield  (lua_State *L, int nresults);
Yields a coroutine. 

This function should only be called as the return expression of a C function, as follows: 

     return lua_yield (L, nresults);

When a C function calls lua_yield in that way, the running coroutine suspends its execution, and the call to lua_resume that started this coroutine returns. The parameter nresults is the number of values from the stack that are passed as results to lua_resume. 


--------------------------------------------------------------------------------

lua_yield
[-?, +?, -] 

int lua_yield  (lua_State *L, int nresults);
挂起一个协程 
这个函数应该仅在C函数return表达式中使用，如下：
return lua_yield (L, nresults);
当一个C函数像那样调用lua_yield，运行的协程暂停它的执行，并且在使此协程重新开始的lua_resume调用处返回。
参数nresults是堆栈中传递给lua_resume结果的值个数。




