Lua 5.1 Reference Manual 
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes 
Copyright ? 2006-2008 Lua.org, PUC-Rio. Freely available under the terms of the Lua license. 

Lua 5.1参考手册
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
版权所有 2006-2008 Lua.org, PUC-Rio. 根据Lua许可证自由（免费）可用


contents ・ index 
目录 索引

1 - Introduction
1 - 简介

Lua is an extension programming language designed to support general procedural programming with data description facilities. It also offers good support for object-oriented programming, functional programming, and data-driven programming. Lua is intended to be used as a powerful, light-weight scripting language for any program that needs one. Lua is implemented as a library, written in clean C (that is, in the common subset of ANSI C and C++). 

Lua是一种为支持带数据描述功能的泛型过程式编程而设计的扩展编程语言。
它还提供对面向对象编程的良好支持，函数式编程，以及数据驱动编程。
Lua致力于成为一种强大和轻量级的脚本语言供任何需要它的程序使用。
Lua被实现为一个库，用纯C(即ANSI C和C++的公共子集)编写。

Being an extension language, Lua has no notion of a "main" program: it only works embedded in a host client, called the embedding program or simply the host. This host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework. The Lua distribution includes a sample host program called lua, which uses the Lua library to offer a complete, stand-alone Lua interpreter. 

作为一种扩展语言，Lua没有"main"程序的概念：它只是嵌入在称为嵌入式语言或者简称为宿主的宿主客户端中工作。
这个宿主程序可以调用函数去执行一段Lua代码，可以读写Lua变量，还可以注册C函数供Lua代码调用。
虽然使用了C函数，Lua可以被扩充，以应付广泛的不同领域，从而创建共享一个语法框架的可定制编程语言。
Lua发布版包含一个称为lua的示例宿主程序,使用Lua库去提供一个完整、可单独运行的Lua解析器。

Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, www.lua.org. 

Lua是自由（免费）软件，并且一般不作保证地提供，正如它的许可证所述。
在这个手册中所描述的实现可以在Lua的官方网站www.lua.org中找到。

Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, Programming in Lua (Second Edition). 

像其它参考手册那样，这个文档很多地方都很枯燥。
关于Lua设计背后的决策的讨论，请参考Lua官网上的技术文档。
关于Lua编程的详细介绍，参考Roberto的书，《Lua程序设计（第二版）》

2 - The Language
2 - 语言

This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean. 

这个部分描述词汇，语法，以及语义。
换而言之，这个部分描述那些符号是有效，它们如何可以组合，以及它们组合的含义。


The language constructs will be explained using the usual extended BNF notation, in which {a} means 0 or more a's, and [a] means an optional a. Non-terminals are shown like non-terminal, keywords are shown like kword, and other terminal symbols are shown like '='. The complete syntax of Lua can be found in §8 at the end of this manual. 

语言构造将解析通用扩展BNF表示法的使用，{a}表示0和更多a，[a]表示一个可选的a。
非最终符号表示为非最终符号（无黑体），关键词表示为kword（黑体），其他非终结符号表示为'='。
完整的Lua语法可以在本手册最后的第八章找到。


2.1 - Lexical Conventions
2.1 - 词法约定

Names (also called identifiers) in Lua can be any string of letters, digits, and underscores, not beginning with a digit. This coincides with the definition of names in most languages. (The definition of letter depends on the current locale: any character considered alphabetic by the current locale can be used in an identifier.) Identifiers are used to name variables and table fields. 

在Lua中，名称（也成为标识符）可以是任意字母，数字和下划线组成但不是以一个数字开头的字符串。
这正好和大多数语言的名称定义相符。
（这个字母的定义依赖于当前的本地环境：任何被当前本地环境当作字母的字符都可以被用于标识符）
标识符用于命名变量和表的域。

The following keywords are reserved and cannot be used as names: 

下面的关键词被保留，不可以用于名称：

    and       break     do        else      elseif
    end       false     for       function  if
    in        local     nil       not       or
    repeat    return    then      true      until     while

and（逻辑与） break（跳出循环）do（循环块开始）else（其它条件）elseif（其它条件判断）
end（循环、条件、闭包块结束）false（逻辑假） for（固定步长循环或迭代） 
function（闭包块开始）if（条件判断）
in（遍历）local（局部变量） nil（空） not（逻辑非）or（逻辑或）
repeat（条件假时循环） return（函数返回） then（条件块开始）true（逻辑真）
until（条件假循环判断）while（条件真时循环判断）


Lua is a case-sensitive language: and is a reserved word, but And and AND are two different, valid names. As a convention, names starting with an underscore followed by uppercase letters (such as _VERSION) are reserved for internal global variables used by Lua. 

Lua是大小写区分的语言：并且虽然作为保留字，但And和AND是两个与and不同的的词，也可以作为合法的名称。
作为一种约定，以下环线开头并且后面是全大写的名称（例如_VERSION）是被保留作为Lua的内部全局变量使用。

The following strings denote other tokens: 

下面的字符串表示其他标记：

+     -     *     /     %     ^     #
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]
;     :     ,     .     ..    ...


+（加）-（减或负号）*（乘）/（除）%（取模）^（指数幂）#（字符串或表长度）
==（相等）~=（不等）<=（小于等于）>=（大于等于）<（小于）>（大于）=（赋值）
(     )（小括号）{     }（大括号，表）[     ]（中括号，下标）
;（分号，分割语句）:（冒号，取对象成员）,（逗号）.（取表成员）..（字符串串联） ...（变长参数列表）

Literal strings can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '\a' (bell), '\b' (backspace), '\f' (form feed), '\n' (newline), '\r' (carriage return), '\t' (horizontal tab), '\v' (vertical tab), '\\' (backslash), '\"' (quotation mark [double quote]), and '\'' (apostrophe [single quote]). Moreover, a backslash followed by a real newline results in a newline in the string. A character in a string can also be specified by its numerical value using the escape sequence \ddd, where ddd is a sequence of up to three decimal digits. (Note that if a numerical escape is to be followed by a digit, it must be expressed using exactly three digits.) Strings in Lua can contain any 8-bit value, including embedded zeros, which can be specified as '\0'. 

字面值的字符串可以由匹配的单引号或双引号分隔，还可以包含下面的C风格转义字符序列：
'\a'（响铃），'\b'（退格），'\f'（表格回退），'\n'（换行），'\r'作为（回车），
'\t'（水平制表符），'\v'（垂直制表符），'\\'（反斜杠），'\"'（引号[双引号]），和'\''（单引号[单引号]）。
此外，反斜杠后的真实换行将在字符串中产生换行。
一个字符串中的字符，也可以用带转义序列\ddd的数值来指定，ddd是最多3个十进制数字的序列。
（注意，如果一个数值转义后面是一个数字，则它必须准确地使用三个数字表示）
在Lua中字符串可以包含任何8位数值，包括中间夹杂的零（注：区别于C风格的必须以\0结束而且前面不能包括\0的字符串），可以被指定为'\0'。（注：相比而言，Lua没有规定一定要以\0结束字符串）

Literal strings can also be defined using a long format enclosed by long brackets. We define an opening long bracket of level n as an opening square bracket followed by n equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as [[, an opening long bracket of level 1 is written as [=[, and so on. A closing long bracket is defined similarly; for instance, a closing long bracket of level 4 is written as ]====]. A long string starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. They can contain anything except a closing bracket of the proper level. 

字面值的字符串还可以使用一个长括号封闭的长格式来定义。
我们把一个n层的左长括号定义为一个左方括号，然后跟着另一个带相同n层的左方括号。
因此，一个0层左长括号写成[[，一个1层左长括号写成[=[，如此类推。
右长括号的定义类似；例如，一个4层右长括号写成]====]。
一个字符串以任意层的左长括号开始，以第一个出现的带相同层数的右长括号结束。
方括号内的字面值可以拆分为几行，不需要使用任何转义序列，忽略其他任何级别的长括号。
它们可以包含除了合适层数的右长括号以外的其它任意字符。



For convenience, when the opening long bracket is immediately followed by a newline, the newline is not included in the string. As an example, in a system using ASCII (in which 'a' is coded as 97, newline is coded as 10, and '1' is coded as 49), the five literal strings below denote the same string: 

     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]



为方便起见，当左长方括号后面立刻跟着一个换行时，这个换行不包括在字符串中。作为一个例子，在一个使用ASCII的系统中（其中'a'编码为97，换行编码为10，'1'编码为49），下面五个字符串字面值表示相同的字符串值：
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]



A numerical constant can be written with an optional decimal part and an optional decimal exponent. Lua also accepts integer hexadecimal constants, by prefixing them with 0x. Examples of valid numerical constants are 

     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56

一个数值常数可以写成一个可选的小数部分加上一个可选的十进制指数。Lua还接受十六进制整数常量，它们以0x作为前缀。合法数值常数的例子如下
3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56


A comment starts with a double hyphen (--) anywhere outside a string. If the text immediately after -- is not an opening long bracket, the comment is a short comment, which runs until the end of the line. Otherwise, it is a long comment, which runs until the corresponding closing long bracket. Long comments are frequently used to disable code temporarily. 

注释开始于字符串以外任何地方的一个双连字符（--）。如果--后紧跟着的文本不是一个左长方括号，这个注释就是一个短注释，它的注释直到行结束为止。否则，它是一个长注释，注释直到相应的右长方括号。长注释常常被用来暂时的代码禁用。








2.2 - Values and Types
Lua is a dynamically typed language. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type. 

2.2 - 值 and 类型
Lua是动态类型的语言。这意味着，变量没有类型，但值拥有。语言中没有类型定义。所有值携带它们自己的类型。



All values in Lua are first-class values. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results. 


Lua中所有值都是第一类值。这意味着所有的值都可以存储变量中，作为参数传递给其他函数，以及作为结果返回。





There are eight basic types in Lua: nil, boolean, number, string, function, userdata, thread, and table. Nil is the type of the value nil, whose main property is to be different from any other value; it usually represents the absence of a useful value. Boolean is the type of the values false and true. Both nil and false make a condition false; any other value makes it true. Number represents real (double-precision floating-point) numbers. (It is easy to build Lua interpreters that use other internal representations for numbers, such as single-precision float or long integers; see file luaconf.h.) String represents arrays of characters. Lua is 8-bit clean: strings can contain any 8-bit character, including embedded zeros ('\0') (see §2.1). 


Lua有八种基本类型：空型，布尔型，数型，字符串，函数，用户数据，线程和表。空型是nil的类型，其主要属性是不同于其它任何值，它通常代表缺少一个有用的值。布尔型是值false和true的类型。nil和false使条件为假；其他任何值都使条件为真。数型表示实数（双精度浮点数）。（在构建Lua解释器时很容易为数型值使用其他内部表示，例如单精度浮点数或者长整数。参考文件luaconf.h）字符串表示字符数组。Lua对8位字符是干净的：字符串可以包含任何8位字符，包括内嵌零（'\0'）（见§2.1）。







Lua can call (and manipulate) functions written in Lua and functions written in C (see §2.5.8). 

Lua中可以调用（和操纵）用lua编写的函数和用C编写的函数（见§2.5.8）。 



The type userdata is provided to allow arbitrary C data to be stored in Lua variables. This type corresponds to a block of raw memory and has no pre-defined operations in Lua, except assignment and identity test. However, by using metatables, the programmer can define operations for userdata values (see §2.8). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program. 

提供userdata类型，允许用户把任意C数据保存在Lua变量中。
此类型对应原始内存块并在lua中没有预定义的操作，除了赋值和唯一性检查。
但是，通过使用元表，程序员可以定义userdata值的操作（见§2.8）。
userdata值不能用Lua创建或修改，只能通过C API。
这保证了宿主程序所拥有数据的完整性。 





The type thread represents independent threads of execution and it is used to implement coroutines (see §2.11). Do not confuse Lua threads with operating-system threads. Lua supports coroutines on all systems, even those that do not support threads. 


线程类型代表可执行的独立线程，它用于实现协程（见§2.11）。
不要把Lua的线程和操作系统的线程混淆。 
Lua在所有系统上支持协程，即使在那些不支持线程的系统。




The type table implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any value (except nil). Tables can be heterogeneous; that is, they can contain values of all types (except nil). Tables are the sole data structuring mechanism in Lua; they can be used to represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing a.name as syntactic sugar for a["name"]. There are several convenient ways to create tables in Lua (see §2.5.7). 

表类型实现关联数组，即数组可以不仅仅用数字索引，还可以用任何值（除了nil）。
表可以是异构的，即它们可以包含所有类型的值（除了nil）。
表是在Lua中唯一的数据结构机制；它们可以被用于表示普通数组，符号表，集合，记录，图，树等。
为了表示记录，Lua使用域（字段）名作为一个索引。
语言通过提供a.name这种表示作为a["name"]的语法糖。
用Lua有几种简便方法可以创建表（见§2.5.7）。





Like indices, the value of a table field can be of any type (except nil). In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry methods (see §2.5.9). 

类似索引，表的字段值可以是任意类型（除了nil）。
特别地，因为函数是第一类值，表的字段可以包含函数。
因此，表也可以携带方法（见§2.5.9）。




Tables, functions, threads, and (full) userdata values are objects: variables do not actually contain these values, only references to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy. 

表，函数，线程和（完全）userdata值都是对象：变量实际上并不包含这些值，只是包含他们的引用。
赋值，参数传递，函数返回总是对其值的引用的操作，这些操作并不暗示有任何类型副本的存在。




The library function type returns a string describing the type of a given value. 

库函数type返回一个描述所给值的类型的字符串。






2.2.1 - Coercion
Lua provides automatic conversion between string and number values at run time. Any arithmetic operation applied to a string tries to convert this string to a number, following the usual conversion rules. Conversely, whenever a number is used where a string is expected, the number is converted to a string, in a reasonable format. For complete control over how numbers are converted to strings, use the format function from the string library (see string.format). 


2.2.1 - 强制转换
Lua中提供在运行时字符串和数值之间的自动转换。
应用到任何一个字符串的任意算术运算都会试图按照通常的转换规则，将这个字符串转换为数字。
相反，当一个数在预计使用一个字符串的场合被使用，这个数会以一个合理的格式转换为字符串。
关于如何把数字转换为字符串的完整控制，请使用string库的format函数（见string.format）。





2.3 - Variables
Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields. 

2.3 - 变量 
变量是存储值的地方。
Lua有三种变量：全局变量，局部变量和表字段（表域）。






A single name can denote a global variable or a local variable (or a function's formal parameter, which is a particular kind of local variable): 

	var ::= Name
	
一个单一的名称可以表示一个全局变量或局部变量（或函数的形式参数，一种特殊的局部变量）： 
var ::= Name



Name denotes identifiers, as defined in §2.1. 

名称表示标识符，在§2.1定义。



Any variable is assumed to be global unless explicitly declared as a local (see §2.4.7). Local variables are lexically scoped: local variables can be freely accessed by functions defined inside their scope (see §2.6). 

任何变量被假设为全局的，除非明确声明为局部（见§2.4.7）。
局部变量是词法作用域：局部变量可以被那些在它们范围内定义的函数自由访问（见§2.6）。




Before the first assignment to a variable, its value is nil. 

在第一次给一个变量赋值前，它的值是nil。



Square brackets are used to index a table: 

	var ::= prefixexp `[′ exp `]′

方括号用于索引表： 
var ::= prefixexp '[' exp ']'


The meaning of accesses to global variables and table fields can be changed via metatables. An access to an indexed variable t[i] is equivalent to a call gettable_event(t,i). (See §2.8 for a complete description of the gettable_event function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.) 

对全局变量和表字段的访问的含义可以通过元表来改变。
对一个索引变量t[i]的访问等效于对gettable_event(t,i)的调用。 
（请参考§2.8中关于gettable_event函数的完整说明。这个函数没有用Lua定义或者可以在Lua中调用。
我们在这里用它只是方便说明。）



The syntax var.Name is just syntactic sugar for var["Name"]: 

	var ::= prefixexp `.′ Name

语法var.Name只是var["Name"]的语法糖： 
var ::= prefixexp '.' Name



All global variables live as fields in ordinary Lua tables, called environment tables or simply environments (see §2.9). Each function has its own reference to an environment, so that all global variables in this function will refer to this environment table. When a function is created, it inherits the environment from the function that created it. To get the environment table of a Lua function, you call getfenv. To replace it, you call setfenv. (You can only manipulate the environment of C functions through the debug library; (see §5.9).) 

所有全局变量正如普通Lua表的字段那样存在，被称为环境表或简称环境（见§2.9）。
每个函数都有一个自己的对应环境的引用，因此在这个函数中所有全局变量将参考这个环境表。
当一个函数被创建时，它从创造它的函数中继承环境。
要想获得一个Lua函数的环境表，你可以调用getfenv。
要想替换它，你可以调用setfenv。
（您只能通过debug库操作C函数的环境；（见§ 5.9）。）


An access to a global variable x is equivalent to _env.x, which in turn is equivalent to 

     gettable_event(_env, "x")

访问全局变量x等效于访问_env.x，而这又相当于执行
gettable_event(_env, "x")



where _env is the environment of the running function. (See §2.8 for a complete description of the gettable_event function. This function is not defined or callable in Lua. Similarly, the _env variable is not defined in Lua. We use them here only for explanatory purposes.) 


其中_env是正在运行的函数的环境。（见§2.8关于gettable_event函数的完整描述。
这个函数不是用Lua定义或者被Lua代码调用。
同样，_env变量也不是用Lua定义。
在这里我们仅仅为了方便解析而使用它们。）



2.4 - Statements
Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations. 


2.4 - 语句 
Lua支持一个大多数都很常规的语句集合，类似于在Pascal或C中使用的语句集合。
这个集合包括赋值，控制结构，函数调用以及变量声明。




2.4.1 - Chunks
The unit of execution of Lua is called a chunk. A chunk is simply a sequence of statements, which are executed sequentially. Each statement can be optionally followed by a semicolon: 

	chunk ::= {stat [`;′]}

2.4.1 - chunk块（注：chunk，不同于下面提到的block显式块）
Lua的执行单元称为chunk块。
chunk块简单来说就是一连串顺序执行的语句序列，
每个语句后面可以可选地跟着一个分号：
chunk ::= {stat [';']}




There are no empty statements and thus ';;' is not legal. 

没有空语句，因此';;'是不合法的。





Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see §2.5.9). As such, chunks can define local variables, receive arguments, and return values. 


Lua把一个块处理成一个带可变数目参数的匿名函数体（见§2.5.9）。
因此，块可以定义局部变量，接收参数，以及返回值。





A chunk can be stored in a file or in a string inside the host program. To execute a chunk, Lua first pre-compiles the chunk into instructions for a virtual machine, and then it executes the compiled code with an interpreter for the virtual machine. 


块可以存储在一个文件中或在宿主程序内的字符串中。
要执行块，Lua首先会把块预编译成一种虚拟机的指令，然后用带虚拟机的解析器执行编译好的编码（注：即字节码）。







Chunks can also be pre-compiled into binary form; see program luac for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly. 



块也可以被预编译成二进制形式；详见程序luac。
源代码形式的程序和编译好的形态是可互换的；Lua会自动检测文件类型并执行相应的处理。




2.4.2 - Blocks
A block is a list of statements; syntactically, a block is the same as a chunk: 

	block ::= chunk

2.4.2 - block块（注：即显式块）
一个block块是一列语句；语法上程序块等于块
block ::= chunk




A block can be explicitly delimited to produce a single statement: 

	stat ::= do block end

一个block块可以被显式划定成一个单独的语句： 
stat ::= do block end






Explicit blocks are useful to control the scope of variable declarations. Explicit blocks are also sometimes used to add a return or break statement in the middle of another block (see §2.4.4). 


显式block块有利于控制变量声明的作用域。
显式block块有时也用于另一个块中添加一个return或break语句（见§2.4.4）。





2.4.3 - Assignment
Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas: 

	stat ::= varlist `=′ explist
	varlist ::= var {`,′ var}
	explist ::= exp {`,′ exp}

2.4.3 - 赋值 
Lua允许多重赋值。
因此，赋值语法定义左侧是一列变量，右侧是一列变量。
两个队列的元素用逗号分隔：
stat ::= varlist '=' explist
varlist ::= var {',' var}
explist ::= exp {',' exp}







Expressions are discussed in §2.5. 

表达式在§2.5中讨论。




Before the assignment, the list of values is adjusted to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many nil's as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see §2.5). 


在赋值前，值列表根据变量列表（注：即左值列表）大小调整长度。
如果值个数超过所需个数，超出个数的值被丢弃。
如果值个数少于所需个数，列表会用所需个数的nil扩充。
如果表达式列表以函数调用结束，那么该调用返回的所有值在调整前进入值列表（除非该调用被括号括起，见§2.5）。



The assignment statement first evaluates all its expressions and only then are the assignments performed. Thus the code 

     i = 3
     i, a[i] = i+1, 20

sets a[3] to 20, without affecting a[4] because the i in a[i] is evaluated (to 3) before it is assigned 4. Similarly, the line 

     x, y = y, x

exchanges the values of x and y, and 

     x, y, z = y, z, x

cyclically permutes the values of x, y, and z. 


赋值语句首先计算它所有的表达式，然后才执行赋值。
因此，代码
i = 3
i, a[i] = i+1, 20
把a[3]设置为20，而不是把a[r]设置为20，因为在a[i]中的i在赋值为4之前被计算（为3）
类似地，代码行
x, y = y, x
交换x和y的值，而
x, y, z = y, z, x
循环交换x，y和z的值





The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable t[i] = val is equivalent to settable_event(t,i,val). (See §2.8 for a complete description of the settable_event function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.) 


全局变量的赋值和表字段的赋值含义可以通过元表来改变。
一个对带索引变量的赋值t[i] = val等效于settable_event(t,i,val)。
（见§2.8关于settable_event的完整描述。
这个函数不是用Lua定义或者在Lua中可访问。
我们在这里用它只是为了方便解析）





An assignment to a global variable x = val is equivalent to the assignment _env.x = val, which in turn is equivalent to 

     settable_event(_env, "x", val)


对一个全局变量的赋值x = val等效于赋值_env.x = val，还等效于 
settable_event(_env, "x", val)








where _env is the environment of the running function. (The _env variable is not defined in Lua. We use it here only for explanatory purposes.) 


其中_env是正在运行的函数的环境。
（_env变量不是用Lua定义。
我们在这里用它只是为了方便解释。）









2.4.4 - Control Structures
The control structures if, while, and repeat have the usual meaning and familiar syntax: 

	stat ::= while exp do block end
	stat ::= repeat block until exp
	stat ::= if exp then block {elseif exp then block} [else block] end

2.4.4 - 控制结构 
控制结构if，while，和repeat拥有通常和熟悉的语法： 
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
	



Lua also has a for statement, in two flavors (see §2.4.5). 


Lua也有for语句，有两种（见§2.4.5）。







The condition expression of a control structure can return any value. Both false and nil are considered false. All values different from nil and false are considered true (in particular, the number 0 and the empty string are also true). 


控制结构的条件表达式可以返回任何值。
false和nil都被视是false。
所有不同于nil和false的值被视为true
（特别的，数字0和空字符串也是true）。
（注：在C的条件表达式中0被视为false，而在Lua中则被视为true）





In the repeatCuntil loop, the inner block does not end at the until keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block. 


在repeat-until循环中，内部块不是在util关键字结束，而是在该条件判断后结束。
因此，条件可以引用loop块内的当地循环内声明的变量块。





The return statement is used to return values from a function or a chunk (which is just a function). Functions and chunks can return more than one value, and so the syntax for the return statement is 

	stat ::= return [explist]

The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop: 

	stat ::= break

A break ends the innermost enclosing loop. 

The return and break statements can only be written as the last statement of a block. If it is really necessary to return or break in the middle of a block, then an explicit inner block can be used, as in the idioms do return end and do break end, because now return and break are the last statements in their (inner) blocks. 


return语句用于从一个函数或一个chunk块（仅仅是一个函数）中返回值。
函数和chunk块可以返回多于一个值，所以return语句的语法是
stat ::= return [explist]
break语句是用来终止了while，repeat，或者for循环，跳到循环之后的下一个语句：
stat ::= break
break结束最内层的封闭循环
return和break语句只可以作为block块的最后语句。
如果真的有必要从block块的中间返回或者结束循环，那么可以使用显式的内部block块，即作为习惯用语的do return end以及do break end，因为现在return和break是它们（内部）block块的最后语句。













2.4.5 - For Statement
The for statement has two forms: one numeric and one generic. 

The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax: 

	stat ::= for Name `=′ exp `,′ exp [`,′ exp] do block end

The block is repeated for name starting at the value of the first exp, until it passes the second exp by steps of the third exp. More precisely, a for statement like 

     for v = e1, e2, e3 do block end

is equivalent to the code: 

     do
       local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
       if not (var and limit and step) then error() end
       while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do
         local v = var
         block
         var = var + step
       end
     end

Note the following: 

All three control expressions are evaluated only once, before the loop starts. They must all result in numbers. 
var, limit, and step are invisible variables. The names shown here are for explanatory purposes only. 
If the third expression (the step) is absent, then a step of 1 is used. 
You can use break to exit a for loop. 
The loop variable v is local to the loop; you cannot use its value after the for ends or is broken. If you need this value, assign it to another variable before breaking or exiting the loop. 
The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil. The generic for loop has the following syntax: 

	stat ::= for namelist in explist do block end
	namelist ::= Name {`,′ Name}

A for statement like 

     for var_1, ・・・, var_n in explist do block end

is equivalent to the code: 

     do
       local f, s, var = explist
       while true do
         local var_1, ・・・, var_n = f(s, var)
         var = var_1
         if var == nil then break end
         block
       end
     end

Note the following: 

explist is evaluated only once. Its results are an iterator function, a state, and an initial value for the first iterator variable. 
f, s, and var are invisible variables. The names are here for explanatory purposes only. 
You can use break to exit a for loop. 
The loop variables var_i are local to the loop; you cannot use their values after the for ends. If you need these values, then assign them to other variables before breaking or exiting the loop. 




2.4.5 - for语句
for语句有两种形式：数字形式和泛型形式。
数字形式的循环当控制变量以算术级数变化时重复执行一段代码块。
它具有以下语法：
stat ::= for Name '=' exp ',' exp [',' exp] do block end
block块对name以第一个表达式的值开始循环，直至它通过第三个表达式的值的步进值，到达第二个表达式的值。
更确切地，一个for语句像这样：
for v = e1, e2, e3 do block end
等效于这样的语句
do
	local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
	if not (var and limit and step) then error() end
	while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do
		local v = var
		block
		var = var + step
	end
end 
注意如下：
这三个控制表达式都只会在循环开始之前计算一次。
它们必须返回数字。
var，limit，和step是不可见变量。
这里展示的名字只是为了方便解释。
如果缺少第三个表达式（step），那么使用步长值1。
你可以使用break退出一个for循环。
新欢变量v在循环中局部可见；你不能再for结束后或者跳出之后使用它的值。
如果你需要这个值，在跳出或退出循环之前把它的值赋给另一个变量。
泛型for语句工作于被称为迭代器的函数上。
在每次迭代时，调用迭代器函数产生新的值，当新的值是nil时停止循环。
泛型for循环拥有以下语法：
stat ::= for namelist in explist do block end
namelist ::= Name {',' Name} 
一个像这样的for语句
for var_1, ・・・, var_n in explist do block end
等效于代码：
do
	local f, s, var = explist
	while true do
		local var_1, ・・・, var_n = f(s, var)
		var = var_1
		if var == nil then break end
		block
	end
end
注意如下：
explist只计算一次。
其结果是一个迭代函数，一个状态，以及第一个迭代器变量的初始值。
f，s，和var是不可见变量。
这里的名字只是为了方便解释。
你可以使用break退出for循环。
循环变量var_i在循环中局部可见，你不能在for循环结束后使用它们的值。
如果你需要这些值，那么在跳出或者退出循环之前把它们的值赋给其它变量。




























2.4.6 - Function Calls as Statements
To allow possible side-effects, function calls can be executed as statements: 

	stat ::= functioncall

In this case, all returned values are thrown away. Function calls are explained in §2.5.8. 


2.4.6 - 作为语句的函数调用 
为了允许可能的副作用，函数调用可以以语句的形式执行： 
stat ::= functioncall
在这种情况下，所有的返回值被丢弃。函数调用在§2.5.8中解释。 









2.4.7 - Local Declarations
Local variables can be declared anywhere inside a block. The declaration can include an initial assignment: 

	stat ::= local namelist [`=′ explist]

If present, an initial assignment has the same semantics of a multiple assignment (see §2.4.3). Otherwise, all variables are initialized with nil. 

A chunk is also a block (see §2.4.1), and so local variables can be declared in a chunk outside any explicit block. The scope of such local variables extends until the end of the chunk. 

The visibility rules for local variables are explained in §2.6. 



2.4.7 - 局部变量声明
局部变量可以在block块内的任意位置声明。
该声明可以包含一个初始化赋值：
stat ::= local namelist ['=' explist]
如果存在，初始化赋值具有和多重赋值相同的语义（见§2.4.3）。
否则，所有变量都被初始化为nil。
chunk块也属于block块（见§2.4.1），因此局部变量可以在任何显式block块外的chunk块中声明。
这种局部变量的作用域延伸至chunk块结束。
局部变量的可见性规则在§2.6中解释。












2.5 - Expressions
The basic expressions in Lua are the following: 

	exp ::= prefixexp
	exp ::= nil | false | true
	exp ::= Number
	exp ::= String
	exp ::= function
	exp ::= tableconstructor
	exp ::= `...′
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | `(′ exp `)′

Numbers and literal strings are explained in §2.1; variables are explained in §2.3; function definitions are explained in §2.5.9; function calls are explained in §2.5.8; table constructors are explained in §2.5.7. Vararg expressions, denoted by three dots ('...'), can only be used when directly inside a vararg function; they are explained in §2.5.9. 

Binary operators comprise arithmetic operators (see §2.5.1), relational operators (see §2.5.2), logical operators (see §2.5.3), and the concatenation operator (see §2.5.4). Unary operators comprise the unary minus (see §2.5.1), the unary not (see §2.5.3), and the unary length operator (see §2.5.5). 

Both function calls and vararg expressions can result in multiple values. If an expression is used as a statement (only possible for function calls (see §2.4.6)), then its return list is adjusted to zero elements, thus discarding all returned values. If an expression is used as the last (or the only) element of a list of expressions, then no adjustment is made (unless the call is enclosed in parentheses). In all other contexts, Lua adjusts the result list to one element, discarding all values except the first one. 

Here are some examples: 

     f()                -- adjusted to 0 results
     g(f(), x)          -- f() is adjusted to 1 result
     g(x, f())          -- g gets x plus all results from f()
     a,b,c = f(), x     -- f() is adjusted to 1 result (c gets nil)
     a,b = ...          -- a gets the first vararg parameter, b gets
                        -- the second (both a and b can get nil if there
                        -- is no corresponding vararg parameter)
     
     a,b,c = x, f()     -- f() is adjusted to 2 results
     a,b,c = f()        -- f() is adjusted to 3 results
     return f()         -- returns all results from f()
     return ...         -- returns all received vararg parameters
     return x,y,f()     -- returns x, y, and all results from f()
     {f()}              -- creates a list with all results from f()
     {...}              -- creates a list with all vararg parameters
     {f(), nil}         -- f() is adjusted to 1 result

Any expression enclosed in parentheses always results in only one value. Thus, (f(x,y,z)) is always a single value, even if f returns several values. (The value of (f(x,y,z)) is the first value returned by f or nil if f does not return any values.) 






2.5 - 表达式
Lua基本表达式如下：
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Number
exp ::= String
exp ::= function
exp ::= tableconstructor
exp ::= '...'
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | '(' exp ')'
数和字符串字面值在§2.1中解释；
变量在§2.3中解释；
函数定义在§2.5.9中解释；
函数调用在§2.5.8中解释；
表构造式在§2.5.7中解释；
变长参数表达式，指三点运算符（'...'），只能直接在变长参数函数中使用；它们在§2.5.9中解释。
二元运算符包括算术运算符（见§2.5.1），关系运算符（见§2.5.2），逻辑运算符（见§2.5.3），一元not（见§2.5.3），以及一元长度操作符（见§2.5.5）。
函数调用和变长参数表达式都可以返回多个值。
如果一个表达式用作语句（只可以用于函数调用（见§2.4.6）），那么它的返回列表调整为0个元素，从而丢弃所有返回值。
如果一个表达式用于表达式列表的最后（或者唯一）的元素，那么不会进行调整（除非调用被括号括起）。
在所有其它场合中，Lua把返回列表调整为一个元素，丢弃第一个值以外的所有值。
这里是一些例子：
f()                -- 调整为0个结果
g(f(), x)          -- f()调整为1个结果
g(x, f())          -- g获得x和f()的所有结果
a,b,c = f(), x     -- f()调整为1个结果(c获得nil)
a,b = ...          -- a获得第一个变长参数的参数, b获得第二个（如果没有相应的变长参数表的参数，a和b可能获得nil）
a,b,c = x, f()     -- f()调整为2个结果
a,b,c = f()        -- f()调整为3个结果
return f()         -- 返回f()的所有结果
return ...         -- 返回所有接受的变长参数表的参数
return x,y,f()     -- 返回x，y，和所有f()的结果
{f()}              -- 创建一个f()结果的列表。
{...}              -- 创建一个变长参数表的所有参数的列表
{f(), nil}         -- f()被调整为1个结果
任意用括号括起的表达式总是返回一个值。
因此，(f(x,y,z))总是一个值，即使f返回几个值。
（(f(x,y,z))是f返回的第一个值，如果f不返回任何值，则是nil。）















2.5.1 - Arithmetic Operators
Lua supports the usual arithmetic operators: the binary + (addition), - (subtraction), * (multiplication), / (division), % (modulo), and ^ (exponentiation); and unary - (negation). If the operands are numbers, or strings that can be converted to numbers (see §2.2.1), then all operations have the usual meaning. Exponentiation works for any exponent. For instance, x^(-0.5) computes the inverse of the square root of x. Modulo is defined as 

     a % b == a - math.floor(a/b)*b

That is, it is the remainder of a division that rounds the quotient towards minus infinity. 



2.5.1 - 算术运算符 
Lua支持普通的算术运算符：二元+（加），-（减），*（乘），/（除），％（取模），和^（指数幂）和一元-（负号）。
如果操作数是数字或可转换为数字的字符串（见§2.2.1），那么所有操作拥有普通的含义。
幂适用于任何指数。
例如x ^（-0.5）计算出x的平方根。
取模定义为
a % b == a - math.floor(a/b)*b
其中它是除法的余数，使商靠近负无穷。






2.5.2 - Relational Operators
The relational operators in Lua are 

     ==    ~=    <     >     <=    >=

These operators always result in false or true. 

Equality (==) first compares the type of its operands. If the types are different, then the result is false. Otherwise, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata, threads, and functions) are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, thread, or function), this new object is different from any previously existing object. 

You can change the way that Lua compares tables and userdata by using the "eq" metamethod (see §2.8). 

The conversion rules of §2.2.1 do not apply to equality comparisons. Thus, "0"==0 evaluates to false, and t[0] and t["0"] denote different entries in a table. 

The operator ~= is exactly the negation of equality (==). 

The order operators work as follows. If both arguments are numbers, then they are compared as such. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the "lt" or the "le" metamethod (see §2.8). A comparison a > b is translated to b < a and a >= b is translated to b <= a. 



2.5.2 - 关系运算符 
Lua的关系运算符有
==    ~=    <     >     <=    >=
这些运算符总是返回false或者true。
相等（==）首先比较操作数的类型。
如果类型不同，那么结果为false。
否则比较操作数的值。
数字和字符串以通常的方式比较。
对象（表，用户数据，线程和函数）用引用进行比较：两个对象仅在它们引用相同对象时才被视为相等。
每次创建一个新的对象（表，用户数据，线程，或功能），这个新的对象是从任何以前存在的对象不同。 
你可以通过使用"eq"元方法改变Lua比较表和userdata的方式。
§2.2.1的转换规则并不适用于相等比较。
因此，"0"==0的计算结果为false，T[0]和T["0"]表示表的不同条目。 
运算符~=是等号（==）的准确否定。
顺序运算符工作方式如下。
如果参数都为数，它们以原本方式比较。否则，如果参数都是字符串，那么它们的值根据当前的本地环境进行比较。
否则，Lua尝试调用"lt"和"le"元方法（见§2.8）
比较式a > b被翻译为b < a，而a >= b被翻译为b <= a。









2.5.3 - Logical Operators
The logical operators in Lua are and, or, and not. Like the control structures (see §2.4.4), all logical operators consider both false and nil as false and anything else as true. 

The negation operator not always returns false or true. The conjunction operator and returns its first argument if this value is false or nil; otherwise, and returns its second argument. The disjunction operator or returns its first argument if this value is different from nil and false; otherwise, or returns its second argument. Both and and or use short-cut evaluation; that is, the second operand is evaluated only if necessary. Here are some examples: 

     10 or 20            --> 10
     10 or error()       --> 10
     nil or "a"          --> "a"
     nil and 10          --> nil
     false and error()   --> false
     false and nil       --> false
     false or nil        --> nil
     10 and 20           --> 20

(In this manual, --> indicates the result of the preceding expression.) 



2.5.3 - 逻辑运算符 
Lua的逻辑运算符有and，or，和not。
像控制结构那样（见§2.4.4），所有逻辑运算符把false和nil视为false，其它视为true。 
否定运算符不总是返回false或true。
如果第一个参数的值是false或nil，组合运算符and会返回这个值；
否则，and返回第二个参数。
如果第一个参数的值不是nil或false，分离运算符or会返回这个值；
否则，or返回第二个参数。
and和or使用短路计算；即第二操作数只在必要时计算。
这里有一些例子：
10 or 20            --> 10
10 or error()       --> 10
nil or "a"          --> "a"
nil and 10          --> nil
false and error()   --> false
false and nil       --> false
false or nil        --> nil
10 and 20           --> 20
（在本手册中，-->表示前面表达式的结果。）（注：同时也是注释的写法）








2.5.4 - Concatenation
The string concatenation operator in Lua is denoted by two dots ('..'). If both operands are strings or numbers, then they are converted to strings according to the rules mentioned in §2.2.1. Otherwise, the "concat" metamethod is called (see §2.8). 



2.5.4 - 连接 
在Lua中字符串连接运算符是指两个点（'..'）。
如果两个操作数都是字符串或数，那么它们都会按照§ 2.2.1中提到的规则转换为字符串。
否则调用"concat"元方法（见§2.8）。










2.5.5 - The Length Operator
The length operator is denoted by the unary operator #. The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte). 

The length of a table t is defined to be any integer index n such that t[n] is not nil and t[n+1] is nil; moreover, if t[1] is nil, n can be zero. For a regular array, with non-nil values from 1 to a given n, its length is exactly that n, the index of its last value. If the array has "holes" (that is, nil values between other non-nil values), then #t can be any of the indices that directly precedes a nil value (that is, it may consider any such nil value as the end of the array). 


2.5.5 - 长度运算符 
长度运算符是指一元运算符#。
字符串的长度是它的字节数（即字符串长度的通常意义，每个字符是一个字节）。 
表t的长度是指任何整数索引n使得T[n]不是nil而T[n+1]是nil；而且，如果t[1]是nil，n可以为零。
对于常规数组，从1到一个给定的n的元素都是非空值，则其长度正好是n，即它最后的值的索引。
如果数组有“洞”（即在其他非空值之间的nil值），则#T可以是在一个非空值前一个值的任何一个索引（即可以把任何一个这种nil值视为数组的结束）。










2.5.6 - Precedence
Operator precedence in Lua follows the table below, from lower to higher priority: 

     or
     and
     <     >     <=    >=    ~=    ==
     ..
     +     -
     *     /     %
     not   #     - (unary)
     ^

As usual, you can use parentheses to change the precedences of an expression. The concatenation ('..') and exponentiation ('^') operators are right associative. All other binary operators are left associative. 



2.5.6 - 优先级
Lua运算符的优先级从低到高如下表所示：
or
and
<     >     <=    >=    ~=    ==
..
+     -
*     /     %
not   #     - (一元)
^
通常你可以使用括号来改变表达式的优先级。
连接('..')和指数('^')操作符为右结合。
其他所有的二元运算符为左结合。









2.5.7 - Table Constructors
Table constructors are expressions that create tables. Every time a constructor is evaluated, a new table is created. A constructor can be used to create an empty table or to create a table and initialize some of its fields. The general syntax for constructors is 

	tableconstructor ::= `{′ [fieldlist] `}′
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= `[′ exp `]′ `=′ exp | Name `=′ exp | exp
	fieldsep ::= `,′ | `;′

Each field of the form [exp1] = exp2 adds to the new table an entry with key exp1 and value exp2. A field of the form name = exp is equivalent to ["name"] = exp. Finally, fields of the form exp are equivalent to [i] = exp, where i are consecutive numerical integers, starting with 1. Fields in the other formats do not affect this counting. For example, 

     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }

is equivalent to 

     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end

If the last field in the list has the form exp and the expression is a function call or a vararg expression, then all values returned by this expression enter the list consecutively (see §2.5.8). To avoid this, enclose the function call or the vararg expression in parentheses (see §2.5). 

The field list can have an optional trailing separator, as a convenience for machine-generated code. 



2.5.7 - 表构造式 
表构造式是创建表的表达式。
每次构造式计算时创建一个新表。
构造式可以用于创建一个空表或者创建一个表并初始化它的一些字段。
关于构造式的一般语法是
tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= '[' exp ']' '=' exp | Name '=' exp | exp
fieldsep ::= ',' | ';'
每个以[exp1] = exp2形式的字段以键exp1和值exp2添加到新表中的一个条目中。
以name = exp的形式的字段等效于["name"] = exp。
最后，exp形式的字段等效于[i] = exp，其中i是连续累加整数，以1开始。
其它形式的字段不会影响这个计数。
例如，
a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
等效于
do
   local t = {}
   t[f(1)] = g
   t[1] = "x"         -- 第1个表达式
   t[2] = "y"         -- 第2个表达式
   t.x = 1            -- t["x"] = 1
   t[3] = f(x)        -- 第3个表达式
   t[30] = 23
   t[4] = 45          -- 第4个表达式
   a = t
end
如果列表最后一个字段的形式exp和表达式是一个函数调用或一个变长参数表达式，
则这个表达式返回的所有值连续地加入到列表中（见§2.5.8）。
要避免这种情况，请用括号括起函数调用或变长参数表达式（见§2.5）。
字段列表可以有一个可选的结尾分隔符，方便机器生成代码。 









2.5.8 - Function Calls
A function call in Lua has the following syntax: 

	functioncall ::= prefixexp args

In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type function, then this function is called with the given arguments. Otherwise, the prefixexp "call" metamethod is called, having as first parameter the value of prefixexp, followed by the original call arguments (see §2.8). 

The form 

	functioncall ::= prefixexp `:′ Name args

can be used to call "methods". A call v:name(args) is syntactic sugar for v.name(v,args), except that v is evaluated only once. 

Arguments have the following syntax: 

	args ::= `(′ [explist] `)′
	args ::= tableconstructor
	args ::= String

All argument expressions are evaluated before the call. A call of the form f{fields} is syntactic sugar for f({fields}); that is, the argument list is a single new table. A call of the form f'string' (or f"string" or f[[string]]) is syntactic sugar for f('string'); that is, the argument list is a single literal string. 

As an exception to the free-format syntax of Lua, you cannot put a line break before the '(' in a function call. This restriction avoids some ambiguities in the language. If you write 

     a = f
     (g).x(a)

Lua would see that as a single statement, a = f(g).x(a). So, if you want two statements, you must add a semi-colon between them. If you actually want to call f, you must remove the line break before (g). 

A call of the form return functioncall is called a tail call. Lua implements proper tail calls (or proper tail recursion): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the return has one single function call as argument; this syntax makes the calling function return exactly the returns of the called function. So, none of the following examples are tail calls: 

     return (f(x))        -- results adjusted to 1
     return 2 * f(x)
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1

2.5.8 - 函数调用 
一个Lua函数调用的语法如下：
functioncall ::= prefixexp args
在一个函数调用中，prefixexp和args首先被计算。
如果prefixexp的值是函数类型，那么这个函数使用给定的参数进行调用。
否则，prefixexp的"call"元方法被调用，第一个参数是prefixexp的值，然后是原本的调用参数（见§2.8）。
形式
functioncall ::= prefixexp ':' Name args
可以用来调用“方法”。
调用v:name(args)是v.name(v,args)的语法糖，除了v仅被计算一次。
参数的语法如下：
args ::= '(' [explist] ')'
args ::= tableconstructor
args ::= String
所有参数表达式在调用前计算。
调用形式f{fields}是f({fields})的语法糖；其中参数表是一个单一的新表。
调用形式f'string'（或f"string"或f[[string]]）是f('string')的语法糖；其中参数表式一个单一的字符串字面值。
作为Lua自由格式语法的例外，你不能在函数调用的'('前插入换行。
这个限制避免语言的一些歧义。如果你写
a = f
(g).x(a)
Lua会把它视为一个单一语句a = f(g).x(a)。
所以，如果你希望是两个语句，你必须在它们之间添加分号。
如果你真的想调用f，你必须删除(g)前的换行。
调用形式return functioncall被称为尾调用。
Lua实现合适的尾调用（或者说尾递归）：在一个尾调用中，被调用的函数重用调用方函数的堆栈入口。
因此，一个程序可以执行的嵌套尾调用数目没有限制。
然而，尾调用清除任何关于调用方函数的调试信息。
注意尾调用只出现在特定语法，其中return只以一个单一函数调用作为参数（注：这里return关键字被看成是函数调用）；
这种语法使调用方函数准确地返回被调用函数的返回值。
所以，下面的例子都不是尾调用：
return (f(x))        -- 结果调整为一个
return 2 * f(x)
return x, f(x)       -- 额外的结果
f(x); return         -- 结果被丢弃
return x or f(x)     -- 结果调整为一个







2.5.9 - Function Definitions
The syntax for function definition is 

	function ::= function funcbody
	funcbody ::= `(′ [parlist] `)′ block end

The following syntactic sugar simplifies function definitions: 

	stat ::= function funcname funcbody
	stat ::= local function Name funcbody
	funcname ::= Name {`.′ Name} [`:′ Name]

The statement 

     function f () body end

translates to 

     f = function () body end

The statement 

     function t.a.b.c.f () body end

translates to 

     t.a.b.c.f = function () body end

The statement 

     local function f () body end

translates to 

     local f; f = function () body end

not to 

     local f = function () body end

(This only makes a difference when the body of the function contains references to f.) 

A function definition is an executable expression, whose value has type function. When Lua pre-compiles a chunk, all its function bodies are pre-compiled too. Then, whenever Lua executes the function definition, the function is instantiated (or closed). This function instance (or closure) is the final value of the expression. Different instances of the same function can refer to different external local variables and can have different environment tables. 

Parameters act as local variables that are initialized with the argument values: 

	parlist ::= namelist [`,′ `...′] | `...′

When a function is called, the list of arguments is adjusted to the length of the list of parameters, unless the function is a variadic or vararg function, which is indicated by three dots ('...') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a vararg expression, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses). 

As an example, consider the following definitions: 

     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end

Then, we have the following mapping from arguments to parameters and to the vararg expression: 

     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... -->  (nothing)
     g(3, 4)          a=3, b=4,   ... -->  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8
     g(5, r())        a=5, b=1,   ... -->  2  3

Results are returned using the return statement (see §2.4.4). If control reaches the end of a function without encountering a return statement, then the function returns with no results. 

The colon syntax is used for defining methods, that is, functions that have an implicit extra parameter self. Thus, the statement 

     function t.a.b.c:f (params) body end

is syntactic sugar for 

     t.a.b.c.f = function (self, params) body end







2.5.9 - 函数定义 
函数定义的语法是
function ::= function funcbody
funcbody ::= '(' [parlist] ')' block end
下面的语法糖简化函数定义：
stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname ::= Name {'.' Name} [':' Name]
语句
function f () body end
翻译为
f = function () body end
语句
function t.a.b.c.f () body end
翻译为
t.a.b.c.f = function () body end
语句
local function f () body end
翻译为
local f; f = function () body end
而不是
local f = function () body end
（仅当函数体中包含有f的引用时这两种写法才会产生区别）
一个函数定义是一个可执行的表达式，其值拥有function类型。
当Lua预编译chunk块时，它的所有函数体都会被预编译。
然后，每当执行Lua的函数定义时，函数会被实例化（或被关闭（注：这里的关闭可能是指闭包定义））。
这个函数的实例（或闭包）是表达式的最终值。
相同函数的不同实例可以引用不同的外部局部变量和拥有不同的环境表。（注：可能指upvalue）
作为局部变量性质工作的参数使用参数值进行初始化：
parlist ::= namelist [',' '...'] | '...'
当一个函数被调用时，实参列表被调整为形参列表的长度，
除非该函数是一个可变参数或在其参数列表结尾用三点('...')表示的变长参数函数。
一个变长参数函数不调整其参数列表，相反它收集所有额外参数和并且把它们通过变长参数表达式传递给函数，它们也被写成三点运算符。
这个表达式的值是所有额外实参的列表，类似于一个具有多个结果的函数。
如果一个变长参数表达式是在另一个表达式或在一个表达式列表中使用，那么它的返回列表被调整为一个元素。
如果表达式是作为一个表达式列表的最后一个元素使用，则不进行调整（除非最后一个表达式是用括号括起）。 
例如考虑以下定义：
function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end
然后我们拥有以下实参（argument）到形参（parameter）的映射以及到变长参数表达式的映射。
调用            形参
f(3)             a=3, b=nil
f(3, 4)          a=3, b=4
f(3, 4, 5)       a=3, b=4
f(r(), 10)       a=1, b=10
f(r())           a=1, b=2
g(3)             a=3, b=nil, ... -->  (无对象)
g(3, 4)          a=3, b=4,   ... -->  (无对象)
g(3, 4, 5, 8)    a=3, b=4,   ... -->  5  8
g(5, r())        a=5, b=1,   ... -->  2  3
使用return语句返回结果（见§2.4.4）。
如果控制没有遇到一个return语句，就到达函数的结束处，那么函数不以任何值返回。
冒号语法用于定义方法，即函数有一个隐含的额外参数self。
因此，语句
function t.a.b.c:f (params) body end
是下面写法的语法糖
t.a.b.c.f = function (self, params) body end










2.6 - Visibility Rules
Lua is a lexically scoped language. The scope of variables begins at the first statement after their declaration and lasts until the end of the innermost block that includes the declaration. Consider the following example: 

     x = 10                -- global variable
     do                    -- new block
       local x = x         -- new 'x', with value 10
       print(x)            --> 10
       x = x+1
       do                  -- another block
         local x = x+1     -- another 'x'
         print(x)          --> 12
       end
       print(x)            --> 11
     end
     print(x)              --> 10  (the global one)

Notice that, in a declaration like local x = x, the new x being declared is not in scope yet, and so the second x refers to the outside variable. 

Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an upvalue, or external local variable, inside the inner function. 

Notice that each execution of a local statement defines new local variables. Consider the following example: 

     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end

The loop creates ten closures (that is, ten instances of the anonymous function). Each of these closures uses a different y variable, while all of them share the same x. 




2.6 - 可见性规则 
Lua是一个词法上拥有作用域限制的语言。
变量的作用域，开始于其声明后的第一个语句，直到包含声明的最内层block块的结束。
考虑下面的例子：
x = 10                -- 全局变量
do                    -- 新的block块
	local x = x       -- 新变量'x', 值为10
	print(x)          --> 10
	x = x+1
	do                -- 另一个block块
		local x = x+1 -- 另一个变量 'x'
		print(x)      --> 12
	end
	print(x)          --> 11
end
print(x)              --> 10  (那个全局变量x)
注意在像local x = x这样的声明中，被定义的新的x还不是在作用域内，所以第二个x引用的是外部变量。
因为词法上的作用域规则，局部变量可以被定义在它作用域内的函数自由访问。
一个被内部函数使用的局部变量称为upvalue，或者称为内部函数内的外部（注：导入）局部变量。
注意，每一个local语句的执行定义新的局部变量。
考虑下面的例子：
a = {}
local x = 20
for i=1,10 do
	local y = 0
	a[i] = function () y=y+1; return x+y end
end
循环创建了10个闭包（即10个匿名函数实例）。
这个闭包每个都使用（注：引用）不同的y变量，但都共享（注：引用）相同的x。






2.7 - Error Handling
Because Lua is an embedded extension language, all Lua actions start from C code in the host program calling a function from the Lua library (see lua_pcall). Whenever an error occurs during Lua compilation or execution, control returns to C, which can take appropriate measures (such as printing an error message). 

Lua code can explicitly generate an error by calling the error function. If you need to catch errors in Lua, you can use the pcall function. 


2.7 - 错误处理 
因为Lua是一个嵌入的扩展语言，Lua的所有操作在宿主程序调用Lua库函数（见lua_pcall）的C代码处开始工作。
每当在Lua编译或执行期间发生错误，控制将返回到C，进行适当的处理（如打印错误消息）。
Lua代码可以显式地通过调用error函数产生错误。
如果你需要在Lua代码中捕获错误，你可以使用pcall函数。












2.8 - Metatables
Every value in Lua can have a metatable. This metatable is an ordinary Lua table that defines the behavior of the original value under certain special operations. You can change several aspects of the behavior of operations over a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field "__add" in its metatable. If it finds one, Lua calls this function to perform the addition. 



2.8 - 元表 
每个Lua值都可以有一个元表。
这个元表是一个普通的Lua表，定义某些特定操作下原始值的行为。
你可以通过把元表的特定字段设置为一个值来改变操作行为的某些角度（注：切面，相位）
例如，当非数值的值是加法的操作数，Lua用它的元表的"__add"字段的函数检查。
如果找到，Lua调用这个函数来执行加法。





We call the keys in a metatable events and the values metamethods. In the previous example, the event is "add" and the metamethod is the function that performs the addition. 

You can query the metatable of any value through the getmetatable function. 

You can replace the metatable of tables through the setmetatable function. You cannot change the metatable of other types from Lua (except by using the debug library); you must use the C API for that. 



我们调用在元表事件中和在值的元方法中的键。
在前一个例子中，事件是"add"而元方法是执行加法的函数。
你可以通过getmetatable函数查询任意值的元表。
你可以通过setmetatable函数替换表的元表。
你不可以在Lua中改变其它类型的元表（除非使用debug库）；你必须使用C API来完成。





Tables and full userdata have individual metatables (although multiple tables and userdata can share their metatables). Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. 

表和完全userdata拥有各自的元表（虽然多重表和userdata可以共享它们的元表）。
其它所有类型的值对每个类型共享一个单独的元表；即所有数有一个单一元表，所有字符串有一个单一元表，等等。







A metatable controls how an object behaves in arithmetic operations, order comparisons, concatenation, length operation, and indexing. A metatable also can define a function to be called when a userdata is garbage collected. For each of these operations Lua associates a specific key called an event. When Lua performs one of these operations over a value, it checks whether this value has a metatable with the corresponding event. If so, the value associated with that key (the metamethod) controls how Lua will perform the operation. 


元表控制一个对象在算术操作，书序比较，连接，长度操作和索引时的行为方式。
元表还能定义一个函数，当一个userdata被垃圾回收时调用它。
Lua把每个操作关联到一个特定的键，称为事件。
当Lua用一个值来执行这些操作时，它会检查这个值是否有相应事件的元表。
如果有，关联那个键的值（元方法）控制Lua执行该操作的方式。








Metatables control the operations listed next. Each operation is identified by its corresponding name. The key for each operation is a string with its name prefixed by two underscores, '__'; for instance, the key for operation "add" is the string "__add". The semantics of these operations is better explained by a Lua function describing how the interpreter executes the operation. 

元表控制下面列举的操作。
每个操作通过它相应的名字来标识。
每个操作的键是一个带有双下划线'__'前缀的名称的字符串。
例如，"add"操作的键是字符串"__add"。
通过一个描述解释器如何执行操作的Lua函数可以更好地解释这些操作的语义。







The code shown here in Lua is only illustrative; the real behavior is hard coded in the interpreter and it is much more efficient than this simulation. All functions used in these descriptions (rawget, tonumber, etc.) are described in §5.1. In particular, to retrieve the metamethod of a given object, we use the expression 

     metatable(obj)[event]

This should be read as 

     rawget(getmetatable(obj) or {}, event)

That is, the access to a metamethod does not invoke other metamethods, and the access to objects with no metatables does not fail (it simply results in nil). 

这里展示的Lua代码只是为了说明；真实的行为时被硬编码进解释器使之比这个模拟更为有效。
这些描述中使用的所有函数（rawget，tonumber，等等）在§5.1中描述。
特别地，为了获得给定对象的元方法，我们使用表达式
metatable(obj)[event]
这个表达式可以读成
rawget(getmetatable(obj) or {}, event)
即对一个元方法的访问不会调用其它元方法，而对不带元表的对象的访问不会失败（只是简单地返回nil）。











"add": the + operation. 
The function getbinhandler below defines how Lua chooses a handler for a binary operation. First, Lua tries the first operand. If its type does not define a handler for the operation, then Lua tries the second operand. 

     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end

By using this function, the behavior of the op1 + op2 is 

     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- both operands are numeric?
         return o1 + o2   -- '+' here is the primitive 'add'
       else  -- at least one of the operands is not numeric
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- call the handler with both operands
           return (h(op1, op2))
         else  -- no handler available: default behavior
           error(・・・)
         end
       end
     end


"add": +操纵。 
下面的函数getbinhandler定义Lua如何为一个二元操作选择处理句柄。
首先，Lua尝试第一个操作数。
如果它的类型没有定义一个操作的处理句柄，那么Lua尝试第二操作数。 
function getbinhandler (op1, op2, event)
	return metatable(op1)[event] or metatable(op2)[event]
end
通过使用这个函数，op1 + op2的行为如下 
function add_event (op1, op2)
	local o1, o2 = tonumber(op1), tonumber(op2)
	if o1 and o2 then  -- 操作数都是数值吗？
		return o1 + o2   -- 这里的'+'是原始的'add'
	else  -- 至少有一个操作数不是数值
		local h = getbinhandler(op1, op2, "__add")
		if h then
			-- 用两个操作数调用处理句柄
			return (h(op1, op2))
		else  -- 没有可用的处理句柄：默认行为
			error(・・・)
		end
	end
end













"sub": the - operation. Behavior similar to the "add" operation. 
"mul": the * operation. Behavior similar to the "add" operation. 
"div": the / operation. Behavior similar to the "add" operation. 
"mod": the % operation. Behavior similar to the "add" operation, with the operation o1 - floor(o1/o2)*o2 as the primitive operation. 
"pow": the ^ (exponentiation) operation. Behavior similar to the "add" operation, with the function pow (from the C math library) as the primitive operation. 
"unm": the unary - operation. 
     function unm_event (op)
       local o = tonumber(op)
       if o then  -- operand is numeric?
         return -o  -- '-' here is the primitive 'unm'
       else  -- the operand is not numeric.
         -- Try to get a handler from the operand
         local h = metatable(op).__unm
         if h then
           -- call the handler with the operand
           return (h(op))
         else  -- no handler available: default behavior
           error(・・・)
         end
       end
     end


"sub": -操作。行为类似于"add"操作。
"mul": *操作。行为类似于"add"操作。
"div": /操作。行为类似于"add"操作。 
"mod": %操作。行为类似于"add"操作，以操作o1 - floor(o1/o2)*o2作为原始操作。 
"pow": ^（指数）操作。 行为类似于"add"操作，以函数pow（出自C的数学库）作为原始操作。 
"unm": 一元-操作. 
function unm_event (op)
	local o = tonumber(op)
	if o then  -- 操作数是数字吗？
		return -o  -- 这里的'-'是原始的'unm'
	else  -- 操作数不是数字
		-- 尝试从操作数中获得一个处理句柄
		local h = metatable(op).__unm
		if h then
		-- 用操作数调用处理句柄
			return (h(op))
		else  -- no handler available: default behavior
			error(・・・)
		end
	end
end








"concat": the .. (concatenation) operation. 
     function concat_event (op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- primitive string concatenation
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error(・・・)
         end
       end
     end



"concat": .. （连接）操作. 
function concat_event (op1, op2)
	if (type(op1) == "string" or type(op1) == "number") and
		(type(op2) == "string" or type(op2) == "number") then
		return op1 .. op2  -- 原始字符串连接
	else
		local h = getbinhandler(op1, op2, "__concat")
		if h then
			return (h(op1, op2))
		else
			error(・・・)
		end
	end
end
 











"len": the # operation. 
     function len_event (op)
       if type(op) == "string" then
         return strlen(op)         -- primitive string length
       elseif type(op) == "table" then
         return #op                -- primitive table length
       else
         local h = metatable(op).__len
         if h then
           -- call the handler with the operand
           return (h(op))
         else  -- no handler available: default behavior
           error(・・・)
         end
       end
     end

See §2.5.5 for a description of the length of a table. 



"len": #操作。 
function len_event (op)
	if type(op) == "string" then
		return strlen(op)         -- 原始字符串长度
	elseif type(op) == "table" then
		return #op                -- 原始表长度
	else
		local h = metatable(op).__len
		if h then
			-- 用操作数调用处理句柄
			return (h(op))
		else  -- 没有可用的处理句柄：默认行为
			error(・・・)
		end
	end
end
见§2.5.5关于表长度的描述。
 









"eq": the == operation. The function getcomphandler defines how Lua chooses a metamethod for comparison operators. A metamethod only is selected when both objects being compared have the same type and the same metamethod for the selected operation. 
     function getcomphandler (op1, op2, event)
       if type(op1) ~= type(op2) then return nil end
       local mm1 = metatable(op1)[event]
       local mm2 = metatable(op2)[event]
       if mm1 == mm2 then return mm1 else return nil end
     end

The "eq" event is defined as follows: 

     function eq_event (op1, op2)
       if type(op1) ~= type(op2) then  -- different types?
         return false   -- different objects
       end
       if op1 == op2 then   -- primitive equal?
         return true   -- objects are equal
       end
       -- try metamethod
       local h = getcomphandler(op1, op2, "__eq")
       if h then
         return (h(op1, op2))
       else
         return false
       end
     end

a ~= b is equivalent to not (a == b). 


"eq": ==操作。
函数getcomphandler定义Lua如何为比较操作符选择一个元方法。
当相同类型的对象比较并且选择操作具有相同的元方法时才会选择那个元方法。
function getcomphandler (op1, op2, event)
	if type(op1) ~= type(op2) then return nil end
	local mm1 = metatable(op1)[event]
	local mm2 = metatable(op2)[event]
	if mm1 == mm2 then return mm1 else return nil end
end
"eq"事件定义如下： 
function eq_event (op1, op2)
	if type(op1) ~= type(op2) then  -- 是不同类型吗？
		return false     -- 不同的对象
	end
	if op1 == op2 then   -- 是原始相等吗？
		return true   	 -- 对象相等
	end
	-- 尝试元方法
	local h = getcomphandler(op1, op2, "__eq")
	if h then
		return (h(op1, op2))
	else
		return false
	end
end
a ~= b 等效于not (a == b). 











"lt": the < operation. 
     function lt_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 < op2   -- numeric comparison
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 < op2   -- lexicographic comparison
       else
         local h = getcomphandler(op1, op2, "__lt")
         if h then
           return (h(op1, op2))
         else
           error(・・・)
         end
       end
     end

a > b is equivalent to b < a. 



"lt": < 操作。 
function lt_event (op1, op2)
	if type(op1) == "number" and type(op2) == "number" then
		return op1 < op2   -- 数值比较
	elseif type(op1) == "string" and type(op2) == "string" then
		return op1 < op2   -- 字典序比较
	else
		local h = getcomphandler(op1, op2, "__lt")
		if h then
			return (h(op1, op2))
		else
			error(・・・)
		end
	end
end

a > b is equivalent to b < a. 














"le": the <= operation. 
     function le_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 <= op2   -- numeric comparison
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 <= op2   -- lexicographic comparison
       else
         local h = getcomphandler(op1, op2, "__le")
         if h then
           return (h(op1, op2))
         else
           h = getcomphandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(・・・)
           end
         end
       end
     end

a >= b is equivalent to b <= a. Note that, in the absence of a "le" metamethod, Lua tries the "lt", assuming that a <= b is equivalent to not (b < a). 



"le": <= 操作。
function le_event (op1, op2)
	if type(op1) == "number" and type(op2) == "number" then
		return op1 <= op2   -- 数值比较
	elseif type(op1) == "string" and type(op2) == "string" then
		return op1 <= op2   -- 字典序比较
	else
		local h = getcomphandler(op1, op2, "__le")
		if h then
			return (h(op1, op2))
		else
			h = getcomphandler(op1, op2, "__lt")
			if h then
				return not h(op2, op1)
			else
				error(・・・)
			end
		end
	end
end

a >= b 等效于 b <= a. 
注意，缺少"le"元方法时, Lua尝试"lt", 假设a <= b等效于not (b < a)。













"index": The indexing access table[key]. 
     function gettable_event (table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error(・・・)
         end
       end
       if type(h) == "function" then
         return (h(table, key))     -- call the handler
       else return h[key]           -- or repeat operation on it
       end
     end



"index": 当索引访问table[key]时被调用. 
function gettable_event (table, key)
	local h
	if type(table) == "table" then
		local v = rawget(table, key)
		if v ~= nil then return v end
		h = metatable(table).__index
		if h == nil then return nil end
	else
		h = metatable(table).__index
		if h == nil then
			error(・・・)
		end
	end
	if type(h) == "function" then
		return (h(table, key))     -- 调用处理句柄
	else return h[key]             -- 或者重复对它操作
	end
end











"newindex": The indexing assignment table[key] = value. 
     function settable_event (table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error(・・・)
         end
       end
       if type(h) == "function" then
         h(table, key,value)           -- call the handler
       else h[key] = value             -- or repeat operation on it
       end
     end


"newindex": 当索引赋值table[key] = value执行时调用。 
function settable_event (table, key, value)
	local h
	if type(table) == "table" then
		local v = rawget(table, key)
		if v ~= nil then rawset(table, key, value); return end
		h = metatable(table).__newindex
		if h == nil then rawset(table, key, value); return end
	else
		h = metatable(table).__newindex
		if h == nil then
			error(・・・)
		end
	end
	if type(h) == "function" then
		h(table, key,value)           -- 调用处理句柄
	else h[key] = value               -- 或者重复对它操作
	end
end
 












"call": called when Lua calls a value. 
     function function_event (func, ...)
       if type(func) == "function" then
         return func(...)   -- primitive call
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(・・・)
         end
       end
     end


"call": 当Lua调用一个值时被调用。 
function function_event (func, ...)
	if type(func) == "function" then
		return func(...)   -- 原始调用
	else
		local h = metatable(func).__call
		if h then
			return h(func, ...)
		else
			error(・・・)
		end
	end
end
 









2.9 - Environments
Besides metatables, objects of types thread, function, and userdata have another table associated with them, called their environment. Like metatables, environments are regular tables and multiple objects can share the same environment. 

Threads are created sharing the environment of the creating thread. Userdata and C functions are created sharing the environment of the creating C function. Non-nested Lua functions (created by loadfile, loadstring or load) are created sharing the environment of the creating thread. Nested Lua functions are created sharing the environment of the creating Lua function. 

Environments associated with userdata have no meaning for Lua. It is only a convenience feature for programmers to associate a table to a userdata. 

Environments associated with threads are called global environments. They are used as the default environment for threads and non-nested Lua functions created by the thread and can be directly accessed by C code (see §3.3). 

The environment associated with a C function can be directly accessed by C code (see §3.3). It is used as the default environment for other C functions and userdata created by the function. 

Environments associated with Lua functions are used to resolve all accesses to global variables within the function (see §2.3). They are used as the default environment for nested Lua functions created by the function. 

You can change the environment of a Lua function or the running thread by calling setfenv. You can get the environment of a Lua function or the running thread by calling getfenv. To manipulate the environment of other objects (userdata, C functions, other threads) you must use the C API. 





2.9 - 环境 
除了元表以外，线程、函数和userdata（注：用户数据）类型的对象还有另一个与它们相关联的表，称为环境。
像元表那样，环境是个常规表，多个对象可以共享相同的环境。
被创建的线程共享创建方线程的环境。
被创建的userdata和C函数共享创建方C函数的环境。
被创建的非嵌套Lua函数（有loadfile，loadstring或load创建的函数）共享创建方线程的环境。
被创建的嵌套的Lua函数共享创建方Lua函数的环境。
与userdata关联的环境对于Lua代码来说没有意义。
只是为了对程序员的方便特性而把表关联到userdata。
关联C函数的环境对于C代码来说是直接可访问的（见§3.3）。
习惯用作被这个函数所创建的其它C函数和userdata的默认环境。
Lua函数关联的环境习惯用于解决在函数内部对全局变量的访问问题。（见§2.3）
它们被用作这个函数所创建的嵌套Lua函数的默认环境。
你可以通过调用setfenv改变一个Lua函数或者运行中的线程的环境。
你可以通过调用getfenv获得一个Lua函数或者运行中的线程的环境。
为了操纵其他对象的环境（userdata，C函数，其他线程），你必须使用C API。 















2.10 - Garbage Collection
Lua performs automatic memory management. This means that you have to worry neither about allocating memory for new objects nor about freeing it when the objects are no longer needed. Lua manages memory automatically by running a garbage collector from time to time to collect all dead objects (that is, objects that are no longer accessible from Lua). All memory used by Lua is subject to automatic management: tables, userdata, functions, threads, strings, etc. 

Lua implements an incremental mark-and-sweep collector. It uses two numbers to control its garbage-collection cycles: the garbage-collector pause and the garbage-collector step multiplier. Both use percentage points as units (so that a value of 100 means an internal value of 1). 

The garbage-collector pause controls how long the collector waits before starting a new cycle. Larger values make the collector less aggressive. Values smaller than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle. 

The step multiplier controls the relative speed of the collector relative to memory allocation. Larger values make the collector more aggressive but also increase the size of each incremental step. Values smaller than 100 make the collector too slow and can result in the collector never finishing a cycle. The default, 200, means that the collector runs at "twice" the speed of memory allocation. 

You can change these numbers by calling lua_gc in C or collectgarbage in Lua. With these functions you can also control the collector directly (e.g., stop and restart it). 




2.10 - 垃圾回收 
Lua执行自动内存管理。
这意味着你不必担心新对象的内存分配，也不必担心不再需要的对象如何释放。
Lua通过间或地运行垃圾回收器自动管理内存来回收所有死亡的对象（即在Lua中不再可以访问的对象）。
Lua使用的所有内存都属在自动管理下：表，userdata（注：用户数据），函数，线程，字符串，等等。
Lua实现一个增量标记清除回收器。
它使用两个数来控制它的垃圾回收周期：垃圾回收器暂停和垃圾回收器步长倍数。
两者都使用百分点作为单位。
（所以一个100的值代表内部数值1的意思）
垃圾回收器暂停控制着回收器在一个新周期前等待的时间长度。
较大的值使回收器拥有较少的侵入性。
小于100的值意味着回收器将不会等待开始新的周期中。
一个200的值意味着回收器等待所有使用中的内存翻一倍后才开始新的周期。
步长倍数控制回收器相对于内存分配器的相对速度。
较大的值会使回收器更具侵入性，但同时增加了每次增量步长的大小。
小于100的值使回收器更慢从而致使回收器永远都不能完成一次周期。
默认值200意味着回收器以内存分配器“两倍”的速度运行。
你可以通过在C中调用lua_gc或者在Lua中调用collectgarbage来改变这些值。
使用这些函数你也可以直接控制回收器（例如停止或重启它）










2.10.1 - Garbage-Collection Metamethods
Using the C API, you can set garbage-collector metamethods for userdata (see §2.8). These metamethods are also called finalizers. Finalizers allow you to coordinate Lua's garbage collection with external resource management (such as closing files, network or database connections, or freeing your own memory). 

Garbage userdata with a field __gc in their metatables are not collected immediately by the garbage collector. Instead, Lua puts them in a list. After the collection, Lua does the equivalent of the following function for each userdata in that list: 

     function gc_event (udata)
       local h = metatable(udata).__gc
       if h then
         h(udata)
       end
     end

At the end of each garbage-collection cycle, the finalizers for userdata are called in reverse order of their creation, among those collected in that cycle. That is, the first finalizer to be called is the one associated with the userdata created last in the program. The userdata itself is freed only in the next garbage-collection cycle. 





2.10.1 - 垃圾回收的元方法 
使用C API，您可以设置userdata的垃圾回收的元方法（见§2.8）。
这些元方法也被称为回收函数（注：终结函数）。回收函数允许你使用外部资源管理协调Lua的垃圾回收
（如关闭文件，网络或数据库连接，或者释放你自己的内存）。 
在元表中带字段__gc的
垃圾userdata不会马上被垃圾回收器回收。
相反，Lua把它们放在一个列表中，在回收后，Lua对那个列表中的每一个userdata执行以下函数的等效操作：
function gc_event (udata)
	local h = metatable(udata).__gc
	if h then
		h(udata)
	end
end
在每个垃圾回收周期的最后，在那个周期回收的那些userdata的回收函数会以它们相反的创建顺序被调用。
即第一个被调用的回收函数是关联着那个在程序中最后创建的userdata。
userdata自身只会在下一次垃圾回收周期里被释放。










2.10.2 - Weak Tables
A weak table is a table whose elements are weak references. A weak reference is ignored by the garbage collector. In other words, if the only references to an object are weak references, then the garbage collector will collect this object. 

A weak table can have weak keys, weak values, or both. A table with weak keys allows the collection of its keys, but prevents the collection of its values. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the __mode field of its metatable. If the __mode field is a string containing the character 'k', the keys in the table are weak. If __mode contains 'v', the values in the table are weak. 

After you use a table as a metatable, you should not change the value of its __mode field. Otherwise, the weak behavior of the tables controlled by this metatable is undefined. 



2.10.2 - 弱表 
弱表是元素为弱引用的表。
弱引用被垃圾收集器忽略。（注：这里的忽略不等于不回收）
换言之，如果指向一个对象的唯一引用时弱引用，那么垃圾回收器将回收这个对象。
一个表可以有弱键，弱值，或两者都有。
一个带弱键的表允许其键的回收，但阻止其值的回收。
拥有弱键和弱值的表允许键和值的回收。
在任何情况下，如果键或值被回收，整个映射对会从表中删除。
表的弱引用属性由它的元表__mode字段控制。
如果__mode字段是包含'k'的字符串，表的键为弱引用。
如果__mode包含'v'，表的值为弱引用。
在你使用一个表作为元表后，你不应该改变它的__mode字段的值。
否则，受这个元表控制的表的弱引用行为是不确定的。









2.11 - Coroutines
Lua supports coroutines, also called collaborative multithreading. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function. 

You create a coroutine with a call to coroutine.create. Its sole argument is a function that is the main function of the coroutine. The create function only creates a new coroutine and returns a handle to it (an object of type thread); it does not start the coroutine execution. 

When you first call coroutine.resume, passing as its first argument a thread returned by coroutine.create, the coroutine starts its execution, at the first line of its main function. Extra arguments passed to coroutine.resume are passed on to the coroutine main function. After the coroutine starts running, it runs until it terminates or yields. 

A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In the first case, coroutine.resume returns true, plus any values returned by the coroutine main function. In case of errors, coroutine.resume returns false plus an error message. 

A coroutine yields by calling coroutine.yield. When a coroutine yields, the corresponding coroutine.resume returns immediately, even if the yield happens inside nested function calls (that is, not in the main function, but in a function directly or indirectly called by the main function). In the case of a yield, coroutine.resume also returns true, plus any values passed to coroutine.yield. The next time you resume the same coroutine, it continues its execution from the point where it yielded, with the call to coroutine.yield returning any extra arguments passed to coroutine.resume. 

Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to coroutine.resume. coroutine.wrap returns all the values returned by coroutine.resume, except the first one (the boolean error code). Unlike coroutine.resume, coroutine.wrap does not catch errors; any error is propagated to the caller. 

As an example, consider the following code: 

     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
            
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))

When you run it, it produces the following output: 

     co-body 1       10
     foo     2
     
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine



2.11 - 协程 
Lua支持协程，它也被称为协同多线程。
Lua中的协程代表一个独立执行的线程。
然而不同于多线程系统的线程，协程只能通过yield函数的显式调用挂起它的执行。
你调用coroutine.create创建一个协程。
它唯一的参数是一个作为协程主函数的函数。
create函数只创建一个新协程，并返回它的句柄（一个thread类型对象），它不启动协程的执行。
当你第一次调用coroutine.resume，把coroutine.create返回的一个线程作为第一个参数传递给它，则协程从主函数的第一行开始执行。
传递给coroutine.resume的额外参数传递给协程的主函数。
协程开始运行后，它将一直运行直至结束或者挂起。 
协同程序可以用两种方式结束它的执行：通常情况下，它的主函数返回（显式或者隐式，在最后一个指令之后）；以及异常，如果发生一个不受保护的错误。
对于第一种情况，coroutine.resume返回true，以及协程主函数的所有返回值。
对于错误的情况，coroutine.resume返回false，以及一个错误消息。
通过调用coroutine.yield挂起（暂停）协程。
当一个协程挂起，相应的coroutine.resume会立即返回，即使挂起发生在嵌套函数调用的内部（即不是在主函数中而是在一个直接或间接被主函数调用的函数中）。
在挂起的情况下，coroutine.resume也返回true，以及传递给coroutine.yield的任何值。
下次你恢复相同的协程时，它会继续从它挂起的地方开始执行，在那里coroutine.yield的调用会返回（执行resume时）传递给coroutine.resume的所有值。
像coroutine.create那样，coroutine.wrap函数也能创建协同程序，但不是返回协程自身，而是返回一个函数，当调用它时，恢复协程。
传递给此函数的任何参数会作为coroutine.resume的额外参数。
coroutine.wrap返回coroutine.resume所返回的所有值，除了第一个返回值（布尔型的错误码）。
不同于coroutine.resume，coroutine.wrap不捕获错误，任何错误会传播给调用者。
作为例子，考虑以下代码：
function foo (a)
   print("foo", a)
   return coroutine.yield(2*a)
end
 
co = coroutine.create(function (a,b)
	   print("co-body", a, b)
	   local r = foo(a+1)
	   print("co-body", r)
	   local r, s = coroutine.yield(a+b, a-b)
	   print("co-body", r, s)
	   return b, "end"
end)
		
print("main", coroutine.resume(co, 1, 10))
print("main", coroutine.resume(co, "r"))
print("main", coroutine.resume(co, "x", "y"))
print("main", coroutine.resume(co, "x", "y"))
当你运行它时，它产生如下输出：
co-body 1       10
foo     2

main    true    4
co-body r
main    true    11      -9
co-body x       y
main    true    10      end
main    false   cannot resume dead coroutine





3 - The Application Program Interface
This section describes the C API for Lua, that is, the set of C functions available to the host program to communicate with Lua. All API functions and related types and constants are declared in the header file lua.h. 

Even when we use the term "function", any facility in the API may be provided as a macro instead. All such macros use each of their arguments exactly once (except for the first argument, which is always a Lua state), and so do not generate any hidden side-effects. 

As in most C libraries, the Lua API functions do not check their arguments for validity or consistency. However, you can change this behavior by compiling Lua with a proper definition for the macro luai_apicheck, in file luaconf.h. 



3 - 应用程序接口 
本节描述Lua的C API，即提供给宿主程序和Lua通信的有效的C函数集合。
所有API函数和相关类型以及常量在头文件lua.h中声明. 
虽然我们使用术语“函数”，任何提供的API工具都可能是一个宏。
所有这些宏准确地使用一次它们的参数（除了第一个参数，它始终是一个Lua状态），所以不会产生任何隐藏的副作用。 
正如大多数C库，Lua的API函数不检查它们参数的有效性或一致性。
但是，你可以通过合适的luai_apicheck宏定义编译Lua来改变这种行为，该宏定义在文件luaconf.h。








3.1 - The Stack
Lua uses a virtual stack to pass values to and from C. Each element in this stack represents a Lua value (nil, number, string, etc.). 

Whenever Lua calls C, the called function gets a new stack, which is independent of previous stacks and of stacks of C functions that are still active. This stack initially contains any arguments to the C function and it is where the C function pushes its results to be returned to the caller (see lua_CFunction). 

For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an index: A positive index represents an absolute stack position (starting at 1); a negative index represents an offset relative to the top of the stack. More specifically, if the stack has n elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index n represents the last element; index -1 also represents the last element (that is, the element at the top) and index -n represents the first element. We say that an index is valid if it lies between 1 and the stack top (that is, if 1 ≤ abs(index) ≤ top). 





3.1 - 堆栈
Lua使用一个虚拟栈与C来回传递值。
堆栈中每个元素代表一个Lua值（空值，数，字符串等）。 
每当Lua中调用C，被调用函数获得一个新的堆栈，独立于仍旧激活的前一个堆栈和前一个C函数的堆栈。
这个堆栈最初包含传递给C函数的任何参数，它也是C函数压入结果以返回给它的调用者的地方（见见lua_CFunction）。
方便起见，大多数API的查询操作不遵循严格的堆栈约定。
取而代之，他们可以通过使用索引来引用堆栈中的任意元素：
正索引代表绝对的堆栈位置（从1开始）；一个负索引代表相对栈顶的偏移。
更具体来说，如果栈有n个元素，那么索引1代表第一个元素（即第一个压入堆栈的元素）而索引n表示最后一个元素；
索引-1也代表最后一个元素（即栈顶的元素）而索引n代表第一个元素。
如果一个索引在1和栈顶之间（即如果1 <= index的绝对值 <= 栈顶索引），则我们说这个索引是合法的。











3.2 - Stack Size
When you interact with Lua API, you are responsible for ensuring consistency. In particular, you are responsible for controlling stack overflow. You can use the function lua_checkstack to grow the stack size. 

Whenever Lua calls C, it ensures that at least LUA_MINSTACK stack positions are available. LUA_MINSTACK is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack. 

Most query functions accept as indices any value inside the available stack space, that is, indices up to the maximum stack size you have set through lua_checkstack. Such indices are called acceptable indices. More formally, we define an acceptable index as follows: 

     (index < 0 && abs(index) <= top) ||
     (index > 0 && index <= stackspace)

Note that 0 is never an acceptable index. 




3.2 - 堆栈大小 
当你与Lua的API交互时，你要负责确保一致性。
特别地，你要负责控制堆栈的溢出。
你可以使用函数lua_checkstack增加栈的大小。
当Lua调用C时，可确保至少有LUA_MINSTACK个堆栈位置可用。
LUA_MINSTACK被定义为20，所以你通常不必担心堆栈空间，除非你的代码循环把元素压入堆栈。
大多数请求函数把有效堆栈空间中的任意值以索引的形式接受（注：以索引来表示值的引用），索引不超过你通过lua_checkstack设置的最大堆栈大小。
这种索引被称为可接受索引。
更正式地，我们以如下方式定义可接受索引：
(index < 0 && abs(index) <= top) ||
(index > 0 && index <= stackspace)
注意0不是一个可接受索引。








3.3 - Pseudo-Indices
Unless otherwise noted, any function that accepts valid indices can also be called with pseudo-indices, which represent some Lua values that are accessible to C code but which are not in the stack. Pseudo-indices are used to access the thread environment, the function environment, the registry, and the upvalues of a C function (see §3.4). 

The thread environment (where global variables live) is always at pseudo-index LUA_GLOBALSINDEX. The environment of the running C function is always at pseudo-index LUA_ENVIRONINDEX. 

To access and change the value of global variables, you can use regular table operations over an environment table. For instance, to access the value of a global variable, do 

     lua_getfield(L, LUA_GLOBALSINDEX, varname);



3.3 - 伪索引 
除非另外说明，任何接受合法索引的函数还可以用伪索引调用，伪索引代表一些不在堆栈中但可以被C代码访问的Lua值。
伪索引用于访问线程环境，函数环境，注册表，以及一个C函数的upvalue（见§3.4）。
线程环境（全局变量所在的地方）总是在伪索引LUA_GLOBALSINDEX处。
正在运行的C函数的环境总是在伪索引LUA_ENVIRONINDEX处。 
访问和改变全局变量的值，你可以在一个环境表上执行常规的表操作。
例如，要访问一个全局变量的值，可以执行 
lua_getfield(L, LUA_GLOBALSINDEX, varname);




3.4 - C Closures
When a C function is created, it is possible to associate some values with it, thus creating a C closure; these values are called upvalues and are accessible to the function whenever it is called (see lua_pushcclosure). 

Whenever a C function is called, its upvalues are located at specific pseudo-indices. These pseudo-indices are produced by the macro lua_upvalueindex. The first value associated with a function is at position lua_upvalueindex(1), and so on. Any access to lua_upvalueindex(n), where n is greater than the number of upvalues of the current function (but not greater than 256), produces an acceptable (but invalid) index. 


3.4 - C闭包（注：指用C实现而在Lua中使用的闭包）
当一个C函数被创建，它有可能关联一些值，从而建立一个C闭包，这些值被称为upvalues，并且在调用时可访问（见lua_pushcclosure）函数。
（注：类似于C的静态局部变量）
当一个C函数被调用时，它的upvalue位于特定的伪索引处。
这些伪索引是由宏lua_upvalueindex产生。
第一个被函数关联的值在lua_upvalueindex(1)处，如此类推。
任何对lua_upvalueindex(n)的访问，如果n大于当前函数的upvalue个数（但不超过256），将产生一个可以接受的（但非法）的索引。 



3.5 - Registry
Lua provides a registry, a pre-defined table that can be used by any C code to store whatever Lua value it needs to store. This table is always located at pseudo-index LUA_REGISTRYINDEX. Any C library can store data into this table, but it should take care to choose keys different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name or a light userdata with the address of a C object in your code. 

The integer keys in the registry are used by the reference mechanism, implemented by the auxiliary library, and therefore should not be used for other purposes. 



3.5 - 注册表 
Lua提供注册表，一个预定义的表，任何C代码可以用它来存储任何需要存储的Lua值。
这个表总是位于伪索引LUA_REGISTRYINDEX处。
任何C库都可以存储数据进这个表，但应注意选择不同于其它库所用的键，以避免冲突。
通常，你应该使用一个包含库名称的键或那些携带你代码中C对象地址的轻量级userdata。 
注册表中的整数键用于引用机制，由辅助库实现，因此不应用于其他用途。 









3.6 - Error Handling in C
Internally, Lua uses the C longjmp facility to handle errors. (You can also choose to use exceptions if you use C++; see file luaconf.h.) When Lua faces any error (such as memory allocation errors, type errors, syntax errors, and runtime errors) it raises an error; that is, it does a long jump. A protected environment uses setjmp to set a recover point; any error jumps to the most recent active recover point. 

Most functions in the API can throw an error, for instance due to a memory allocation error. The documentation for each function indicates whether it can throw errors. 

Inside a C function you can throw an error by calling lua_error. 



3.6 - C的错误处理 
在实现内部，Lua使用C的longjmp工具处理错误。 
（如果你使用C++；您也可以选择使用异常；见luaconf.h）
当Lua遇到任意错误时（例如内存分配错误，类型错误，语法错误和运行时错误）它会引发一个错误，即它会执行一个长跳转。
一个受保护的环境使用setjmp设置一个恢复点；任何错误会跳转到最近激活的恢复点。
大部分API的函数都可能抛出一个错误，比如因为内存分配错误。
每个函数的文档会指出它是否可能抛出错误。
在C函数内部，你可以通过调用lua_error抛出错误。
















3.7 - Functions and Types
Here we list all functions and types from the C API in alphabetical order. Each function has an indicator like this: [-o, +p, x] 

The first field, o, is how many elements the function pops from the stack. The second field, p, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form x|y means the function can push (or pop) x or y elements, depending on the situation; an interrogation mark '?' means that we cannot know how many elements the function pops/pushes by looking only at its arguments (e.g., they may depend on what is on the stack). The third field, x, tells whether the function may throw errors: '-' means the function never throws any error; 'm' means the function may throw an error only due to not enough memory; 'e' means the function may throw other kinds of errors; 'v' means the function may throw an error on purpose. 


3.7 - 函数和类型
这里我们以字母顺序列举所有CAPI的函数和类型。
每个函数有一个好像这样子的指示符：[-o, +p, x]
第一个字段o是指有多少元素从堆栈中弹出。
第二个字段p是指有多少元素压入堆栈中。
（如何函数总是在弹出它的参数之后压入它的结果。）
以x|y形式表示的字段意思是函数可以压入（或弹出）x或y个元素，依赖于实际情况；
一个问号'?'意思是只通过看它的参数我们无法知道函数弹出或压入多少元素（例如，它们可能依赖于堆栈里的东西）。
第三个字段x告知函数是否抛出错误：'-'表示函数从不抛出错误；
'm'表示函数只会因为不够内存才会抛出错误；
'e'表示函数可能会抛出其它类型的错误；
'v'表示函数可能会故意抛出错误。


--------------------------------------------------------------------------------

lua_Alloc
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);
The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to realloc, but not exactly the same. Its arguments are ud, an opaque pointer passed to lua_newstate; ptr, a pointer to the block being allocated/reallocated/freed; osize, the original size of the block; nsize, the new size of the block. ptr is NULL if and only if osize is zero. When nsize is zero, the allocator must return NULL; if osize is not zero, it should free the block pointed to by ptr. When nsize is not zero, the allocator returns NULL if and only if it cannot fill the request. When nsize is not zero and osize is zero, the allocator should behave like malloc. When nsize and osize are not zero, the allocator behaves like realloc. Lua assumes that the allocator never fails when osize >= nsize. 

Here is a simple implementation for the allocator function. It is used in the auxiliary library by luaL_newstate. 

     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }

This code assumes that free(NULL) has no effect and that realloc(NULL, size) is equivalent to malloc(size). ANSI C ensures both behaviors. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Alloc
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);
这种类型的内存分配函数由Lua状态机使用。分配器函数必须提供类似realloc的功能，但是不必完全一样。它的参数是ud，一个由lua_newstate传入的不透明指针；ptr，一个指向即将被分配/重分配/释放的内存块的指针；osize，内存块原来的尺寸；nsize，内存块的新尺寸。当且仅当osize是0时ptr为NULL。当nsize是0时，分配器必须返回NULL；如果osize非0，它将会释放ptr指向的内存块。当nsize非0时，当且仅当分配器不能满足请求时返回NULL。当nsize非0且osize是0时，分配器应该表现的类似malloc。当nsize和osize非0时，分配器表现的类似realloc。Lua假定当osize >= nsize时分配器决不失败。 

这儿有个分配器函数的简单实现。它被辅助库中的被luaL_newstate使用。 

     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }

该代码假定free(NULL)不起作用而且realloc(NULL, size)等价于malloc(size)。ANSI C确保这两种行为。 


--------------------------------------------------------------------------------

lua_atpanic
[-0, +0, -] 

lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
Sets a new panic function and returns the old one. 

If an error happens outside any protected environment, Lua calls a panic function and then calls exit(EXIT_FAILURE), thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump). 

The panic function can access the error message at the top of the stack. 


--------------------------------------------------------------------------------
（注：TODO）

lua_atpanic
[-0, +0, -] 

lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
设置新的应急（panic）函数并返回前一个。 

如果在任何受保护的环境外面发生了错误，Lua调用应急函数接着调用exit(EXIT_FAILURE)，从而退出宿主程序。你的应急函数可通过永不返回（例如执行一次长跳转）以避免这次退出。 

应急函数可访问栈顶的错误消息。 

--------------------------------------------------------------------------------

lua_call
[-(nargs + 1), +nresults, e] 

void lua_call (lua_State *L, int nargs, int nresults);
Calls a function. 

To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call lua_call; nargs is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to nresults, unless nresults is LUA_MULTRET. In this case, all results from the function are pushed. Lua takes care that the returned values fit into the stack space. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack. 

Any error inside the called function is propagated upwards (with a longjmp). 

The following example shows how the host program can do the equivalent to this Lua code: 

     a = f("how", t.x, 14)

Here it is in C: 

     lua_getfield(L, LUA_GLOBALSINDEX, "f"); /* function to be called */
     lua_pushstring(L, "how");                        /* 1st argument */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");   /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* set global 'a' */

Note that the code above is "balanced": at its end, the stack is back to its original configuration. This is considered good programming practice. 


--------------------------------------------------------------------------------
（注：TODO）

lua_call
[-(nargs + 1), +nresults, e] 

void lua_call (lua_State *L, int nargs, int nresults);
调用一个函数。 

要调用函数必须使用下面的协议：首先，将要被调用的函数压栈；然后，将函数参数顺序压栈；即第一参数首先压栈。最后，调用lua_call；nargs是你压栈的参数数量。当函数被调用时所有参数以及函数值被弹出栈。当函数返回时其结果被压栈。结果被调整为nresults个，除非nresults是LUA_MULTRET。在该情况下，来自函数的所有结果被压栈。Lua会确保返回值适合栈空间。函数结果被顺序压栈（第一个结果首先压栈），因而调用后最后一个结果在栈顶。 

被调用函数内的任何错误会被向上传播（使用longjmp）。 

下面的例子显示宿主程序可如何执行与该Lua代码等价的操作： 

     a = f("how", t.x, 14)

这是C中的代码： 

     lua_getfield(L, LUA_GLOBALSINDEX, "f");          /* 要被调用的函数 */
     lua_pushstring(L, "how");                             /* 第1个参数 */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");            /* 要被索引的表 */
     lua_getfield(L, -1, "x");           /* 将t.x的结果压栈（第2个参数） */
     lua_remove(L, -2);                  /* 从栈中删除‘t’ */
     lua_pushinteger(L, 14);                               /* 第3个参数 */
     lua_call(L, 3, 1);               /* 以3个参数调用‘f’，返回1个结果 */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* 设置全局变量‘a’ */

注意上面的代码是“对称的”：在其结尾，栈回到其初始配置。这是一种良好的编程习惯。 


--------------------------------------------------------------------------------

lua_CFunction
typedef int (*lua_CFunction) (lua_State *L);
Type for C functions. 

In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, lua_gettop(L) returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index lua_gettop(L). To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results. 

As an example, the following function receives a variable number of numerical arguments and returns their average and sum: 

     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0;
       int i;
       for (i = 1; i <= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }

--------------------------------------------------------------------------------
（注：TODO）

lua_CFunction
typedef int (*lua_CFunction) (lua_State *L);
用于C函数的类型。 

为了与Lua恰当地通讯，C函数必须使用下面的协议，它定义了参数和结果的传递方式：C函数在其栈中以顺序的方式（第一参数被首先压栈）接收来自Lua的参数。所以，当函数开始时，lua_gettop(L)返回函数收到的参数个数。第一参数（如果存在）在索引1处，最后的参数在索引lua_gettop(L)处。要向Lua返回值，C函数只需要将它们顺序压栈（第一个结果被首先压栈），并返回结果的个数。栈中结果下面的任何其他值将被Lua恰当地丢弃。同Lua函数一样，被Lua调用的C函数也能返回多个结果。 

作为例子，下面的函数接收可变数量的数字参数，并返回它们的平均数与总和： 

     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数的个数 */
       lua_Number sum = 0;
       int i;
       for (i = 1; i <= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第1个参数 */
       lua_pushnumber(L, sum);         /* 第2个参数 */
       return 2;                   /* 结果的个数 */
     }

--------------------------------------------------------------------------------

lua_checkstack
[-0, +0, m] 

int lua_checkstack (lua_State *L, int extra);
Ensures that there are at least extra free stack slots in the stack. It returns false if it cannot grow the stack to that size. This function never shrinks the stack; if the stack is already larger than the new size, it is left unchanged. 

--------------------------------------------------------------------------------
（注：TODO）

lua_checkstack
[-0, +0, m] 

int lua_checkstack (lua_State *L, int extra);
确保栈中存在至少extra个空闲栈槽位。如果栈不能增长到那个尺寸则返回假。本函数从不缩小栈；如果栈已经比新尺寸大则无变化。 


--------------------------------------------------------------------------------

lua_close
[-0, +0, -] 

void lua_close (lua_State *L);
Destroys all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any) and frees all dynamic memory used by this state. On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs, such as a daemon or a web server, might need to release states as soon as they are not needed, to avoid growing too large. 

--------------------------------------------------------------------------------
（注：TODO）

lua_close
[-0, +0, -] 

void lua_close (lua_State *L);
销毁给定Lua状态机中的全部对象（如果存在对应的垃圾收集元方法则调用它们），并释放该状态机占用的所有动态内存。在一些平台上，你可能不需要调用本函数，因为当宿主程序结束时，所有资源自然地被释放。另一方面，长期运行的程序，比如后台程序（daemon）或web服务器，可能需要在状态机不再需要时立刻释放它们，以避免增长过大。 

--------------------------------------------------------------------------------

lua_concat
[-n, +1, e] 

void lua_concat (lua_State *L, int n);
Concatenates the n values at the top of the stack, pops them, and leaves the result at the top. If n is 1, the result is the single value on the stack (that is, the function does nothing); if n is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see §2.5.4). 

--------------------------------------------------------------------------------
（注：TODO）

lua_concat
[-n, +1, e] 

void lua_concat (lua_State *L, int n);
连接栈顶的n个值，弹出它们并将结果留在栈顶。如果n是1，结果就是栈上的单个值（即函数什么也不做）；如果n是0，结果是空字符串。连接操作依照Lua的常规语义执行（见§2.5.4）。 

--------------------------------------------------------------------------------

lua_cpcall
[-0, +(0|1), -] 

int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
Calls the C function func in protected mode. func starts with only one element in its stack, a light userdata containing ud. In case of errors, lua_cpcall returns the same error codes as lua_pcall, plus the error object on the top of the stack; otherwise, it returns zero, and does not change the stack. All values returned by func are discarded. 

--------------------------------------------------------------------------------
（注：TODO）

lua_cpcall
[-0, +(0|1), -] 

int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
以保护模式调用C函数func。func的栈中只有一个元素，是个包含ud的轻量级用户数据。发生错误时，lua_cpcall返回同lua_pcall一样的错误代码，以及栈顶的错误对象；否则返回0且不改变栈。func返回的所有值被丢弃。 

--------------------------------------------------------------------------------

lua_createtable
[-0, +1, m] 

void lua_createtable (lua_State *L, int narr, int nrec);
Creates a new empty table and pushes it onto the stack. The new table has space pre-allocated for narr array elements and nrec non-array elements. This pre-allocation is useful when you know exactly how many elements the table will have. Otherwise you can use the function lua_newtable. 

--------------------------------------------------------------------------------
（注：TODO）

lua_createtable
[-0, +1, m] 

void lua_createtable (lua_State *L, int narr, int nrec);
创建新的空表并将其压栈。新表预分配narr个数组元素和nrec个非数组元素的空闲空间。当你确切地知道表将由多少个元素时，预分配是非常有用的。否则，你可用函数lua_newtable。 


--------------------------------------------------------------------------------

lua_dump
[-0, +0, m] 

int lua_dump (lua_State *L, lua_Writer writer, void *data);
Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped. As it produces parts of the chunk, lua_dump calls function writer (see lua_Writer) with the given data to write them. 

The value returned is the error code returned by the last call to the writer; 0 means no errors. 

This function does not pop the Lua function from the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_dump
[-0, +0, m] 

int lua_dump (lua_State *L, lua_Writer writer, void *data);
将函数转储为二进制代码单元。接收栈顶的Lua函数并产生二进制单元，如果后者被再次加载，得到与被转储的等价的函数。当产生单元的各部分时，lua_dump用给定的data调用函数writer（见lua_Writer）来写出它们。 

返回值是最后一次调用记录器（writer）返回的错误代码；0表示没有错误。 

本函数不会将Lua函数从栈中弹出。 

--------------------------------------------------------------------------------

lua_equal
[-0, +0, e] 

int lua_equal (lua_State *L, int index1, int index2);
Returns 1 if the two values in acceptable indices index1 and index2 are equal, following the semantics of the Lua == operator (that is, may call metamethods). Otherwise returns 0. Also returns 0 if any of the indices is non valid. 
--------------------------------------------------------------------------------
（注：TODO）

lua_equal
[-0, +0, e] 

int lua_equal (lua_State *L, int index1, int index2);
沿用Lua的==操作符的语义（即可能调用元方法），比较在可接受索引index1和index2中的两个值，如果相等则返回1。否则返回0。如果任何索引无效也返回0。 

--------------------------------------------------------------------------------

lua_error
[-1, +0, v] 

int lua_error (lua_State *L);
Generates a Lua error. The error message (which can actually be a Lua value of any type) must be on the stack top. This function does a long jump, and therefore never returns. (see luaL_error). 

--------------------------------------------------------------------------------
（注：TODO）

lua_error
[-1, +0, v] 

int lua_error (lua_State *L);
产生一个Lua错误。错误消息（实际上可为任何类型的Lua值）必须在栈顶。本函数执行长跳转，因此从不返回。（见luaL_error）。 

--------------------------------------------------------------------------------

lua_gc
[-0, +0, e] 

int lua_gc (lua_State *L, int what, int data);
Controls the garbage collector. 

This function performs several tasks, according to the value of the parameter what: 

LUA_GCSTOP: stops the garbage collector. 
LUA_GCRESTART: restarts the garbage collector. 
LUA_GCCOLLECT: performs a full garbage-collection cycle. 
LUA_GCCOUNT: returns the current amount of memory (in Kbytes) in use by Lua. 
LUA_GCCOUNTB: returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024. 
LUA_GCSTEP: performs an incremental step of garbage collection. The step "size" is controlled by data (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of data. The function returns 1 if the step finished a garbage-collection cycle. 
LUA_GCSETPAUSE: sets data as the new value for the pause of the collector (see §2.10). The function returns the previous value of the pause. 
LUA_GCSETSTEPMUL: sets data as the new value for the step multiplier of the collector (see §2.10). The function returns the previous value of the step multiplier. 

--------------------------------------------------------------------------------
（注：TODO）

lua_gc
[-0, +0, e] 

int lua_gc (lua_State *L, int what, int data);
控制垃圾收集器。 

本函数根据参数what的值执行若干任务： 

LUA_GCSTOP: 停止垃圾收集器。 
LUA_GCRESTART: 重新启动垃圾收集器。 
LUA_GCCOLLECT: 执行一次完整的垃圾收集器周期。 
LUA_GCCOUNT: 返回Lua当前占用的内存总量（以Kbyte为单位）。 
LUA_GCCOUNTB: 返回Lua当前的内存用量的字节数除1024的余数。 
LUA_GCSTEP: 执行一步增量垃圾收集。步“长”由data以未指定的方式控制（值越大意味着步骤越多）。要控制步长，你必须实验性地调整data的值。如果该步完成了一个垃圾收集周期则函数返回1。 
LUA_GCSETPAUSE: 设置data作为收集器的pause（见§2.10）的新值。返回pause的前一个值。 
LUA_GCSETSTEPMUL: 设置data作为收集器的step multiplier（见§2.10）的新值。返回step multiplier的前一个值。 


--------------------------------------------------------------------------------

lua_getallocf
[-0, +0, -] 

lua_Alloc lua_getallocf (lua_State *L, void **ud);
Returns the memory-allocation function of a given state. If ud is not NULL, Lua stores in *ud the opaque pointer passed to lua_newstate. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getallocf
[-0, +0, -] 

lua_Alloc lua_getallocf (lua_State *L, void **ud);
返回给定状态机的内存分配函数。如果ud不为NULL，Lua将lua_newstate传入的不透明指针存入*ud。 

--------------------------------------------------------------------------------

lua_getfenv
[-0, +1, -] 

void lua_getfenv (lua_State *L, int index);
Pushes onto the stack the environment table of the value at the given index. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getfenv
[-0, +1, -] 

void lua_getfenv (lua_State *L, int index);
将给定索引处的值的环境表压栈。 

--------------------------------------------------------------------------------

lua_getfield
[-0, +1, e] 

void lua_getfield (lua_State *L, int index, const char *k);
Pushes onto the stack the value t[k], where t is the value at the given valid index. As in Lua, this function may trigger a metamethod for the "index" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_getfield
[-0, +1, e] 

void lua_getfield (lua_State *L, int index, const char *k);
将t[k]的值压栈，其中t是给定的有效索引处的值。同Lua中一样，本函数可能触发用于“index”事件的元方法（见§2.8）。 

--------------------------------------------------------------------------------

lua_getglobal
[-0, +1, e] 

void lua_getglobal (lua_State *L, const char *name);
Pushes onto the stack the value of the global name. It is defined as a macro: 

     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)

--------------------------------------------------------------------------------
（注：TODO）

lua_getglobal
[-0, +1, e] 

void lua_getglobal (lua_State *L, const char *name);
将全局变量name的值压栈。它被定义为宏： 

     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)


--------------------------------------------------------------------------------

lua_getmetatable
[-0, +(0|1), -] 

int lua_getmetatable (lua_State *L, int index);
Pushes onto the stack the metatable of the value at the given acceptable index. If the index is not valid, or if the value does not have a metatable, the function returns 0 and pushes nothing on the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getmetatable
[-0, +(0|1), -] 

int lua_getmetatable (lua_State *L, int index);
将给定的认可的索引处的值的元表压栈。如果索引无效，或者如果该值没有元表，本函数返回0且不会压栈任何东西。 

--------------------------------------------------------------------------------

lua_gettable
[-1, +1, e] 

void lua_gettable (lua_State *L, int index);
Pushes onto the stack the value t[k], where t is the value at the given valid index and k is the value at the top of the stack. 

This function pops the key from the stack (putting the resulting value in its place). As in Lua, this function may trigger a metamethod for the "index" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_gettable
[-1, +1, e] 

void lua_gettable (lua_State *L, int index);
将值t[k]压栈，其中t是指定的有效索引处的值，并且k是栈顶的值。 

本函数将键出栈（将结果值放在它的位置）。同Lua中一样，本函数可能触发用于“index”事件的元方法（见§2.8）。 

--------------------------------------------------------------------------------

lua_gettop
[-0, +0, -] 

int lua_gettop (lua_State *L);
Returns the index of the top element in the stack. Because indices start at 1, this result is equal to the number of elements in the stack (and so 0 means an empty stack). 

--------------------------------------------------------------------------------
（注：TODO）

lua_gettop
[-0, +0, -] 

int lua_gettop (lua_State *L);
返回栈顶元素的索引。因为索引从1开始，该结果等于栈中元素的数量（所以0表示空栈）。 

--------------------------------------------------------------------------------

lua_insert
[-1, +1, -] 

void lua_insert (lua_State *L, int index);
Moves the top element into the given valid index, shifting up the elements above this index to open space. Cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 

--------------------------------------------------------------------------------
（注：TODO）

lua_insert
[-1, +1, -] 

void lua_insert (lua_State *L, int index);
将栈顶元素移入给定的有效索引，并将该索引上面的元素上移至开放空间。不能以伪索引调用，因为伪索引不是真实的栈位置。 

--------------------------------------------------------------------------------

lua_Integer
typedef ptrdiff_t lua_Integer;
The type used by the Lua API to represent integral values. 

By default it is a ptrdiff_t, which is usually the largest signed integral type the machine handles "comfortably". 

--------------------------------------------------------------------------------
（注：TODO）

lua_Integer
typedef ptrdiff_t lua_Integer;
被Lua API用来表示整型值的类型。 

缺省是ptrdiff_t，它通常是机器能处理的最大的带符号整型。 

--------------------------------------------------------------------------------

lua_isboolean
[-0, +0, -] 

int lua_isboolean (lua_State *L, int index);
Returns 1 if the value at the given acceptable index has type boolean, and 0 otherwise. 

--------------------------------------------------------------------------------
（注：TODO）

lua_isboolean
[-0, +0, -] 

int lua_isboolean (lua_State *L, int index);
如果给定的认可的索引处的值具有布尔类型则返回1，否则返回0。 


--------------------------------------------------------------------------------

lua_iscfunction
[-0, +0, -] 

int lua_iscfunction (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a C function, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_iscfunction
[-0, +0, -] 

int lua_iscfunction (lua_State *L, int index);
如果所给可接受索引处的值为C函数则返回1，否则返回0。

--------------------------------------------------------------------------------

lua_isfunction
[-0, +0, -] 

int lua_isfunction (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a function (either C or Lua), and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isfunction
[-0, +0, -] 

int lua_isfunction (lua_State *L, int index);
如果所给可接受索引处的值为函数（C或者是Lua）则返回1，否则返回0。

--------------------------------------------------------------------------------

lua_islightuserdata
[-0, +0, -] 

int lua_islightuserdata (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a light userdata, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_islightuserdata
[-0, +0, -] 

int lua_islightuserdata (lua_State *L, int index);
如果所给可接受索引处的值为轻量级userdata则返回1，否则返回0。

--------------------------------------------------------------------------------

lua_isnil
[-0, +0, -] 

int lua_isnil (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is nil, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isnil
[-0, +0, -] 

int lua_isnil (lua_State *L, int index);
如果所给可接受索引处的值为nil则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isnone
[-0, +0, -] 

int lua_isnone (lua_State *L, int index);
Returns 1 if the given acceptable index is not valid (that is, it refers to an element outside the current stack), and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isnone
[-0, +0, -] 

int lua_isnone (lua_State *L, int index);
如果所给可接受索引处的值不可用（即引用的元素在当前堆栈以外）则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isnoneornil
[-0, +0, -] 

int lua_isnoneornil (lua_State *L, int index);
Returns 1 if the given acceptable index is not valid (that is, it refers to an element outside the current stack) or if the value at this index is nil, and 0 otherwise. 


--------------------------------------------------------------------------------

lua_isnoneornil
[-0, +0, -] 

int lua_isnoneornil (lua_State *L, int index);
如果所给可接受索引处的值不可用（即引用的元素在当前堆栈以外）或者索引处的值为nil则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isnumber
[-0, +0, -] 

int lua_isnumber (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a number or a string convertible to a number, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isnumber
[-0, +0, -] 

int lua_isnumber (lua_State *L, int index);
如果所给可接受索引处的值是数或者可转换为数的字符串则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isstring
[-0, +0, -] 

int lua_isstring (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a string or a number (which is always convertible to a string), and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isstring
[-0, +0, -] 

int lua_isstring (lua_State *L, int index);
如果所给可接受索引处的值是字符串或者数（总是可以转换为字符串）则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_istable
[-0, +0, -] 

int lua_istable (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a table, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_istable
[-0, +0, -] 

int lua_istable (lua_State *L, int index);
如果所给可接受索引处的值是表则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isthread
[-0, +0, -] 

int lua_isthread (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a thread, and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isthread
[-0, +0, -] 

int lua_isthread (lua_State *L, int index);
如果所给可接受索引处的值是一个线程则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_isuserdata
[-0, +0, -] 

int lua_isuserdata (lua_State *L, int index);
Returns 1 if the value at the given acceptable index is a userdata (either full or light), and 0 otherwise. 

--------------------------------------------------------------------------------

lua_isuserdata
[-0, +0, -] 

int lua_isuserdata (lua_State *L, int index);
如果所给可接受索引处的值是一个userdata（完全或者轻量级）则返回1，否则返回0。


--------------------------------------------------------------------------------

lua_lessthan
[-0, +0, e] 

int lua_lessthan (lua_State *L, int index1, int index2);
Returns 1 if the value at acceptable index index1 is smaller than the value at acceptable index index2, following the semantics of the Lua < operator (that is, may call metamethods). Otherwise returns 0. Also returns 0 if any of the indices is non valid. 

--------------------------------------------------------------------------------

lua_lessthan
[-0, +0, e] 

int lua_lessthan (lua_State *L, int index1, int index2);
如果所给可接受索引index1处的值小于索引index2处的值则返回1，遵循Lua的<运算符的语义（即，可能调用元方法）。
否则返回0。
如果任意索引不合法也会返回0。


--------------------------------------------------------------------------------

lua_load
[-0, +1, -] 

int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);
Loads a Lua chunk. If there are no errors, lua_load pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message. The return values of lua_load are: 

0: no errors; 
LUA_ERRSYNTAX: syntax error during pre-compilation; 
LUA_ERRMEM: memory allocation error. 
This function only loads a chunk; it does not run it. 

lua_load automatically detects whether the chunk is text or binary, and loads it accordingly (see program luac). 

The lua_load function uses a user-supplied reader function to read the chunk (see lua_Reader). The data argument is an opaque value passed to the reader function. 

The chunkname argument gives a name to the chunk, which is used for error messages and in debug information (see §3.8). 

--------------------------------------------------------------------------------

lua_load
[-0, +1, -] 

int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);
加载一个Lua块。
如果没有错误，lua_load把编译好的块作为一个Lua函数压入栈顶。
否则，它把错误信息压入栈中。
lua_load的返回值有：
0: 无错误; 
LUA_ERRSYNTAX: 在预编译时出现语法错误； 
LUA_ERRMEM: 内存分配错误。
这个函数值能加载一个块；它不会运行这个函数。
lua_load自动检测块是文本格式还是二进制格式，并且相应进行加载（见程序luac）。
lua_load函数使用一个用户提供的读入器函数读入块（见lua_Reader）。
data参数是一个传递给读入器函数的不透明值。
chunkname参数给块起名，用于错误信息以及调试信息（见§3.8）。 



--------------------------------------------------------------------------------

lua_newstate
[-0, +0, -] 

lua_State *lua_newstate (lua_Alloc f, void *ud);
Creates a new, independent state. Returns NULL if cannot create the state (due to lack of memory). The argument f is the allocator function; Lua does all memory allocation for this state through this function. The second argument, ud, is an opaque pointer that Lua simply passes to the allocator in every call. 

--------------------------------------------------------------------------------

lua_newstate
[-0, +0, -] 

lua_State *lua_newstate (lua_Alloc f, void *ud);
创建一个新的，独立的状态。
如果无法创建状态则返回NULL（因为缺少内存）。
参数f是分配器函数；Lua通过这个函数为这个状态执行所有内存分配。
第二个参数ud是一个不透明的指针。Lua简单地在每次调用时把它传递给分配器函数。


--------------------------------------------------------------------------------

lua_newtable
[-0, +1, m] 

void lua_newtable (lua_State *L);
Creates a new empty table and pushes it onto the stack. It is equivalent to lua_createtable(L, 0, 0). 

--------------------------------------------------------------------------------
（注：TODO）

lua_newtable
[-0, +1, m] 

void lua_newtable (lua_State *L);
创建新的空表并将其压栈。它等价于lua_createtable(L, 0, 0)。 


--------------------------------------------------------------------------------

lua_newthread
[-0, +1, m] 

lua_State *lua_newthread (lua_State *L);
Creates a new thread, pushes it on the stack, and returns a pointer to a lua_State that represents this new thread. The new state returned by this function shares with the original state all global objects (such as tables), but has an independent execution stack. 

There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object. 

--------------------------------------------------------------------------------
（注：TODO）

lua_newthread
[-0, +1, m] 

lua_State *lua_newthread (lua_State *L);
创建新线程，将其压栈，并返回指向lua_State的指针，它表示该新线程。本函数返回的新状态机与初始状态机共享所有全局对象（例如表），但具有独立的执行栈。 

没有关闭或销毁线程的显式函数。像任何Lua对象一样，线程受垃圾收集的支配。 


--------------------------------------------------------------------------------

lua_newuserdata
[-0, +1, m] 

void *lua_newuserdata (lua_State *L, size_t size);
This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. 

Userdata represent C values in Lua. A full userdata represents a block of memory. It is an object (like a table): you must create it, it can have its own metatable, and you can detect when it is being collected. A full userdata is only equal to itself (under raw equality). 

When Lua collects a full userdata with a gc metamethod, Lua calls the metamethod and marks the userdata as finalized. When this userdata is collected again then Lua frees its corresponding memory. 

--------------------------------------------------------------------------------
（注：TODO）

lua_newuserdata
[-0, +1, m] 

void *lua_newuserdata (lua_State *L, size_t size);
本函数分配新的给定尺寸的内存块，以块地址的方式将完整的用户数据压栈，并返回该地址。 

Lua中的用户数据表示C值。完整的用户数据表示一块内存。它是个对象（如同表）：你必须创建它，它可以有自己的元表，而且当被收集时能被检测到。完整的用户数据只等于自己（依照原始的相等比较）。 

当Lua用gc元方法收集完整的用户数据时，Lua调用该元方法并把用户数据标记为完成的。当该用户数据再次被收集时，Lua释放其对应的内存。 


--------------------------------------------------------------------------------

lua_next
[-1, +(2|0), e] 

int lua_next (lua_State *L, int index);
Pops a key from the stack, and pushes a key-value pair from the table at the given index (the "next" pair after the given key). If there are no more elements in the table, then lua_next returns 0 (and pushes nothing). 

A typical traversal looks like this: 

     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }

While traversing a table, do not call lua_tolstring directly on a key, unless you know that the key is actually a string. Recall that lua_tolstring changes the value at the given index; this confuses the next call to lua_next. 

--------------------------------------------------------------------------------
（注：TODO）

lua_next
[-1, +(2|0), e] 

int lua_next (lua_State *L, int index);
从栈中弹出一个键，并从给定的索引处的表中弹出一个键-值对（给定键的“下一”对）。如果表中没有更多的元素，则lua_next返回0（且不会压栈任何东西）。 

典型的遍历看起来像这样： 

     /* 表在栈中的索引‘t’处 */
     lua_pushnil(L);  /* 第一个键 */
     while (lua_next(L, t) != 0) {
       /* 使用‘键’（索引-2）和‘值’(索引-1） */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除‘值’；为下次迭代保留‘键’ */
       lua_pop(L, 1);
     }

当遍历表时，不要直接对键调用lua_tolstring，除非你知道键确实是字符串。回忆一下，lua_tolstring会改变给定所引处的值；这会干扰下一次调用lua_next。 


--------------------------------------------------------------------------------

lua_Number
typedef double lua_Number;
The type of numbers in Lua. By default, it is double, but that can be changed in luaconf.h. 

Through the configuration file you can change Lua to operate with another type for numbers (e.g., float or long). 

--------------------------------------------------------------------------------
（注：TODO）

lua_Number
typedef double lua_Number;
Lua中的数字类型。缺省是双精度浮点数，但是能在luaconf.h中改变。 

通过配置文件能改变Lua去操作其他的类型用作数字（例如单精度浮点数或长整型）。 


--------------------------------------------------------------------------------

lua_objlen
[-0, +0, -] 

size_t lua_objlen (lua_State *L, int index);
Returns the "length" of the value at the given acceptable index: for strings, this is the string length; for tables, this is the result of the length operator ('#'); for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0. 

--------------------------------------------------------------------------------
（注：TODO）
lua_objlen
[-0, +0, -] 

size_t lua_objlen (lua_State *L, int index);
返回给定的认可的索引处的值的“长度”：对于字符串，这是其长度；对于表，这是取长操作符（‘#’）的结果；对于用户数据，这是为其分配的内存块的尺寸；对于其他类型是0。 


--------------------------------------------------------------------------------

lua_pcall
[-(nargs + 1), +(nresults|1), -] 

int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
Calls a function in protected mode. 

Both nargs and nresults have the same meaning as in lua_call. If there are no errors during the call, lua_pcall behaves exactly like lua_call. However, if there is any error, lua_pcall catches it, pushes a single value on the stack (the error message), and returns an error code. Like lua_call, lua_pcall always removes the function and its arguments from the stack. 

If errfunc is 0, then the error message returned on the stack is exactly the original error message. Otherwise, errfunc is the stack index of an error handler function. (In the current implementation, this index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error message and its return value will be the message returned on the stack by lua_pcall. 

Typically, the error handler function is used to add more debug information to the error message, such as a stack traceback. Such information cannot be gathered after the return of lua_pcall, since by then the stack has unwound. 

The lua_pcall function returns 0 in case of success or one of the following error codes (defined in lua.h): 

LUA_ERRRUN: a runtime error. 
LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the error handler function. 
LUA_ERRERR: error while running the error handler function. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pcall
[-(nargs + 1), +(nresults|1), -] 

int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
在保护模式中调用函数。 

nargs和nresults同lua_call中的有相同的含义。如果调用期间没有错误，lua_pcall的行为完全类似lua_call。然而，如果存在任何错误，lua_pcall捕捉它，将单个值压栈（错误消息），并返回错误代码。同lua_call一样，lua_pcall总是从栈中移除函数及其参数。 

如果errfunc是0，则在栈上返回的错误消息就是原始的错误消息。否则,errfunc就是错误处理器函数（error handler function）的栈索引。（当前实现中，该索引不能是伪索引。）在发生运行时错误时，该函数将用错误消息调用，而且其返回值将变成栈上被lua_pcall返回的消息。 

典型地，错误处理器函数用于向错误消息中增加更多调试信息，例如栈回溯。这种信息不能在lua_pcall返回后搜集，因为那时候栈已释放。 

成功时lua_pcall函数返回0，或者下面的错误代码之一（在lua.h中定义）： 

LUA_ERRRUN: 运行时错误。 
LUA_ERRMEM: 内存分配错误。对于这类错误，Lua不会调用错误处理器函数。 
LUA_ERRERR: 当运行错误处理器函数时的错误。 


--------------------------------------------------------------------------------

lua_pop
[-n, +0, -] 

void lua_pop (lua_State *L, int n);
Pops n elements from the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pop
[-n, +0, -] 

void lua_pop (lua_State *L, int n);
从栈中弹出n个元素。 


--------------------------------------------------------------------------------

lua_pushboolean
[-0, +1, -] 

void lua_pushboolean (lua_State *L, int b);
Pushes a boolean value with value b onto the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushboolean
[-0, +1, -] 

void lua_pushboolean (lua_State *L, int b);
把值b作为布尔值压栈。 


--------------------------------------------------------------------------------

lua_pushcclosure
[-n, +1, m] 

void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
Pushes a new C closure onto the stack. 

When a C function is created, it is possible to associate some values with it, thus creating a C closure (see §3.4); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values should be pushed onto the stack (when there are multiple values, the first value is pushed first). Then lua_pushcclosure is called to create and push the C function onto the stack, with the argument n telling how many values should be associated with the function. lua_pushcclosure also pops these values from the stack. 

The maximum value for n is 255. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushcclosure
[-n, +1, m] 

void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
把新的C闭包压栈。 

当C函数被创建时，它可以把一些值与自己关联，这样就创建了C闭包（见§3.4）；接下来无论何时它被调用，这些值对该函数都是可访问的。要将值与C函数关联，首先这些值应当被压栈（当有多个值时第一个值首先压栈）。然后用参数n调用lua_pushcclosure来创建C函数并将其压栈，n表明应当把多少值关联到该函数。lua_pushcclosure也会将这些值从栈中弹出。 

n的最大值是255。 


--------------------------------------------------------------------------------

lua_pushcfunction
[-0, +1, m] 

void lua_pushcfunction (lua_State *L, lua_CFunction f);
Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type function that, when called, invokes the corresponding C function. 

Any function to be registered in Lua must follow the correct protocol to receive its parameters and return its results (see lua_CFunction). 

lua_pushcfunction is defined as a macro: 

     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)

--------------------------------------------------------------------------------
（注：TODO）

lua_pushcfunction
[-0, +1, m] 

void lua_pushcfunction (lua_State *L, lua_CFunction f);
将C函数压栈。本函数接收一个指向C函数的指针并把一个function类型的Lua值压栈，当这种类型的函数被调用时，会调用相应的C函数。 

任何要在Lua中注册的函数必须遵循正确的协议，以接收其参数并返回其结果（见lua_CFunction）。 

lua_pushcfunction被定义为宏： 

     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)

--------------------------------------------------------------------------------

lua_pushfstring
[-0, +1, m] 

const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the C function sprintf, but has some important differences: 

You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection). 
The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '%%' (inserts a '%' in the string), '%s' (inserts a zero-terminated string, with no size restrictions), '%f' (inserts a lua_Number), '%p' (inserts a pointer as a hexadecimal numeral), '%d' (inserts an int), and '%c' (inserts an int as a character). 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushfstring
[-0, +1, m] 

const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
将格式化的字符串压栈并返回指向它的指针。它与C函数sprintf类似，但也有一些重要的区别： 

你不需要为结果分配空间：结果是Lua字符串且Lua会照看内存分配（以及通过垃圾收集解除分配）。 
转换说明符非常的有限。没有标记、宽度或精度。转换说明符只能是'%%' （在字符串中插入一个'%'），'%s' （插入一个以0结尾的字符串，没有尺寸限制），'%f' （插入一个lua_Number），'%p' （插入一个指针作为十六进制数），'%d' （插入一个int），以及'%c' （插入一个int作为字符）。 


--------------------------------------------------------------------------------

lua_pushinteger
[-0, +1, -] 

void lua_pushinteger (lua_State *L, lua_Integer n);
Pushes a number with value n onto the stack. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushinteger
[-0, +1, -] 

void lua_pushinteger (lua_State *L, lua_Integer n);
将一个值为n的数字压栈。 

--------------------------------------------------------------------------------

lua_pushlightuserdata
[-0, +1, -] 

void lua_pushlightuserdata (lua_State *L, void *p);
Pushes a light userdata onto the stack. 

Userdata represent C values in Lua. A light userdata represents a pointer. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to "any" light userdata with the same C address. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushlightuserdata
[-0, +1, -] 

void lua_pushlightuserdata (lua_State *L, void *p);
将轻型用户数据压栈。 

在Lua中用户数据表示C值。轻型用户数据表示一个指针。它是个值（就像数字）：你不用创建它，它没有单独的元表，而且它不会被回收（如同从不被创建）。带有相同的C地址的轻型用户数据相等。 


--------------------------------------------------------------------------------

lua_pushliteral
[-0, +1, m] 

void lua_pushliteral (lua_State *L, const char *s);
This macro is equivalent to lua_pushlstring, but can be used only when s is a literal string. In these cases, it automatically provides the string length. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushliteral
[-0, +1, m] 

void lua_pushliteral (lua_State *L, const char *s);
本宏等价于lua_pushlstring，但是只能当s是字面字符串时使用。在这些情况下，它自动地提供字符串长度。 

--------------------------------------------------------------------------------

lua_pushlstring
[-0, +1, m] 

void lua_pushlstring (lua_State *L, const char *s, size_t len);
Pushes the string pointed to by s with size len onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at s can be freed or reused immediately after the function returns. The string can contain embedded zeros. 

--------------------------------------------------------------------------------
（注：TODO）

lua_pushlstring
[-0, +1, m] 

void lua_pushlstring (lua_State *L, const char *s, size_t len);
将s指向的尺寸为len的字符串压栈。Lua制造（或重用）给定字符串的内部拷贝，所以函数返回后s的内存立刻可被释放或重用。字符串可含有内嵌的0。 


--------------------------------------------------------------------------------

lua_pushnil
[-0, +1, -] 

void lua_pushnil (lua_State *L);
Pushes a nil value onto the stack. 

--------------------------------------------------------------------------------

lua_pushnil
[-0, +1, -] 

void lua_pushnil (lua_State *L);
压入一个空值进堆栈。 

--------------------------------------------------------------------------------

lua_pushnumber
[-0, +1, -] 

void lua_pushnumber (lua_State *L, lua_Number n);
Pushes a number with value n onto the stack. 

--------------------------------------------------------------------------------

lua_pushnumber
[-0, +1, -] 

void lua_pushnumber (lua_State *L, lua_Number n);
压入一个拥有值n的数字进堆栈。

--------------------------------------------------------------------------------

lua_pushstring
[-0, +1, m] 

void lua_pushstring (lua_State *L, const char *s);
Pushes the zero-terminated string pointed to by s onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at s can be freed or reused immediately after the function returns. The string cannot contain embedded zeros; it is assumed to end at the first zero. 


--------------------------------------------------------------------------------

lua_pushstring
[-0, +1, m] 

void lua_pushstring (lua_State *L, const char *s);
压入一个s指向的零结束字符串进堆栈。
Lua制造（或重用）所给字符串的一个内部拷贝，所以s指向的内存可以在函数返回后立刻被释放或重用。
这个字符串不可以包含内嵌零；假设第一个零为结束。

--------------------------------------------------------------------------------

lua_pushthread
[-0, +1, -] 

int lua_pushthread (lua_State *L);
Pushes the thread represented by L onto the stack. Returns 1 if this thread is the main thread of its state. 


--------------------------------------------------------------------------------
lua_pushthread
[-0, +1, -] 

int lua_pushthread (lua_State *L);
把L代表的线程压入栈中。
如果这个线程是状态的主线程则返回1。

--------------------------------------------------------------------------------

lua_pushvalue
[-0, +1, -] 

void lua_pushvalue (lua_State *L, int index);
Pushes a copy of the element at the given valid index onto the stack. 
--------------------------------------------------------------------------------

lua_pushvalue
[-0, +1, -] 

void lua_pushvalue (lua_State *L, int index);
把所给合法index处的元素的拷贝压入栈内。


--------------------------------------------------------------------------------

lua_pushvfstring
[-0, +1, m] 

const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);
Equivalent to lua_pushfstring, except that it receives a va_list instead of a variable number of arguments. 


--------------------------------------------------------------------------------

lua_pushvfstring
[-0, +1, m] 

const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);
等效于lua_pushfstring，除了接收一个va_list以代替参数个数。

--------------------------------------------------------------------------------

lua_rawequal
[-0, +0, -] 

int lua_rawequal (lua_State *L, int index1, int index2);
Returns 1 if the two values in acceptable indices index1 and index2 are primitively equal (that is, without calling metamethods). Otherwise returns 0. Also returns 0 if any of the indices are non valid. 

--------------------------------------------------------------------------------

lua_rawequal
[-0, +0, -] 

int lua_rawequal (lua_State *L, int index1, int index2);
如果两个所接收的索引index1和index2处的值原生相等（即不调用元方法），则返回1。
否则，返回0。
如果任意索引不合法，也返回0。

--------------------------------------------------------------------------------

lua_rawget
[-1, +1, -] 

void lua_rawget (lua_State *L, int index);
Similar to lua_gettable, but does a raw access (i.e., without metamethods). 

--------------------------------------------------------------------------------

lua_rawget
[-1, +1, -] 

void lua_rawget (lua_State *L, int index);
类似于lua_gettable，但执行原生访问(例如，没有元方法） 

--------------------------------------------------------------------------------

lua_rawgeti
[-0, +1, -] 

void lua_rawgeti (lua_State *L, int index, int n);
Pushes onto the stack the value t[n], where t is the value at the given valid index. The access is raw; that is, it does not invoke metamethods. 


--------------------------------------------------------------------------------

lua_rawgeti
[-0, +1, -] 

void lua_rawgeti (lua_State *L, int index, int n);
把t[n]的值压入栈中，其中t是所给合法Index处的值。
访问是原生的，不执行元方法

--------------------------------------------------------------------------------

lua_rawset
[-2, +0, m] 

void lua_rawset (lua_State *L, int index);
Similar to lua_settable, but does a raw assignment (i.e., without metamethods). 

--------------------------------------------------------------------------------
（注：TODO）

lua_rawset
[-2, +0, m] 

void lua_rawset (lua_State *L, int index);
类似lua_settable，但是执行一次原生赋值（也就是不用元方法）。 


--------------------------------------------------------------------------------

lua_rawseti
[-1, +0, m] 

void lua_rawseti (lua_State *L, int index, int n);
Does the equivalent of t[n] = v, where t is the value at the given valid index and v is the value at the top of the stack. 

This function pops the value from the stack. The assignment is raw; that is, it does not invoke metamethods. 

--------------------------------------------------------------------------------
（注：TODO）

lua_rawseti
[-1, +0, m] 

void lua_rawseti (lua_State *L, int index, int n);
执行t[n] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值。 

本函数将值出栈。赋值是原生的；即不调用元方法。 


--------------------------------------------------------------------------------

lua_Reader
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);
The reader function used by lua_load. Every time it needs another piece of the chunk, lua_load calls the reader, passing along its data parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set size to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return NULL or set size to zero. The reader function may return pieces of any size greater than zero. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Reader
typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);
被lua_load使用的读取器函数。每次需要单元的另一段时，lua_load沿着它的data参数调用读取器。读取器必须返回一个的内存块的指针，其中含有单元的新代码段，并且设置size为块尺寸。块必须一直存在直到再次调用读取器函数。读取器必须返回NULL或设置size为0来指示单元结束。读取器函数可能返回大于0的任何尺寸的代码段。 


--------------------------------------------------------------------------------

lua_register
[-0, +0, e] 

void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);
Sets the C function f as the new value of global name. It is defined as a macro: 

     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))

--------------------------------------------------------------------------------
（注：TODO）

lua_register
[-0, +0, e] 

void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);
设置C函数f为全局变量name的新值。它被定义为宏： 

     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))

--------------------------------------------------------------------------------

lua_remove
[-1, +0, -] 

void lua_remove (lua_State *L, int index);
Removes the element at the given valid index, shifting down the elements above this index to fill the gap. Cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position. 

--------------------------------------------------------------------------------
（注：TODO）

lua_remove
[-1, +0, -] 

void lua_remove (lua_State *L, int index);
移除给定的有效索引处的元素，并将该索引上面的元素下移来填充空隙。不能用伪索引调用，因为伪索引不是真实的栈位置。 

--------------------------------------------------------------------------------

lua_replace
[-1, +0, -] 

void lua_replace (lua_State *L, int index);
Moves the top element into the given position (and pops it), without shifting any element (therefore replacing the value at the given position). 

--------------------------------------------------------------------------------
（注：TODO）

lua_replace
[-1, +0, -] 

void lua_replace (lua_State *L, int index);
将栈顶元素移动到给定的索引中（并弹出它），不会移动任何元素（因此替换给定位置的值）。 


--------------------------------------------------------------------------------

lua_resume
[-?, +?, -] 

int lua_resume (lua_State *L, int narg);
Starts and resumes a coroutine in a given thread. 

To start a coroutine, you first create a new thread (see lua_newthread); then you push onto its stack the main function plus any arguments; then you call lua_resume, with narg being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to lua_yield, or all values returned by the body function. lua_resume returns LUA_YIELD if the coroutine yields, 0 if the coroutine finishes its execution without errors, or an error code in case of errors (see lua_pcall). In case of errors, the stack is not unwound, so you can use the debug API over it. The error message is on the top of the stack. To restart a coroutine, you put on its stack only the values to be passed as results from yield, and then call lua_resume. 

--------------------------------------------------------------------------------
（注：TODO）

lua_resume
[-?, +?, -] 

int lua_resume (lua_State *L, int narg);
启动和恢复给定线程中的一个协程。 

要启动一个协程，首先创建线程（见lua_newthread）；接着将主函数以及任何参数压到它的栈中；然后用narg指定参数个数来调用lua_resume。当协程挂起或运行完成时该调用返回。当它返回时，栈中含有lua_yield传入的所有值，或主体函数返回的所有值。如果协程中断则lua_resume返回LUA_YIELD，如果运行无误结束则返回0，或者在发生错误时返回错误代码（见lua_pcall）。发生错误时，栈未被释放，所以可对它使用调试API。错误消息位于栈顶。要重新启动协程，你只需把要从yield传出的结果放到它的栈上，然后调用lua_resume。 

--------------------------------------------------------------------------------

lua_setallocf
[-0, +0, -] 

void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
Changes the allocator function of a given state to f with user data ud. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setallocf
[-0, +0, -] 

void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
把给定状态机的分配器函数换成带用户数据ud的f。 


--------------------------------------------------------------------------------

lua_setfenv
[-1, +0, -] 

int lua_setfenv (lua_State *L, int index);
Pops a table from the stack and sets it as the new environment for the value at the given index. If the value at the given index is neither a function nor a thread nor a userdata, lua_setfenv returns 0. Otherwise it returns 1. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setfenv
[-1, +0, -] 

int lua_setfenv (lua_State *L, int index);
从栈中弹出一个表并把它设为给定索引处的值的新环境。如果给定索引处的值既不是函数又不是线程也不是用户数据，lua_setfenv返回0。否则返回1。 


--------------------------------------------------------------------------------

lua_setfield
[-1, +0, e] 

void lua_setfield (lua_State *L, int index, const char *k);
Does the equivalent to t[k] = v, where t is the value at the given valid index and v is the value at the top of the stack. 

This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the "newindex" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_setfield
[-1, +0, e] 

void lua_setfield (lua_State *L, int index, const char *k);
执行t[k] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值。 

本函数从栈中弹出值。同Lua中一样，本函数可能触发“newindex”事件的元方法（见§2.8）。 


--------------------------------------------------------------------------------

lua_setglobal
[-1, +0, e] 

void lua_setglobal (lua_State *L, const char *name);
Pops a value from the stack and sets it as the new value of global name. It is defined as a macro: 

     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)

--------------------------------------------------------------------------------
（注：TODO）

lua_setglobal
[-1, +0, e] 

void lua_setglobal (lua_State *L, const char *name);
从栈中弹出一个值并将其设为全局变量name的新值。它被定义为宏： 

     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)

--------------------------------------------------------------------------------

lua_setmetatable
[-1, +0, -] 

int lua_setmetatable (lua_State *L, int index);
Pops a table from the stack and sets it as the new metatable for the value at the given acceptable index. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setmetatable
[-1, +0, -] 

int lua_setmetatable (lua_State *L, int index);
从栈中弹出一个表并将其设为给定的认可的索引处的值的新元表。 


--------------------------------------------------------------------------------

lua_settable
[-2, +0, e] 

void lua_settable (lua_State *L, int index);
Does the equivalent to t[k] = v, where t is the value at the given valid index, v is the value at the top of the stack, and k is the value just below the top. 

This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the "newindex" event (see §2.8). 

--------------------------------------------------------------------------------
（注：TODO）

lua_settable
[-2, +0, e] 

void lua_settable (lua_State *L, int index);
执行t[k] = v的等价操作，其中t是给定的有效索引处的值，v是栈顶的值，k正好是栈顶下面的值。 

本函数将键和值都弹出栈。同Lua中一样，本函数可能触发“newindex”事件的元方法（见§2.8）。 


--------------------------------------------------------------------------------

lua_settop
[-?, +?, -] 

void lua_settop (lua_State *L, int index);
Accepts any acceptable index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with nil. If index is 0, then all stack elements are removed. 

--------------------------------------------------------------------------------

lua_settop
[-?, +?, -] 

void lua_settop (lua_State *L, int index);
接受任意可接受的索引，或者0，把栈顶设置在此索引上。
如果新的栈顶大于原有的，那么新创建的元素被填充为空。
如果索引为0，那么所有堆栈元素都会被删除。 

--------------------------------------------------------------------------------

lua_State
typedef struct lua_State lua_State;
Opaque structure that keeps the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is kept in this structure. 

A pointer to this state must be passed as the first argument to every function in the library, except to lua_newstate, which creates a Lua state from scratch. 

--------------------------------------------------------------------------------
lua_State
typedef struct lua_State lua_State;

保存整个Lua解析器状态（机）的不透明的结构。
Lua库（注：这里应该指C API）是完全可重入的：它没有全局变量。
关于状态的所有信息被保存在这个结构中。
指向这种状态的指针必须作为库里每一个库函数的第一个参数传递，除了从最开始创建一个Lua状态的lua_newstate以外。

--------------------------------------------------------------------------------

lua_status
[-0, +0, -] 

int lua_status (lua_State *L);
Returns the status of the thread L. 

The status can be 0 for a normal thread, an error code if the thread finished its execution with an error, or LUA_YIELD if the thread is suspended. 


--------------------------------------------------------------------------------

lua_status
[-0, +0, -] 

int lua_status (lua_State *L);
返回线程L的状态值。
线程正常时状态值为0，线程遇到错误而结束它的执行则返回一个错误码，线程挂起（暂停）则返回LUA_YIELD。

--------------------------------------------------------------------------------

lua_toboolean
[-0, +0, -] 

int lua_toboolean (lua_State *L, int index);
Converts the Lua value at the given acceptable index to a C boolean value (0 or 1). Like all tests in Lua, lua_toboolean returns 1 for any Lua value different from false and nil; otherwise it returns 0. It also returns 0 when called with a non-valid index. (If you want to accept only actual boolean values, use lua_isboolean to test the value's type.) 

--------------------------------------------------------------------------------

lua_toboolean
[-0, +0, -] 

int lua_toboolean (lua_State *L, int index);
把所给可接受的索引处的Lua值转换为C的布尔值(0或1)。
好像Lua的所有测试那样，对于任何不是false和nil的值lua_toboolean返回1；否则返回0。
它在用非法索引调用时也返回0。
（如果你只想接收实际的布尔值，使用lua_isboolean来检查值类型）

--------------------------------------------------------------------------------

lua_tocfunction
[-0, +0, -] 

lua_CFunction lua_tocfunction (lua_State *L, int index);
Converts a value at the given acceptable index to a C function. That value must be a C function; otherwise, returns NULL. 


--------------------------------------------------------------------------------

lua_tocfunction
[-0, +0, -] 

lua_CFunction lua_tocfunction (lua_State *L, int index);
把所给可接受索引处的值转换为C函数。
那个值必须是C函数，否则返回NULL。


--------------------------------------------------------------------------------

lua_tointeger
[-0, +0, -] 

lua_Integer lua_tointeger (lua_State *L, int index);
Converts the Lua value at the given acceptable index to the signed integral type lua_Integer. The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tointeger returns 0. 

If the number is not an integer, it is truncated in some non-specified way. 

--------------------------------------------------------------------------------
lua_tointeger
[-0, +0, -] 

lua_Integer lua_tointeger (lua_State *L, int index);
把所给可接受索引处的值转换为带符号的整型lua_Integer。
Lua值必须是一个数或者可转为数的字符串（参考§2.2.1），否则，lua_tointeger返回0。
如果数不是整数，会以不确定的方式被剪切。

--------------------------------------------------------------------------------

lua_tolstring
[-0, +0, m] 

const char *lua_tolstring (lua_State *L, int index, size_t *len);
Converts the Lua value at the given acceptable index to a C string. If len is not NULL, it also sets *len with the string length. The Lua value must be a string or a number; otherwise, the function returns NULL. If the value is a number, then lua_tolstring also changes the actual value in the stack to a string. (This change confuses lua_next when lua_tolstring is applied to keys during a table traversal.) 

lua_tolstring returns a fully aligned pointer to a string inside the Lua state. This string always has a zero ('\0') after its last character (as in C), but can contain other zeros in its body. Because Lua has garbage collection, there is no guarantee that the pointer returned by lua_tolstring will be valid after the corresponding value is removed from the stack. 

--------------------------------------------------------------------------------

lua_tolstring
[-0, +0, m] 

const char *lua_tolstring (lua_State *L, int index, size_t *len);
把所给可接受索引处的值转换为C的字符串。
如果len不是NULL，也可以设置*len为字符串长度。
Lua值不许是一个字符串或数。否则，这个函数返回NULL。
如果值是数，那么lua_tolstring还会改变堆栈的实际值为字符串。
（当lua_tolstring应用到表遍历的键中，这种改变会混淆lua_next。）
lua_tolstring返回一个完全对齐的指向Lua状态内部的字符串的指针。
因为Lua有垃圾回收，所以不保证lua_tolstring所返回的指针在相应值从堆栈中删除后仍合法。

--------------------------------------------------------------------------------

lua_tonumber
[-0, +0, -] 

lua_Number lua_tonumber (lua_State *L, int index);
Converts the Lua value at the given acceptable index to the C type lua_Number (see lua_Number). The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tonumber returns 0. 


--------------------------------------------------------------------------------

lua_tonumber
[-0, +0, -] 

lua_Number lua_tonumber (lua_State *L, int index);
把所给可接受索引处的值转换为C类型lua_Number（参考lua_Number）。
Lua值必须为一个数或可以转换为数的字符串（参考§2.2.1）；否则，lua_tonumber返回0。

--------------------------------------------------------------------------------

lua_topointer
[-0, +0, -] 

const void *lua_topointer (lua_State *L, int index);
Converts the value at the given acceptable index to a generic C pointer (void*). The value can be a userdata, a table, a thread, or a function; otherwise, lua_topointer returns NULL. Different objects will give different pointers. There is no way to convert the pointer back to its original value. 

Typically this function is used only for debug information. 

--------------------------------------------------------------------------------

lua_topointer
[-0, +0, -] 

const void *lua_topointer (lua_State *L, int index);
把所给可接受索引处的值转换为泛型的C指针（void*）。
这个值可以是用户定义数据，表，线程，或者是函数；否则，lua_topointer返回NULL。
不同的对象会给出不同的指针。
没有方法可以把指针转换回它原有值。
特别地这个函数仅用于调试信息。

--------------------------------------------------------------------------------

lua_tostring
[-0, +0, m] 

const char *lua_tostring (lua_State *L, int index);
Equivalent to lua_tolstring with len equal to NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_tostring
[-0, +0, m] 

const char *lua_tostring (lua_State *L, int index);
等价于len等于NULL时的lua_tolstring。 


--------------------------------------------------------------------------------

lua_tothread
[-0, +0, -] 

lua_State *lua_tothread (lua_State *L, int index);
Converts the value at the given acceptable index to a Lua thread (represented as lua_State*). This value must be a thread; otherwise, the function returns NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_tothread
[-0, +0, -] 

lua_State *lua_tothread (lua_State *L, int index);
把给定的认可的索引处的值转换为Lua线程（用lua_State*表示）。该值必须为线程；否则，本函数返回NULL。 


--------------------------------------------------------------------------------

lua_touserdata
[-0, +0, -] 

void *lua_touserdata (lua_State *L, int index);
If the value at the given acceptable index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns NULL. 

--------------------------------------------------------------------------------
（注：TODO）

lua_touserdata
[-0, +0, -] 

void *lua_touserdata (lua_State *L, int index);
如果给定的认可的索引处的值是完整的用户数据，则返回其块地址。如果是轻型用户数据，返回其指针。否则返回NULL。 


--------------------------------------------------------------------------------

lua_type
[-0, +0, -] 

int lua_type (lua_State *L, int index);
Returns the type of the value in the given acceptable index, or LUA_TNONE for a non-valid index (that is, an index to an "empty" stack position). The types returned by lua_type are coded by the following constants defined in lua.h: LUA_TNIL, LUA_TNUMBER, LUA_TBOOLEAN, LUA_TSTRING, LUA_TTABLE, LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD, and LUA_TLIGHTUSERDATA. 

--------------------------------------------------------------------------------
（注：TODO）

lua_type
[-0, +0, -] 

int lua_type (lua_State *L, int index);
返回给定的认可的索引处的值的类型，或者对不合法的索引返回LUA_TNONE（即指向“空”栈位置的索引）。lua_type返回的类型在lua.h中定义，被编码为下面的常量： LUA_TNIL、LUA_TNUMBER、LUA_TBOOLEAN、LUA_TSTRING、LUA_TTABLE、LUA_TFUNCTION、LUA_TUSERDATA、LUA_TTHREAD和LUA_TLIGHTUSERDATA。 


--------------------------------------------------------------------------------

lua_typename
[-0, +0, -] 

const char *lua_typename  (lua_State *L, int tp);
Returns the name of the type encoded by the value tp, which must be one the values returned by lua_type. 

--------------------------------------------------------------------------------
（注：TODO）

lua_typename
[-0, +0, -] 

const char *lua_typename  (lua_State *L, int tp);
返回由值tp编码的类型名，tp必须是lua_type的返回值的其中一个。 


--------------------------------------------------------------------------------

lua_Writer
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);
The type of the writer function used by lua_dump. Every time it produces another piece of chunk, lua_dump calls the writer, passing along the buffer to be written (p), its size (sz), and the data parameter supplied to lua_dump. 

The writer returns an error code: 0 means no errors; any other value means an error and stops lua_dump from calling the writer again. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Writer
typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);
由lua_dump使用的记录器函数的类型。lua_dump沿着要被写入的缓冲区（p）调用本函数，同时传入缓冲区尺寸（sz）和提供给lua_dump的data参数。每次调用会产生单元的另一段代码。 

记录器返回错误代码：0表示没错误；任何其他值表示错误并阻止lua_dump再次调用记录器。 

--------------------------------------------------------------------------------

lua_xmove
[-?, +?, -] 

void lua_xmove (lua_State *from, lua_State *to, int n);
Exchange values between different threads of the same global state. 

This function pops n values from the stack from, and pushes them onto the stack to. 

--------------------------------------------------------------------------------

lua_xmove
[-?, +?, -] 

void lua_xmove (lua_State *from, lua_State *to, int n);
交换相同全局状态中不同线程的值。
这个函数从堆栈from中弹出n个值，然后把它们压入堆栈to。

--------------------------------------------------------------------------------

lua_yield
[-?, +?, -] 

int lua_yield  (lua_State *L, int nresults);
Yields a coroutine. 

This function should only be called as the return expression of a C function, as follows: 

     return lua_yield (L, nresults);

When a C function calls lua_yield in that way, the running coroutine suspends its execution, and the call to lua_resume that started this coroutine returns. The parameter nresults is the number of values from the stack that are passed as results to lua_resume. 


--------------------------------------------------------------------------------

lua_yield
[-?, +?, -] 

int lua_yield  (lua_State *L, int nresults);
挂起一个协程 
这个函数应该仅在C函数return表达式中使用，如下：
return lua_yield (L, nresults);
当一个C函数像那样调用lua_yield，运行的协程暂停它的执行，并且在使此协程重新开始的lua_resume调用处返回。
参数nresults是堆栈中传递给lua_resume结果的值个数。














3.8 - The Debug Interface
Lua has no built-in debugging facilities. Instead, it offers a special interface by means of functions and hooks. This interface allows the construction of different kinds of debuggers, profilers, and other tools that need "inside information" from the interpreter. 

3.8 - 调试界面
Lua没有内置的调试工具。
取而代之，它通过函数和钩子提供一个特殊的界面。
这个界面兼容不同种类的调试器，性能剖析工具，以及其它需要从及解析器内部“内幕信息”的工具的结构。

--------------------------------------------------------------------------------

lua_Debug
typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) number of upvalues */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  other fields
} lua_Debug;
A structure used to carry different pieces of information about an active function. lua_getstack fills only the private part of this structure, for later use. To fill the other fields of lua_Debug with useful information, call lua_getinfo. 

The fields of lua_Debug have the following meaning: 

source: If the function was defined in a string, then source is that string. If the function was defined in a file, then source starts with a '@' followed by the file name. 
short_src: a "printable" version of source, to be used in error messages. 
linedefined: the line number where the definition of the function starts. 
lastlinedefined: the line number where the definition of the function ends. 
what: the string "Lua" if the function is a Lua function, "C" if it is a C function, "main" if it is the main part of a chunk, and "tail" if it was a function that did a tail call. In the latter case, Lua has no other information about the function. 
currentline: the current line where the given function is executing. When no line information is available, currentline is set to -1. 
name: a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of multiple global variables, while others can be stored only in a table field. The lua_getinfo function checks how the function was called to find a suitable name. If it cannot find a name, then name is set to NULL. 
namewhat: explains the name field. The value of namewhat can be "global", "local", "method", "field", "upvalue", or "" (the empty string), according to how the function was called. (Lua uses the empty string when no other option seems to apply.) 
nups: the number of upvalues of the function. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Debug
typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) upvalue的数量 */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 专用部分 */
  其他字段
} lua_Debug;
用于持有关于活动函数的信息的不同事项的结构。lua_getstack只填充本结构的专用部分，留作后用。要用有用的信息填充lua_Debug的其他字段，调用lua_getinfo。 

lua_Debug的字段具有下面的含义： 

source: 如果函数在字符串中定义，则source就是那个字符串。如果函数在文件中定义，则source以‘@’开头后跟文件名。 
short_src: 一个source的“可打印”版本，将用于错误消息中。 
linedefined: 函数定义开始的行号。 
lastlinedefined: 函数定义结束的行号。 
what: 如果函数是Lua函数则为字符串"Lua"，如果是C函数则为"C"，如果是单元的主体部分则为"main"，并且如果是执行了尾调用的函数则为 "tail"。最后一种情况，Lua没有关于函数的其他信息。 
currentline: 给定函数正执行的当前行。当没有行信息可用时，currentline被设为-1。 
name: 给定函数的合适的名字。因为Lua函数是第一类值，所以它们没有固定的名字：一些函数可为多个全局变量的值，然而其他的可只存储于一个表字段中。函数lua_getinfo检查函数是如何被调用的以找到合适的名字。如果找不到，则name被设为NULL。 
namewhat: 解释name字段。依据函数被如何调用，namewhat的值可为"global"、"local"、"method"、"field"、"upvalue"或""（空字符串）。（当看似没有其他选项可用时Lua使用空串。） 
nups: 函数的upvalue的数量。 


--------------------------------------------------------------------------------

lua_gethook
[-0, +0, -] 

lua_Hook lua_gethook (lua_State *L);
Returns the current hook function. 

--------------------------------------------------------------------------------

lua_gethook
[-0, +0, -] 

lua_Hook lua_gethook (lua_State *L);
返回当前钩子函数。 

--------------------------------------------------------------------------------

lua_gethookcount
[-0, +0, -] 

int lua_gethookcount (lua_State *L);
Returns the current hook count. 

--------------------------------------------------------------------------------

lua_gethookcount
[-0, +0, -] 

int lua_gethookcount (lua_State *L);
返回当前钩子个数

--------------------------------------------------------------------------------

lua_gethookmask
[-0, +0, -] 

int lua_gethookmask (lua_State *L);
Returns the current hook mask. 


--------------------------------------------------------------------------------

lua_gethookmask
[-0, +0, -] 

int lua_gethookmask (lua_State *L);
返回当前钩子掩码。 

--------------------------------------------------------------------------------

lua_getinfo
[-(0|1), +(0|1|2), m] 

int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
Returns information about a specific function or function invocation. 

To get information about a function invocation, the parameter ar must be a valid activation record that was filled by a previous call to lua_getstack or given as argument to a hook (see lua_Hook). 

To get information about a function you push it onto the stack and start the what string with the character '>'. (In that case, lua_getinfo pops the function in the top of the stack.) For instance, to know in which line a function f was defined, you can write the following code: 

     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* get global 'f' */
     lua_getinfo(L, ">S", &ar);
     printf("%d\n", ar.linedefined);

Each character in the string what selects some fields of the structure ar to be filled or a value to be pushed on the stack: 

'n': fills in the field name and namewhat; 
'S': fills in the fields source, short_src, linedefined, lastlinedefined, and what; 
'l': fills in the field currentline; 
'u': fills in the field nups; 
'f': pushes onto the stack the function that is running at the given level; 
'L': pushes onto the stack a table whose indices are the numbers of the lines that are valid on the function. (A valid line is a line with some associated code, that is, a line where you can put a break point. Non-valid lines include empty lines and comments.) 
This function returns 0 on error (for instance, an invalid option in what). 


--------------------------------------------------------------------------------

lua_getinfo
[-(0|1), +(0|1|2), m] 

int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
返回关于特定函数或函数调用的信息。
要获得函数调用的信息，参数ar必须是被前一个调用lua_getstack填充的合法的激活记录，或者是作为参数传给hook（参考lua_Hook）。
为了获得函数信息，你可以把它压入堆栈然后启动带字符'>'开头的字符串what。
（这种情况下，lua_getinfo会弹出栈顶的函数。）
例如，为了指导哪一行定义了函数f，你可以写如下代码：
lua_Debug ar;
lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* 获取全局'f' */
lua_getinfo(L, ">S", &ar);
printf("%d\n", ar.linedefined);
字符串what的每个字符选择了结构体ar要填充的域或者是压入堆栈的值：
'n': 填充域name和namewhat； 
'S': 填充域source, short_src, linedefined, lastlinedefined, 和what； 
'l': 填充域currentline； 
'u': 填充域nups；
'f': 把运行于所给层的函数压入栈顶； 
'L': 把一个索引是函数合法行号的表压入堆栈（一个合法行是带有关联代码的行，所以一行中可以放置一个断点。不合法的行包括空行和注释。）
这个函数在错误时返回0（例如，what的一个不合法选项）

--------------------------------------------------------------------------------

lua_getlocal
[-0, +(0|1), -] 

const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);
Gets information about a local variable of a given activation record. The parameter ar must be a valid activation record that was filled by a previous call to lua_getstack or given as argument to a hook (see lua_Hook). The index n selects which local variable to inspect (1 is the first parameter or active local variable, and so on, until the last active local variable). lua_getlocal pushes the variable's value onto the stack and returns its name. 

Variable names starting with '(' (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals). 

Returns NULL (and pushes nothing) when the index is greater than the number of active local variables. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getlocal
[-0, +(0|1), -] 

const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);
获得给定的活动记录的一个局部变量的信息。参数ar必须是有效的活动记录，它被之前的lua_getstack调用填充，或者作为hook的参数（见lua_Hook）。索引n选取要检阅哪个局部变量（1是第一个参数或活动的局部变量，以此类推，直到最后一个活动的局部变量）。lua_getlocal将变量的值压栈并返回其名字。 

‘(’（开圆括号）开头的变量表示内部变量（循环控制变量、临时变量和C函数局部变量）。 

当索引比活动的局部变量的数量大时返回NULL（且不压栈任何东西）。 


--------------------------------------------------------------------------------

lua_getstack
[-0, +0, -] 

int lua_getstack (lua_State *L, int level, lua_Debug *ar);
Get information about the interpreter runtime stack. 

This function fills parts of a lua_Debug structure with an identification of the activation record of the function executing at a given level. Level 0 is the current running function, whereas level n+1 is the function that has called level n. When there are no errors, lua_getstack returns 1; when called with a level greater than the stack depth, it returns 0. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getstack
[-0, +0, -] 

int lua_getstack (lua_State *L, int level, lua_Debug *ar);
得到关于解释器运行时的栈信息。 

本函数用执行于给定级别的函数的活动记录的标识符填充部分lua_Debug结构。0级是当前运行的函数，而n+1级是调用n级的函数。无错误时lua_getstack返回1；当以超过栈深度的级别调用时返回0。 


--------------------------------------------------------------------------------

lua_getupvalue
[-0, +(0|1), -] 

const char *lua_getupvalue (lua_State *L, int funcindex, int n);
Gets information about a closure's upvalue. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.) lua_getupvalue gets the index n of an upvalue, pushes the upvalue's value onto the stack, and returns its name. funcindex points to the closure in the stack. (Upvalues have no particular order, as they are active through the whole function. So, they are numbered in an arbitrary order.) 

Returns NULL (and pushes nothing) when the index is greater than the number of upvalues. For C functions, this function uses the empty string "" as a name for all upvalues. 

--------------------------------------------------------------------------------
（注：TODO）

lua_getupvalue
[-0, +(0|1), -] 

const char *lua_getupvalue (lua_State *L, int funcindex, int n);
得到闭包的一个upvalue的信息。（对于Lua函数，upvalue是函数用到因而被包含在其闭包内的外部局部变量。）lua_getupvalue得到索引n处的upvalue，将其值压栈并返回其名。funcindex指向栈中的闭包。（upvalue没有特定的顺序，因为它们在整个函数中从头至尾都是活动的，所以它们以任意顺序被编号。） 

当索引比upvalue的数量大时返回NULL（且不压栈任何东西）。对于C函数，本函数用空串""作为所有upvalue的名字。 

--------------------------------------------------------------------------------

lua_Hook
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
Type for debugging hook functions. 

Whenever a hook is called, its ar argument has its field event set to the specific event that triggered the hook. Lua identifies these events with the following constants: LUA_HOOKCALL, LUA_HOOKRET, LUA_HOOKTAILRET, LUA_HOOKLINE, and LUA_HOOKCOUNT. Moreover, for line events, the field currentline is also set. To get the value of any other field in ar, the hook must call lua_getinfo. For return events, event can be LUA_HOOKRET, the normal value, or LUA_HOOKTAILRET. In the latter case, Lua is simulating a return from a function that did a tail call; in this case, it is useless to call lua_getinfo. 

While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks. 

--------------------------------------------------------------------------------
（注：TODO）

lua_Hook
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
调试的hook函数类型。 

当hook被调用时，其ar参数将其字段event设为触发该hook的特定事件。Lua用下面的常量标识这些事件：LUA_HOOKCALL、LUA_HOOKRET、LUA_HOOKTAILRET、LUA_HOOKLINE和LUA_HOOKCOUNT。此外，对于行事件，也会设置字段currentline。要得到ar中其他字段的值，hook必须调用lua_getinfo。对于返回事件，event可以是普通值LUA_HOOKRET或LUA_HOOKTAILRET。对于后者，Lua将模拟从执行了尾调用的函数中的返回；这种情况下，调用lua_getinfo是无用的。 

当Lua运行hook时，它禁止其他的hook调用。因此，如果hook回调Lua来执行函数或单元，该次执行不带任何hook调用。 


--------------------------------------------------------------------------------

lua_sethook
[-0, +0, -] 

int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);
Sets the debugging hook function. 

Argument f is the hook function. mask specifies on which events the hook will be called: it is formed by a bitwise or of the constants LUA_MASKCALL, LUA_MASKRET, LUA_MASKLINE, and LUA_MASKCOUNT. The count argument is only meaningful when the mask includes LUA_MASKCOUNT. For each event, the hook is called as explained below: 

The call hook: is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments. 
The return hook: is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. You have no access to the values to be returned by the function. 
The line hook: is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.) 
The count hook: is called after the interpreter executes every count instructions. (This event only happens while Lua is executing a Lua function.) 
A hook is disabled by setting mask to zero. 

--------------------------------------------------------------------------------
（注：TODO）

lua_sethook
[-0, +0, -] 

int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);
设置调试的hook函数。 

参数f是hook函数。mask规定发生哪个事件时hook将被调用：它由常量LUA_MASKCALL、LUA_MASKRET、LUA_MASKLINE和LUA_MASKCOUNT按位或组成。只当掩码含有LUA_MASKCOUNT时，count参数才有意义。对于每个事件，hook如下面解释的那样被调用： 

call hook: 当解释器调用函数时被调用。hook在Lua刚进入新函数后、在函数得到其参数前被调用。 
return hook: 当解释器从函数返回时被调用。hook在Lua正要离开函数前被调用。你不能访问要被函数返回的值。 
line hook: 当解释器将要开始新行代码的执行或跳回到代码中（甚至是同一行）时被调用。（该事件只在Lua正执行Lua函数时发生。） 
count hook: 在解释器执行每count条指令后被调用。（该事件只在Lua正执行Lua函数时发生。） 
通过设定mask为0禁用hook。 


--------------------------------------------------------------------------------

lua_setlocal
[-(0|1), +0, -] 

const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);
Sets the value of a local variable of a given activation record. Parameters ar and n are as in lua_getlocal (see lua_getlocal). lua_setlocal assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack. 

Returns NULL (and pops nothing) when the index is greater than the number of active local variables. 

--------------------------------------------------------------------------------
（注：TODO）

lua_setlocal
[-(0|1), +0, -] 

const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);
设置给定的活动记录的一个局部变量的值。参数ar和n与lua_getlocal中一样（见lua_getlocal）。lua_setlocal把栈顶的值赋给变量并返回其名字。它也将值从栈中弹出。 

当索引超过活动的局部变量的数量时返回NULL（且不出栈任何东西）。 


--------------------------------------------------------------------------------

lua_setupvalue
[-(0|1), +0, -] 

const char *lua_setupvalue (lua_State *L, int funcindex, int n);
Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack. Parameters funcindex and n are as in the lua_getupvalue (see lua_getupvalue). 

Returns NULL (and pops nothing) when the index is greater than the number of upvalues. 


--------------------------------------------------------------------------------
（注：TODO）

lua_setupvalue
[-(0|1), +0, -] 

const char *lua_setupvalue (lua_State *L, int funcindex, int n);
设置闭包的upvalue的值。它把栈顶的值赋给upvalue并返回其名字。它也把值从栈中弹出。参数funcindex和n同lua_getupvalue中一样（见lua_getupvalue）。 

当索引超过upvalue的数量时返回NULL（且不出栈任何东西）。 







4 - The Auxiliary Library
The auxiliary library provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks. 

All functions from the auxiliary library are defined in header file lauxlib.h and have a prefix luaL_. 

All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with this API. 

Several functions in the auxiliary library are used to check C function arguments. Their names are always luaL_check* or luaL_opt*. All of these functions throw an error if the check is not satisfied. Because the error message is formatted for arguments (e.g., "bad argument #1"), you should not use these functions for other stack values. 


（注：TODO）
4 - 辅助库
辅助库为连接C和Lua提供若干便利的函数。基础API为C和Lua间的所有交互提供基本功能，而辅助库为一些通用任务提供高级功能。 

所有来自辅助库的函数在头文件lauxlib.h中定义并具有前缀luaL_。 

辅助库中的所有函数建立于基础API的顶层，所以该API做不了的它们也不提供。 

辅助库中的一些函数用于检查C函数的参数。它们的名字总是luaL_check*或luaL_opt*。如果未满足检查条件，所有这些函数会抛出错误。因为错误消息是为参数格式化的（例如“bad argument #1”），所以不能把这些函数用于其它栈值。 











4.1 - Functions and Types
Here we list all functions and types from the auxiliary library in alphabetical order. 


（注：TODO）
4.1 - 函数与类型
这儿我们以字母顺序列出来自辅助库的所有函数和类型。 


--------------------------------------------------------------------------------

luaL_addchar
[-0, +0, m] 

void luaL_addchar (luaL_Buffer *B, char c);
Adds the character c to the buffer B (see luaL_Buffer). 

--------------------------------------------------------------------------------

luaL_addchar
[-0, +0, m] 

void luaL_addchar (luaL_Buffer *B, char c);
把字符c加入缓冲区B（参考luaL_Buffer）。

--------------------------------------------------------------------------------

luaL_addlstring
[-0, +0, m] 

void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
Adds the string pointed to by s with length l to the buffer B (see luaL_Buffer). The string may contain embedded zeros. 


--------------------------------------------------------------------------------

luaL_addlstring
[-0, +0, m] 

void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
把指向s的长度l的字符串加入缓冲区B（参考luaL_Buffer）。
这个字符串可以包含嵌入的0。


--------------------------------------------------------------------------------

luaL_addsize
[-0, +0, m] 

void luaL_addsize (luaL_Buffer *B, size_t n);
Adds to the buffer B (see luaL_Buffer) a string of length n previously copied to the buffer area (see luaL_prepbuffer). 


--------------------------------------------------------------------------------

luaL_addsize
[-0, +0, m] 

void luaL_addsize (luaL_Buffer *B, size_t n);
把前一个复制到缓冲区（参考luaL_prepbuffer）的长度n的字符串加入缓冲B（参考luaL_Buffer）


--------------------------------------------------------------------------------

luaL_addstring
[-0, +0, m] 

void luaL_addstring (luaL_Buffer *B, const char *s);
Adds the zero-terminated string pointed to by s to the buffer B (see luaL_Buffer). The string may not contain embedded zeros. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_addstring
[-0, +0, m] 

void luaL_addstring (luaL_Buffer *B, const char *s);
把s指向的0结尾的字符串添加到缓冲器B（见luaL_Buffer）。字符串不可包含内嵌的0。 



--------------------------------------------------------------------------------

luaL_addvalue
[-1, +0, m] 

void luaL_addvalue (luaL_Buffer *B);
Adds the value at the top of the stack to the buffer B (see luaL_Buffer). Pops the value. 

This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_addvalue
[-1, +0, m] 

void luaL_addvalue (luaL_Buffer *B);
把栈顶的值添加到缓冲器B（见luaL_Buffer）。弹出该值。 

这是仅有能（且必须）用栈上的一个额外元素调用的关于字符串缓冲器的函数，该元素是要被添加到缓冲器的值。 




--------------------------------------------------------------------------------

luaL_argcheck
[-0, +0, v] 

void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);
Checks whether cond is true. If not, raises an error with the following message, where func is retrieved from the call stack: 

     bad argument #<narg> to <func> (<extramsg>)

--------------------------------------------------------------------------------

luaL_argcheck
[-0, +0, v] 

void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);
检查条件是否为真。
如果不是，用下面的信息引发一个错误，其中func是从调用堆栈中重新取得。
bad argument #<narg> to <func> (<extramsg>)

--------------------------------------------------------------------------------

luaL_argerror
[-0, +0, v] 

int luaL_argerror (lua_State *L, int narg, const char *extramsg);
Raises an error with the following message, where func is retrieved from the call stack: 

     bad argument #<narg> to <func> (<extramsg>)

This function never returns, but it is an idiom to use it in C functions as return luaL_argerror(args). 

--------------------------------------------------------------------------------
（注：TODO）

luaL_argerror
[-0, +0, v] 

int luaL_argerror (lua_State *L, int narg, const char *extramsg);
抛出带下面的消息的错误，其中func是取自调用栈： 

     bad argument #<narg> to <func> (<extramsg>)

本函数决不返回，但是像return luaL_argerror(args)这样是用在C函数中的习惯用法。 


--------------------------------------------------------------------------------

luaL_Buffer
typedef struct luaL_Buffer luaL_Buffer;
Type for a string buffer. 

A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows: 

First you declare a variable b of type luaL_Buffer. 
Then you initialize it with a call luaL_buffinit(L, &b). 
Then you add string pieces to the buffer calling any of the luaL_add* functions. 
You finish by calling luaL_pushresult(&b). This call leaves the final string on the top of the stack. 
During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is luaL_addvalue.) After calling luaL_pushresult the stack is back to its level when the buffer was initialized, plus the final string on its top. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_Buffer
typedef struct luaL_Buffer luaL_Buffer;
字符串缓冲器类型。 

字符串缓冲器允许C代码逐段地构建Lua字符串。其使用模式如下： 

首先声明luaL_Buffer类型的变量b。 
接着调用luaL_buffinit(L, &b)初始化它。 
然后调用luaL_add*函数把字符串片断添加到缓冲器。 
通过调用luaL_pushresult(&b)结束。该调用把最终的字符串放在栈顶。 
在字符串缓冲器的常规操作期间，它占用的栈槽数量不固定。所以，使用缓冲器时，你不能假定知道栈顶在哪儿。只要用法是对称的，你就能在连续的对缓冲器操作的调用之间使用栈；就是说，当你调用缓冲器操作时，栈处于前一个缓冲器操作后立刻得到的水平。（该规则的唯一例外是luaL_addvalue。）调用luaL_pushresult之后，栈回到缓冲器被初始化时的水平，加上栈顶的最终字符串。 



--------------------------------------------------------------------------------

luaL_buffinit
[-0, +0, -] 

void luaL_buffinit (lua_State *L, luaL_Buffer *B);
Initializes a buffer B. This function does not allocate any space; the buffer must be declared as a variable (see luaL_Buffer). 

--------------------------------------------------------------------------------
（注：TODO）

luaL_buffinit
[-0, +0, -] 

void luaL_buffinit (lua_State *L, luaL_Buffer *B);
初始化缓冲器B。本函数不分配任何空间；缓冲器必须已被声明为变量（见luaL_Buffer）。 


--------------------------------------------------------------------------------

luaL_callmeta
[-0, +(0|1), e] 

int luaL_callmeta (lua_State *L, int obj, const char *e);
Calls a metamethod. 

If the object at index obj has a metatable and this metatable has a field e, this function calls this field and passes the object as its only argument. In this case this function returns 1 and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns 0 (without pushing any value on the stack). 

--------------------------------------------------------------------------------
（注：TODO）

luaL_callmeta
[-0, +(0|1), e] 

int luaL_callmeta (lua_State *L, int obj, const char *e);
调用一个元方法。 

如果索引obj处的对象具有元表且该元表具有字段e，本函数调用该字段并传入该对象为其唯一参数。这种情况下，本函数返回1并将该调用返回的值压栈。如果没有元表或没有元方法，本函数返回0（不将任何值压栈）。 


--------------------------------------------------------------------------------

luaL_checkany
[-0, +0, v] 

void luaL_checkany (lua_State *L, int narg);
Checks whether the function has an argument of any type (including nil) at position narg. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_checkany
[-0, +0, v] 

void luaL_checkany (lua_State *L, int narg);
检查函数是否在位置narg处有个任意类型（包括nil）的参数。 


--------------------------------------------------------------------------------

luaL_checkint
[-0, +0, v] 

int luaL_checkint (lua_State *L, int narg);
Checks whether the function argument narg is a number and returns this number cast to an int. 


--------------------------------------------------------------------------------

luaL_checkint
[-0, +0, v] 

int luaL_checkint (lua_State *L, int narg);
检查函数参数narg是否为一个数，并且把这个数转换为整数然后返回。

--------------------------------------------------------------------------------

luaL_checkinteger
[-0, +0, v] 

lua_Integer luaL_checkinteger (lua_State *L, int narg);
Checks whether the function argument narg is a number and returns this number cast to a lua_Integer. 

--------------------------------------------------------------------------------

luaL_checkinteger
[-0, +0, v] 

lua_Integer luaL_checkinteger (lua_State *L, int narg);
检查函数参数narg是否是一个数，并且把这个数转换为lua_Integer然后返回。


--------------------------------------------------------------------------------

luaL_checklong
[-0, +0, v] 

long luaL_checklong (lua_State *L, int narg);
Checks whether the function argument narg is a number and returns this number cast to a long. 

--------------------------------------------------------------------------------

luaL_checklong
[-0, +0, v] 

long luaL_checklong (lua_State *L, int narg);
检查函数参数narg是否是一个数，并且把这个数转换为长整型然后返回。


--------------------------------------------------------------------------------

luaL_checklstring
[-0, +0, v] 

const char *luaL_checklstring (lua_State *L, int narg, size_t *l);
Checks whether the function argument narg is a string and returns this string; if l is not NULL fills *l with the string's length. 

This function uses lua_tolstring to get its result, so all conversions and caveats of that function apply here. 

--------------------------------------------------------------------------------

luaL_checklstring
[-0, +0, v] 

const char *luaL_checklstring (lua_State *L, int narg, size_t *l);
检查函数参数narg是否是一个字符串，然后返回这个字符串；如果l不是NULL则填充*l为字符串的长度。
这个函数使用lua_tolstring获得结果，所以那个函数的所有转换和注意事项都适用于此。

--------------------------------------------------------------------------------

luaL_checknumber
[-0, +0, v] 

lua_Number luaL_checknumber (lua_State *L, int narg);
Checks whether the function argument narg is a number and returns this number. 

--------------------------------------------------------------------------------

luaL_checknumber
[-0, +0, v] 

lua_Number luaL_checknumber (lua_State *L, int narg);
检查函数参数narg是否是一个数，并且返回这个数。


--------------------------------------------------------------------------------

luaL_checkoption
[-0, +0, v] 

int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);
Checks whether the function argument narg is a string and searches for this string in the array lst (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found. 

If def is not NULL, the function uses def as a default value when there is no argument narg or if this argument is nil. 

This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.) 

--------------------------------------------------------------------------------

luaL_checkoption
[-0, +0, v] 

int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);
检查函数参数narg是否是一个字符串并且在数组lst中搜索这个字符串（必须是NULL结束）。
返回数组中所找到字符串的索引。
如果参数不是一个字符串或字符串找不到则引发错误。
如果def不是NULL，当没有narg参数或者这个参数为空时，这个函数使用def作为默认值
这个函数对匹配字符串为C枚举值时很有用。
（在Lua库中普遍的约定是使用字符串代替数字去选择选项）


--------------------------------------------------------------------------------

luaL_checkstack
[-0, +0, v] 

void luaL_checkstack (lua_State *L, int sz, const char *msg);
Grows the stack size to top + sz elements, raising an error if the stack cannot grow to that size. msg is an additional text to go into the error message. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_checkstack
[-0, +0, v] 

void luaL_checkstack (lua_State *L, int sz, const char *msg);
增长栈尺寸到top + sz个元素，如果不能增长到那个尺寸则引发错误。msg是加入错误消息的补充文本。 


--------------------------------------------------------------------------------

luaL_checkstring
[-0, +0, v] 

const char *luaL_checkstring (lua_State *L, int narg);
Checks whether the function argument narg is a string and returns this string. 

This function uses lua_tolstring to get its result, so all conversions and caveats of that function apply here. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_checkstring
[-0, +0, v] 

const char *luaL_checkstring (lua_State *L, int narg);
检查函数参数narg是否字符串并返回它。 

本函数用lua_tolstring取得其结果，所以那个函数的所有变换和警告也适用于此处。 


--------------------------------------------------------------------------------

luaL_checktype
[-0, +0, v] 

void luaL_checktype (lua_State *L, int narg, int t);
Checks whether the function argument narg has type t. See lua_type for the encoding of types for t. 


--------------------------------------------------------------------------------

luaL_checktype
[-0, +0, v] 

void luaL_checktype (lua_State *L, int narg, int t);
检查函数参数narg是否拥有类型t。
参考lua_type获得t的类型编码。

--------------------------------------------------------------------------------

luaL_checkudata
[-0, +0, v] 

void *luaL_checkudata (lua_State *L, int narg, const char *tname);
Checks whether the function argument narg is a userdata of the type tname (see luaL_newmetatable). 

--------------------------------------------------------------------------------

luaL_checkudata
[-0, +0, v] 

void *luaL_checkudata (lua_State *L, int narg, const char *tname);
检查函数参数narg是否是类型tname的用户定义类型（参考luaL_newmetatable）


--------------------------------------------------------------------------------

luaL_dofile
[-0, +?, m] 

int luaL_dofile (lua_State *L, const char *filename);
Loads and runs the given file. It is defined as the following macro: 

     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))

It returns 0 if there are no errors or 1 in case of errors. 

--------------------------------------------------------------------------------

luaL_dofile
[-0, +?, m] 

int luaL_dofile (lua_State *L, const char *filename);
加载并运行所给的文件，定义为如下宏
(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
如果没有错误则返回0，如果出错返回1。

--------------------------------------------------------------------------------

luaL_dostring
[-0, +?, m] 

int luaL_dostring (lua_State *L, const char *str);
Loads and runs the given string. It is defined as the following macro: 
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
It returns 0 if there are no errors or 1 in case of errors. 

--------------------------------------------------------------------------------

luaL_dostring
[-0, +?, m] 

int luaL_dostring (lua_State *L, const char *str);
加载并运行所给的字符串。定义为如下宏：
(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
如果没有错误则返回0，如果出错返回1。

--------------------------------------------------------------------------------

luaL_error
[-0, +0, v] 

int luaL_error (lua_State *L, const char *fmt, ...);
Raises an error. The error message format is given by fmt plus any extra arguments, following the same rules of lua_pushfstring. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available. 

This function never returns, but it is an idiom to use it in C functions as return luaL_error(args). 

--------------------------------------------------------------------------------

luaL_error
[-0, +0, v] 

int luaL_error (lua_State *L, const char *fmt, ...);
引发错误。
错误信息的格式由fmt指定，外加额外的参数，遵循与lua_pushfstring相同的规则。
它还会在信息的开头加上文件名和发生错误的行号，如果这类信息可用的话。
这个函数从不返回，但习惯在C函数内以return luaL_error(args)方式使用。

--------------------------------------------------------------------------------

luaL_getmetafield
[-0, +(0|1), m] 

int luaL_getmetafield (lua_State *L, int obj, const char *e);
Pushes onto the stack the field e from the metatable of the object at index obj. If the object does not have a metatable, or if the metatable does not have this field, returns 0 and pushes nothing. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_getmetafield
[-0, +(0|1), m] 

int luaL_getmetafield (lua_State *L, int obj, const char *e);
把来自索引obj处的对象的元表的字段e压栈。如果对象没有元表或其元表没有该字段，则返回0且不会压栈任何东西。 


--------------------------------------------------------------------------------

luaL_getmetatable
[-0, +1, -] 

void luaL_getmetatable (lua_State *L, const char *tname);
Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable). 

--------------------------------------------------------------------------------
（注：TODO）

luaL_getmetatable
[-0, +1, -] 

void luaL_getmetatable (lua_State *L, const char *tname);
把与注册表中的名字tname相关联的元表压栈。（见luaL_newmetatable）。 


--------------------------------------------------------------------------------

luaL_gsub
[-0, +1, m] 

const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);
Creates a copy of string s by replacing any occurrence of the string p with the string r. Pushes the resulting string on the stack and returns it. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_gsub
[-0, +1, m] 

const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);
通过把出现的任何字符串p替换为字符串r来创建字符串s的拷贝。把结果字符串压栈并返回它。 


--------------------------------------------------------------------------------

luaL_loadbuffer
[-0, +1, m] 

int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);
Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz. 

This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_loadbuffer
[-0, +1, m] 

int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);
载入缓冲器并作为一个Lua单元。本函数用lua_load来加载缓冲器中由buff指向且长度为sz的单元。 

本函数返回同lua_load一样的结果。name是单元名字，用于调试信息和错误消息。 


--------------------------------------------------------------------------------

luaL_loadfile
[-0, +1, m] 

int luaL_loadfile (lua_State *L, const char *filename);
Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #. 

This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file. 

As lua_load, this function only loads the chunk; it does not run it. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_loadfile
[-0, +1, m] 

int luaL_loadfile (lua_State *L, const char *filename);
载入文件作为一个Lua单元。本函数用lua_load来载入名为filename的文件中的单元。如果filename是NULL，则从标准输入载入。文件中的第一行如果以#开头则被忽略。 

本函数返回同lua_load一样的结果，除了有个额外的错误代码LUA_ERRFILE，用于不能打开/读取文件的情况。 

同lua_load一样，本函数只载入单元；不会运行它。 


--------------------------------------------------------------------------------

luaL_loadstring
[-0, +1, m] 

int luaL_loadstring (lua_State *L, const char *s);
Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s. 

This function returns the same results as lua_load. 

Also as lua_load, this function only loads the chunk; it does not run it. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_loadstring
[-0, +1, m] 

int luaL_loadstring (lua_State *L, const char *s);
载入字符串作为一个Lua单元。本函数用lua_load来载入以0结尾的字符串s中的单元。 

本函数返回同lua_load一样的结果。 

本函数只载入单元，这也同lua_load一样；不会运行它。 



--------------------------------------------------------------------------------

luaL_newmetatable
[-0, +1, m] 

int luaL_newmetatable (lua_State *L, const char *tname);
If the registry already has the key tname, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds it to the registry with key tname, and returns 1. 

In both cases pushes onto the stack the final value associated with tname in the registry. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_newmetatable
[-0, +1, m] 

int luaL_newmetatable (lua_State *L, const char *tname);
如果注册表已经有了键tname则返回0。否则，创建将用作用户数据的元表的新表，把它同键tname一起加入注册表，并且返回1。 

两种情况都把注册表中与tname相关联的最终值压栈。 


--------------------------------------------------------------------------------

luaL_newstate
[-0, +0, -] 

lua_State *luaL_newstate (void);
Creates a new Lua state. It calls lua_newstate with an allocator based on the standard C realloc function and then sets a panic function (see lua_atpanic) that prints an error message to the standard error output in case of fatal errors. 

Returns the new state, or NULL if there is a memory allocation error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_newstate
[-0, +0, -] 

lua_State *luaL_newstate (void);
创建新的Lua状态机。它用基于标准C的realloc函数的分配器调用lua_newstate，然后设置一个在发生重大错误时向标准错误输出打印一条错误消息的应急函数（见lua_atpanic）。 

返回新的状态机，如果发生内存分配错误则返回NULL。 


--------------------------------------------------------------------------------

luaL_openlibs
[-0, +0, m] 

void luaL_openlibs (lua_State *L);
Opens all standard Lua libraries into the given state. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_openlibs
[-0, +0, m] 

void luaL_openlibs (lua_State *L);
打开所有的标准Lua库到给定的状态机中。 


--------------------------------------------------------------------------------

luaL_optint
[-0, +0, v] 

int luaL_optint (lua_State *L, int narg, int d);
If the function argument narg is a number, returns this number cast to an int. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optint
[-0, +0, v] 

int luaL_optint (lua_State *L, int narg, int d);
如果函数参数narg是数字，则把该数字转型为int返回。如果该参数不存在或为nil则返回d。否则引发错误。 


--------------------------------------------------------------------------------

luaL_optinteger
[-0, +0, v] 

lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);
If the function argument narg is a number, returns this number cast to a lua_Integer. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optinteger
[-0, +0, v] 

lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);
如果函数参数narg是数字，则把该数字转型为lua_Integer返回。如果该参数不存在或为nil则返回d。否则引发错误。 

--------------------------------------------------------------------------------

luaL_optlong
[-0, +0, v] 

long luaL_optlong (lua_State *L, int narg, long d);
If the function argument narg is a number, returns this number cast to a long. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optlong
[-0, +0, v] 

long luaL_optlong (lua_State *L, int narg, long d);
如果函数参数narg是数字，则把该数字转型为long返回。如果该参数不存在或为nil则返回d。否则引发错误。 


--------------------------------------------------------------------------------

luaL_optlstring
[-0, +0, v] 

const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);
If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

If l is not NULL, fills the position *l with the results's length. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optlstring
[-0, +0, v] 

const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);
如果函数参数narg是字符串则返回它。如果该参数不存在或为nil则返回d。否则引发错误。 

如果l不为NULL，则用结果的长度填充位置*l。 



--------------------------------------------------------------------------------

luaL_optnumber
[-0, +0, v] 

lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);
If the function argument narg is a number, returns this number. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optnumber
[-0, +0, v] 

lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);
如果函数参数narg是数字则返回它。如果该参数不存在或为nil则返回d。否则引发错误。 


--------------------------------------------------------------------------------

luaL_optstring
[-0, +0, v] 

const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);
If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_optstring
[-0, +0, v] 

const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);
如果函数参数narg是字符串则返回它。如果该参数不存在或为nil则返回d。否则引发错误。 



--------------------------------------------------------------------------------

luaL_prepbuffer
[-0, +0, -] 

char *luaL_prepbuffer (luaL_Buffer *B);
Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see luaL_Buffer). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_prepbuffer
[-0, +0, -] 

char *luaL_prepbuffer (luaL_Buffer *B);
返回尺寸为LUAL_BUFFERSIZE的空间的地址，你能把要被加入缓冲器B的字符串拷贝到其中（见luaL_Buffer）。在把字符串拷贝到该空间中以后，你必须用字符串的尺寸调用luaL_addsize来把它加入缓冲器中。 



--------------------------------------------------------------------------------

luaL_pushresult
[-?, +1, m] 

void luaL_pushresult (luaL_Buffer *B);
Finishes the use of buffer B leaving the final string on the top of the stack. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_pushresult
[-?, +1, m] 

void luaL_pushresult (luaL_Buffer *B);
结束对缓冲器B的使用，把最终字符串留在栈顶。 




--------------------------------------------------------------------------------

luaL_ref
[-1, +0, m] 

int luaL_ref (lua_State *L, int t);
Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object). 

A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object. 

If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_ref
[-1, +0, m] 

int luaL_ref (lua_State *L, int t);
在索引t处的表中为栈顶的对象创建一个引用（reference）并返回（而且弹出该对象）。 

引用是唯一的整数键。只要你不手工向表t中加入整数键，luaL_ref保证它返回的键的唯一性。你可通过调用lua_rawgeti(L, t, r)取回被r引用的对象。函数luaL_unref释放引用及其关联的对象。 

如果栈顶的对象是nil，luaL_ref返回常量LUA_REFNIL。常量LUA_NOREF被确保与luaL_ref返回的任何引用都不同。 


--------------------------------------------------------------------------------

luaL_Reg
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_Reg
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
用于要被luaL_register注册的函数数组的类型。name是函数名，func是函数指针。任何luaL_Reg数组必须以name和func都为NULL的标记项结尾。 



--------------------------------------------------------------------------------

luaL_register
[-(0|1), +1, m] 

void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);
Opens a library. 

When called with libname equal to NULL, it simply registers all functions in the list l (see luaL_Reg) into the table on the top of the stack. 

When called with a non-null libname, luaL_register creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one. 

In any case the function leaves the table on the top of the stack. 


--------------------------------------------------------------------------------
（注：TODO）

luaL_register
[-(0|1), +1, m] 

void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);
打开一个库。 

当以libname等于NULL调用时，它只是注册列表l中的所有函数（见luaL_Reg）到栈顶的表中。 

当以非空的libname调用时，luaL_register创建新表t，把它设为全局变量libname的值，和package.loaded[libname]的值，并把列表l中的所有函数注册到该表。如果package.loaded[libname]中或变量libname中有个表，则重用该表而不是创建一个新的。 

无论如何函数都把表留在栈顶。 


--------------------------------------------------------------------------------

luaL_typename
[-0, +0, -] 

const char *luaL_typename (lua_State *L, int index);
Returns the name of the type of the value at the given index. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_typename
[-0, +0, -] 

const char *luaL_typename (lua_State *L, int index);
返回给定索引处的值的类型名。 


--------------------------------------------------------------------------------

luaL_typerror
[-0, +0, v] 

int luaL_typerror (lua_State *L, int narg, const char *tname);
Generates an error with a message like the following: 

     location: bad argument narg to 'func' (tname expected, got rt)

where location is produced by luaL_where, func is the name of the current function, and rt is the type name of the actual argument. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_typerror
[-0, +0, v] 

int luaL_typerror (lua_State *L, int narg, const char *tname);
用类似下面的消息产生一个错误： 

     location: bad argument narg to 'func' (tname expected, got rt)

其中location由luaL_where产生，func是当前函数名，且rt是实际参数的类型名。 


--------------------------------------------------------------------------------

luaL_unref
[-0, +0, -] 

void luaL_unref (lua_State *L, int t, int ref);
Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again. 

If ref is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing. 

--------------------------------------------------------------------------------
（注：TODO）

luaL_unref
[-0, +0, -] 

void luaL_unref (lua_State *L, int t, int ref);
解除来自索引t处的表的引用ref（见luaL_ref）。该项从表中删除，所以被引用的对象可被回收。引用ref也被释放以备再次使用。 

如果ref是LUA_NOREF或LUA_REFNIL，luaL_unref什么也不做。 


--------------------------------------------------------------------------------

luaL_where
[-0, +1, m] 

void luaL_where (lua_State *L, int lvl);
Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the following format: 

     chunkname:currentline:

Level 0 is the running function, level 1 is the function that called the running function, etc. 

This function is used to build a prefix for error messages. 



--------------------------------------------------------------------------------

luaL_where
[-0, +1, m] 

void luaL_where (lua_State *L, int lvl);
压入一个标识当前在lvl层调用堆栈的控制位置到堆栈中。
特别地这个字符串格式如下：
块名:当前行:
0层是正在运行的函数，1层是调用运行中函数的函数，如此类推。
这个函数用于构建错误信息的前缀。








5 - Standard Libraries
The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., type and getmetatable); others provide access to "outside" services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., table.sort). 

All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries: 


（注：TODO）
5 - 标准库
Lua标准库提供直接通过C API实现的有用的函数。其中一些函数提供语言的核心服务（例如type和getmetatable）；其他的提供对“外”访问服务（例如I/O）；还有一些能用Lua自身实现，但是非常有用或者有关键的性能要求以致需要C实现（例如table.sort）。 

所有库通过官方C API实现并且作为独立的C 模块提供。当前Lua拥有如下标准库： 







basic library, which includes the coroutine sub-library; 
package library; 
string manipulation; 
table manipulation; 
mathematical functions (sin, log, etc.); 
input and output; 
operating system facilities; 
debug facilities. 

基础库，包括协程子库；
包库
字符串操作；
表操作；
数学函数（sin，log等）；
输入和输出；
操作系统工具；
调试工具。



Except for the basic and package libraries, each library provides all its functions as fields of a global table or as methods of its objects. 

To have access to these libraries, the C host program should call the luaL_openlibs function, which opens all standard libraries. Alternatively, it can open them individually by calling luaopen_base (for the basic library), luaopen_package (for the package library), luaopen_string (for the string library), luaopen_table (for the table library), luaopen_math (for the mathematical library), luaopen_io (for the I/O library), luaopen_os (for the Operating System library), and luaopen_debug (for the debug library). These functions are declared in lualib.h and should not be called directly: you must call them like any other Lua C function, e.g., by using lua_call. 


除了基础库和包库以外，每个库都以一个全局表的域或它的对象的方法提供所有函数。
想要拥有这些库的访问权，可以通过调用luaopen_base（对于基础库），luaopen_package（对于包库），luaopen_string（对于字符串），luaopen_table（对于表库），luaopen_math（对于数学库），luaopen_io（对于输入输出库），luaopen_os（对于操作系统库），luaopen_debug（对于调试库）单独地打开它们。这些函数在lualib.h中声明，不应该直接调用：你必须像其他Lua的C函数那样调用它们，例如lua_call。








5.1 - Basic Functions
The basic library provides some core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities. 



--------------------------------------------------------------------------------


5.1 - 基础函数
基础库提供一些Lua的核心函数。
如果你在你的应用程序中不包含这个库，你应该细心检查是否需要提供它的某些工具的实现。

--------------------------------------------------------------------------------



assert (v [, message])
Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to "assertion failed!" 


--------------------------------------------------------------------------------



assert (v [, message])
Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to "assertion failed!" 
当它的参数v的值是false（例如nil或false）时发出错误，否则，返回它所有参数。
message是一个错误信息；如果缺省，则默认为"assertion failed!"

--------------------------------------------------------------------------------

collectgarbage (opt [, arg])
This function is a generic interface to the garbage collector. It performs different functions according to its first argument, opt: 

"stop": stops the garbage collector. 
"restart": restarts the garbage collector. 
"collect": performs a full garbage-collection cycle. 
"count": returns the total memory in use by Lua (in Kbytes). 
"step": performs a garbage-collection step. The step "size" is controlled by arg (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of arg. Returns true if the step finished a collection cycle. 
"setpause": sets arg as the new value for the pause of the collector (see §2.10). Returns the previous value for pause. 
"setstepmul": sets arg as the new value for the step multiplier of the collector (see §2.10). Returns the previous value for step. 

--------------------------------------------------------------------------------

collectgarbage (opt [, arg])
这个函数式一个对于垃圾回收器的通用界面。
它根据第一个参数opt执行不同的函数，包括：

"stop": 停止垃圾回收。 
"restart": 重新启动垃圾回收。
"collect": 执行一个完整的垃圾回收循环。 
"count": 返回Lua使用的总内存(千字节单位). 
"step": 执行一个垃圾回收步长。这个步长“大小”以不确定的方式受arg控制（较大的值意味着加大的步长）。
如果你想控制步长大小你必须试验地调节arg的值。
如果步长完成了一次回收循环则返回true。
"setpause": 设置arg为回收器新的暂停值（参考§2.10）。
返回前一个暂停值。
"setstepmul": 设置arg为回收器步长乘数的新值。
返回前一个步长值。


--------------------------------------------------------------------------------

dofile (filename)
Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode). 


--------------------------------------------------------------------------------

dofile (filename)
打开命名文件，并且把它的内容作为Lua块来执行。
当不带参数调用时，dofile执行标准输入（stdin）的内容。
返回块所返回的所有值。
如果出错，dofile把错误传播给它的调用者（即dofile不在保护模式下运行）。

--------------------------------------------------------------------------------

error (message [, level])
Terminates the last protected function called and returns message as the error message. Function error never returns. 
Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message. 

--------------------------------------------------------------------------------

error (message [, level])
终止被调用的最后一个被保护函数然后返回错误信息message。
函数error从不返回。
通常，error在信息的开头添加一些关于错误位置的信息。
参数level指定如何获得错误位置。
当使用层1（默认）时，错误信息是error被调用的地方。
层2把错误指向调用error的函数所在的地方；如此类推。
传递0层参数以避免添加额外的错误位置信息到message中。

--------------------------------------------------------------------------------

_G
A global variable (not a function) that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice-versa. (Use setfenv to change environments.) 

--------------------------------------------------------------------------------
（注：TODO）

_G
持有全局环境的全局变量（非函数）（即_G._G = _G）。Lua自身并不使用该变量；改变其值不影响任何环境，反之亦然。（使用setfenv来改变环境。） 

--------------------------------------------------------------------------------

getfenv ([f])
Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1. 

--------------------------------------------------------------------------------
（注：TODO）

getfenv ([f])
返回函数的当前环境。f可以是Lua函数或指定调用栈级别的数字：级别1是调用getfenv的函数。如果给出的函数不是Lua函数或者f为0，getfenv返回全局环境。f缺省为1。 



--------------------------------------------------------------------------------

getmetatable (object)
If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a "__metatable" field, returns the associated value. Otherwise, returns the metatable of the given object. 

--------------------------------------------------------------------------------
（注：TODO）

getmetatable (object)
如果object没有元表，返回nil。否则，如果对象的元表具有"__metatable"字段，返回关联的值。否则返回给定对象的元表。 


--------------------------------------------------------------------------------

ipairs (t)
Returns three values: an iterator function, the table t, and 0, so that the construction 

     for i,v in ipairs(t) do body end

will iterate over the pairs (1,t[1]), (2,t[2]), ・・・, up to the first integer key absent from the table. 

--------------------------------------------------------------------------------
（注：TODO）

ipairs (t)
返回三个值：迭代器函数、表t和0，所以结构 

     for i,v in ipairs(t) do body end

将迭代键值对（1,t[1]）、（2,t[2]）、・・・，直到第一个不存在于表中的整数键。 


--------------------------------------------------------------------------------

load (func [, chunkname])
Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results. A return of an empty string, nil, or no value signals the end of the chunk. 

If there are no errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message. The environment of the returned function is the global environment. 

chunkname is used as the chunk name for error messages and debug information. When absent, it defaults to "=(load)". 

--------------------------------------------------------------------------------
（注：TODO）

load (func [, chunkname])
通过用func函数获取代码片的方式载入单元。对func的每次调用必须返回一个与先前的结果串联的字符串。返回空串、nil或无值告知单元结束。 

如果没有错误，将编译的单元作为函数返回；否则返回nil以及错误消息。被返回的函数的环境是全局环境。 

chunkname作为单元名用于错误消息和调试信息。当省略时，缺省委“=(load)”。 


--------------------------------------------------------------------------------

loadfile ([filename])
Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given. 

--------------------------------------------------------------------------------
（注：TODO）

loadfile ([filename])
与load类似，但是从文件filename中获取单元，如果未给出文件名则从标准输入获取。 


--------------------------------------------------------------------------------

loadstring (string [, chunkname])
Similar to load, but gets the chunk from the given string. 

To load and run a given string, use the idiom 

     assert(loadstring(s))()

When absent, chunkname defaults to the given string. 

--------------------------------------------------------------------------------
（注：TODO）

loadstring (string [, chunkname])
与load类似，但是从给定的字符串获得单元。 

要载入并运行给定的字符串，使用惯用法： 

     assert(loadstring(s))()

当省略时，chunkname缺省为给定的字符串。 


--------------------------------------------------------------------------------

next (table [, index])
Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty. 

The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numeric order, use a numerical for or the ipairs function.) 

The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields. 

--------------------------------------------------------------------------------
（注：TODO）

next (table [, index])
允许程序遍历标的所有字段。它的第一参数是表，第二参数是该表中的索引。next返回表的下一个索引及其关联的值。当以nil作为第二参数调用时，next返回初始索引和关联的值。当以最后的索引调用或以nil调用空表时，next返回nil。如果省略第二参数，它被解释为nil。特别地，可用next(t)测试表是否为空。 

索引被列举的顺序是未指定的，即使是数字索引。（要以数字顺序遍历表，使用数字for或ipairs函数。） 

如果在遍历期间给表中不存在的字段赋任意值，则next的行为是未定义的。然而，你可以修改已经存在的字段。特别地，你可以清空已经存在的字段。 


--------------------------------------------------------------------------------

pairs (t)
Returns three values: the next function, the table t, and nil, so that the construction 

     for k,v in pairs(t) do body end

will iterate over all keyCvalue pairs of table t. 

See function next for the caveats of modifying the table during its traversal. 


--------------------------------------------------------------------------------
（注：TODO）

pairs (t)
返回三个值：next函数、表t和nil，所以结构 

     for k,v in pairs(t) do body end

将迭代表t的所有键-值对。 

参阅函数next关于其遍历期间对表修改的警告。 


--------------------------------------------------------------------------------

pcall (f, arg1, ・・・)
Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message. 

--------------------------------------------------------------------------------
（注：TODO）

pcall (f, arg1, ・・・)
用给定参数以保护模式（protected mode）调用函数f。这意味着f内的任何错误都不被传播；代替的做法是，pcall捕获错误并返回一个状态码。它的第一结果是状态码（布尔），如果调用成功无误则为true。在这种情况下，pcall也在第一结果之后返回来自调用的所有结果。在任何错误的情况下，pcall返回false以及错误消息。 


--------------------------------------------------------------------------------

print (・・・)
Receives any number of arguments, and prints their values to stdout, using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format. 

--------------------------------------------------------------------------------
（注：TODO）

print (・・・)
接受任意数量的参数，打印它们的值到标准输出（stdout），方式是利用tostring函数将他们转换为字符串。print不是打算给格式化的输出使用的，而是作为一种快速显示值的方式，特别是对调试。对于格式化的输出，使用string.format。 


--------------------------------------------------------------------------------

rawequal (v1, v2)
Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean. 

--------------------------------------------------------------------------------
（注：TODO）

rawequal (v1, v2)
检查v1与v2是否相等，不会调用任何元方法。返回布尔值。 

--------------------------------------------------------------------------------

rawget (table, index)
Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value. 

--------------------------------------------------------------------------------
（注：TODO）

rawget (table, index)
获取table[index]的实际值，不会调用任何元方法。table必须是个表；index可以是任何值。 


--------------------------------------------------------------------------------

rawset (table, index, value)
Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. 
This function returns table. 

--------------------------------------------------------------------------------
（注：TODO）

rawset (table, index, value)
设置table[index]的实际值为value，不会调用任何元方法。table必须是个表，index可以是任何非nil值，并且value可以是任何Lua值。 
该函数返回表。 


--------------------------------------------------------------------------------

select (index, ・・・)
If index is a number, returns all arguments after argument number index. Otherwise, index must be the string "#", and select returns the total number of extra arguments it received. 

--------------------------------------------------------------------------------

select (index, ・・・)
如果索引是数字，返回在参数数目index后的所有参数。
否则index必须是字符串"#"，select会返回它接收的所有额外参数。

--------------------------------------------------------------------------------

setfenv (f, table)
Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling setfenv. setfenv returns the given function. 

As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values. 

--------------------------------------------------------------------------------
（注：TODO）

setfenv (f, table)
设置给定函数要用的环境。f可以是Lua函数或栈中指定级别的函数：级别1是调用setfenv的函数。setfenv返回给定的函数。 

作为特例，当f为0时setfenv改变当前运行线程的环境。在该情况下，setfenv不返回值。 



--------------------------------------------------------------------------------

setmetatable (table, metatable)
Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a "__metatable" field, raises an error. 

This function returns table. 


--------------------------------------------------------------------------------

setmetatable (table, metatable)
为所给的表设置元表。
（你不可以修改来自Lua的其它类型的元表，只能修改来自C的。）
如果元表为nil，删除所给表的元表。
如果原来的元表拥有"__metatable"域，引发一个错误。
这个函数返回表。

--------------------------------------------------------------------------------

tonumber (e [, base])
Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil. 
An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. In base 10 (the default), the number can have a decimal part, as well as an optional exponent part (see §2.1). In other bases, only unsigned integers are accepted. 

--------------------------------------------------------------------------------
（注：TODO）

tonumber (e [, base])
尝试将参数转换为数字。如果参数已经是数字或可转换为数字的字符串，则tonumber返回该数字；否则返回nil。 
可选参数指定如何解释数字的基数。基数可以是2和36之间的任何整数，也包括它们。在高于10的基数中，字母'A'（大小写皆可）表示10，'B'表示11，依次类推，直到'Z'表示35。在基数为10（缺省）时，数字可有小数部分，也可有可选的指数部分（见§2.1）。其他基数只接受无符号整数。 



--------------------------------------------------------------------------------

tostring (e)
Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format. 
If the metatable of e has a "__tostring" field, then tostring calls the corresponding value with e as argument, and uses the result of the call as its result. 


--------------------------------------------------------------------------------
（注：TODO）

tostring (e)
接受任意类型的参数并以合理的格式将其转换为字符串。对于完全控制数字如何转换，使用string.format。 
如果e的元表有"__tostring"字段，则tostring以e为参数调用相应的值，并用调用的结果为其结果。 


--------------------------------------------------------------------------------

type (v)
Returns the type of its only argument, coded as a string. The possible results of this function are "nil" (a string, not the value nil), "number", "string", "boolean", "table", "function", "thread", and "userdata". 

--------------------------------------------------------------------------------
（注：TODO）

type (v)
返回其仅有参数的类型，编码为一个字符串。该函数的可能结果是"nil"（字符串，不是值nil）、"number"、"string"、"boolean"、"table"、"function"、"thread"和"userdata"。 


--------------------------------------------------------------------------------

unpack (list [, i [, j]])
Returns the elements from the given table. This function is equivalent to 
     return list[i], list[i+1], ・・・, list[j]

except that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator (see §2.5.5). 

--------------------------------------------------------------------------------
（注：TODO）

unpack (list [, i [, j]])
返回给定标的元素。该函数等价于 
     return list[i], list[i+1], ・・・, list[j]

除了上面的代码只能用在元素数量固定的情况。缺省时，i是1而j是列表的长度，就像取长操作符（见§2.5.5）定义的那样。 


--------------------------------------------------------------------------------

_VERSION
A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is "Lua 5.1". 

--------------------------------------------------------------------------------
（注：TODO）

_VERSION
保存含有当前解释器版本的字符串的全局变量（非函数）。该变量的当前内容是“Lua 5.1”。 


--------------------------------------------------------------------------------

xpcall (f, err)
This function is similar to pcall, except that you can set a new error handler. 

xpcall calls function f in protected mode, using err as the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In this case, xpcall also returns all results from the call, after this first result. In case of any error, xpcall returns false plus the result from err. 


--------------------------------------------------------------------------------
（注：TODO）

xpcall (f, err)
该函数类似pcall，除了可以设置新的错误处理器。 

xpcall用err作为错误处理器，在保护模式中调用函数f。f内的错误不被传播；代替做法是，xpcall捕获错误，以原始错误对象调用err函数，并返回一个状态码。它的第一结果是状态码（布尔值），如果调用成功无误则为true。在该情况下，xpcall也在该第一结果后面返回来自调用的所有结果。在错误的情况下，xpcall返回false以及来自err的结果。 








5.2 - Coroutine Manipulation
The operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. See §2.11 for a general description of coroutines. 


（注：TODO）
5.2 - 协程操作
涉及协程的操作由基础库的一个子库组成，并且出现在表coroutine内。关于协程的全面描述见§2.11。 


--------------------------------------------------------------------------------

coroutine.create (f)
Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type "thread". 


--------------------------------------------------------------------------------
（注：TODO）

coroutine.create (f)
用f主体创建一个新协程。f必须是Lua函数。返回该新协程，它是类型为“thread”的对象。 



--------------------------------------------------------------------------------

coroutine.resume (co [, val1, ・・・])
Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ・・・ are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ・・・ are passed as the results from the yield. 

If the coroutine runs without any errors, resume returns true plus any values passed to yield (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, resume returns false plus the error message. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.resume (co [, val1, ・・・])
启动或继续协程co的执行。首次恢复协程时，它启动运行协程主体。值val1, ・・・是传入主体函数的参数。如果协程被中断了，resume重新启动它；值val1, ・・・是从yield传来的结果。 

如果协程运行无误，resume返回true以及传入yield（如果协程中断）的任何值或由主体函数（如果协程结束）返回的任何值。如果有任何错误，resume返回false以及错误消息。 



--------------------------------------------------------------------------------

coroutine.running ()
Returns the running coroutine, or nil when called by the main thread. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.running ()
返回运行的协程，或者当被主线程调用时返回nil。 


--------------------------------------------------------------------------------

coroutine.status (co)
Returns the status of coroutine co, as a string: "running", if the coroutine is running (that is, it called status); "suspended", if the coroutine is suspended in a call to yield, or if it has not started running yet; "normal" if the coroutine is active but not running (that is, it has resumed another coroutine); and "dead" if the coroutine has finished its body function, or if it has stopped with an error. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.status (co)
返回协程co的状态，以字符串的方式：如果协程正在运行（即是它调用了status）则为“running”；如果协程被yield调用暂停或还未启动运行则为“suspended”；如果协程是活动的但不在运行中（即它恢复了另一个协程）则为“normal”；如果协程结束了它的主体函数或出错停止则为"dead"。 



--------------------------------------------------------------------------------

coroutine.wrap (f)
Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.wrap (f)
用f主体创建一个新协程。f必须是Lua函数。返回一个函数，每次调用它会恢复协程。传入该函数的任何参数都作为resume的额外参数。返回值同resume相同，除了第一个布尔值。在发生错误情况下传播错误。 


--------------------------------------------------------------------------------

coroutine.yield (・・・)
Suspends the execution of the calling coroutine. The coroutine cannot be running a C function, a metamethod, or an iterator. Any arguments to yield are passed as extra results to resume. 

--------------------------------------------------------------------------------
（注：TODO）

coroutine.yield (・・・)
暂停调用者协程的执行。协程不能正在运行C函数、元方法或迭代器。yield的任何参数被传为resume的结果。 




5.3 - Modules
The package library provides basic facilities for loading and building modules in Lua. It exports two of its functions directly in the global environment: require and module. Everything else is exported in a table package. 


（注：TODO）

5.3 - 模块
打包库为在Lua中加载和创建模块提供基础设备。它直接导出两个函数到全局环境中：require和module。其他东西都导出到表package中。 



--------------------------------------------------------------------------------

module (name [, ・・・])
Creates a module. If there is a table in package.loaded[name], this table is the module. Otherwise, if there is a global table t with the given name, this table is the module. Otherwise creates a new table t and sets it as the value of the global name and the value of package.loaded[name]. This function also initializes t._NAME with the given name, t._M with the module (t itself), and t._PACKAGE with the package name (the full module name minus last component; see below). Finally, module sets t as the new environment of the current function and the new value of package.loaded[name], so that require returns t. 

If name is a compound name (that is, one with components separated by dots), module creates (or reuses, if they already exist) tables for each component. For instance, if name is a.b.c, then module stores the module table in field c of field b of global a. 

This function can receive optional options after the module name, where each option is a function to be applied over the module. 

--------------------------------------------------------------------------------
（注：TODO）

module (name [, ・・・])
创建一个模块。如果在package.loaded[name]中有个表，该表就是模块。否则，如果有个给定名字的全局表t，该表就是模块。否则创建新表t并把它设为全局name和package.loaded[name]的值。该函数也用给定的名字初始化t._NAME，用模块（t自身）设置t._M，并用包名设置t._PACKAGE（完整模块名减去最后部分；见下）。最后，module设置t为当前函数的新环境和package.loaded[name]的新值，因此require返回t。 

如果name是个复合名字（即用点号分隔的几个部分），module为每个部分创建（或重用，如果它们已经存在）表。例如，如果name是a.b.c，则module在全局a的字段b的字段c中存储模块表。 

该函数可接受模块名后可选的options，其中每个选项是要加入模块的函数。 


--------------------------------------------------------------------------------

require (modname)
Loads the given module. The function starts by looking into the package.loaded table to determine whether modname is already loaded. If it is, then require returns the value stored at package.loaded[modname]. Otherwise, it tries to find a loader for the module. 

To find a loader, require is guided by the package.loaders array. By changing this array, we can change how require looks for a module. The following explanation is based on the default configuration for package.loaders. 

First require queries package.preload[modname]. If it has a value, this value (which should be a function) is the loader. Otherwise require searches for a Lua loader using the path stored in package.path. If that also fails, it searches for a C loader using the path stored in package.cpath. If that also fails, it tries an all-in-one loader (see package.loaders). 

Once a loader is found, require calls the loader with a single argument, modname. If the loader returns any value, require assigns the returned value to package.loaded[modname]. If the loader returns no value and has not assigned any value to package.loaded[modname], then require assigns true to this entry. In any case, require returns the final value of package.loaded[modname]. 

If there is any error loading or running the module, or if it cannot find any loader for the module, then require signals an error. 

--------------------------------------------------------------------------------
（注：TODO）

require (modname)
加载给定模块。该函数先浏览表package.loaded确认modname是否已经加载了。如果是，require返回存储在package.loaded[modname]中的值。否则，它尝试为模块找到一个加载器（loader）。 

数组package.loaders指示require如何寻找加载器。通过改变该数组，我们可以改变require如何寻找模块。下面的解释基于package.loaders的缺省配置。 

require首先查询package.preload[modname]。如果它有值，该值（应是个函数）就是加载器。否则require使用存储在package.path中的路径搜索一个Lua加载器。如果那也失败了，它用存储在package.cpath中的路径搜索一个C加载器。如果也失败了，它尝试一个一体化（all-in-one）加载器（见package.loaders）。 

一旦找到，require用单个参数modname调用这个加载器。如果加载器返回任何值，require把返回值赋给package.loaded[modname]。如果加载器不返回值而且没有赋给package.loaded[modname]任何值，require把true赋给该条目。在任何情况下，require返回package.loaded[modname]的最终值。 

如果加载或运行模块时发生任何错误，或者如果不能为模块找到任何加载器，require导致一个错误。 




--------------------------------------------------------------------------------

package.cpath
The path used by require to search for a C loader. 

Lua initializes the C path package.cpath in the same way it initializes the Lua path package.path, using the environment variable LUA_CPATH or a default path defined in luaconf.h. 

--------------------------------------------------------------------------------
（注：TODO）

package.cpath
该路径被require用于搜索一个C加载器。 

Lua用同初始化Lua路径package.path一样的方式初始化C路径package.cpath，利用环境变量LUA_CPATH或一个定义在luaconf.h中的缺省路径。 


--------------------------------------------------------------------------------

package.loaded
A table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there. 

--------------------------------------------------------------------------------
（注：TODO）

package.loaded
被require用来控制已经加载了哪些模块。当你require一个模块modname而且package.loaded[modname]不为假时，require只是返回存储在那儿的值。 


--------------------------------------------------------------------------------

package.loaders
A table used by require to control how to load modules. 

Each entry in this table is a searcher function. When looking for a module, require calls each of these searchers in ascending order, with the module name (the argument given to require) as its sole parameter. The function can return another function (the module loader) or a string explaining why it did not find that module (or nil if it has nothing to say). Lua initializes this table with four functions. 

The first searcher simply looks for a loader in the package.preload table. 

The second searcher looks for a loader as a Lua library, using the path stored at package.path. A path is a sequence of templates separated by semicolons. For each template, the searcher will change each interrogation mark in the template by filename, which is the module name with each dot replaced by a "directory separator" (such as "/" in Unix); then it will try to open the resulting file name. So, for instance, if the Lua path is the string 

     "./?.lua;./?.lc;/usr/local/?/init.lua"

the search for a Lua file for module foo will try to open the files ./foo.lua, ./foo.lc, and /usr/local/foo/init.lua, in that order. 

The third searcher looks for a loader as a C library, using the path given by the variable package.cpath. For instance, if the C path is the string 

     "./?.so;./?.dll;/usr/local/?/init.so"

the searcher for module foo will try to open the files ./foo.so, ./foo.dll, and /usr/local/foo/init.so, in that order. Once it finds a C library, this searcher first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside the library to be used as the loader. The name of this C function is the string "luaopen_" concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is a.v1-b.c, the function name will be luaopen_b_c. 

The fourth searcher tries an all-in-one loader. It searches the C path for a library for the root name of the given module. For instance, when requiring a.b.c, it will search for a C library for a. If found, it looks into it for an open function for the submodule; in our example, that would be luaopen_a_b_c. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function. 


--------------------------------------------------------------------------------
（注：TODO）

package.loaders
被require用来控制如何加载模块的表。 

该表的每个条目是个搜索器函数（searcher function）。当查找模块时，require按照升序逐个调用这些搜索器，并用模块名（传给require的参数）作为它的唯一参数。该函数可返回另一个函数（模块加载器）或一条解释为何没找到模块的字符串（或nil，如果没话可说）。Lua用四个函数初始化该表。 

第一个搜索器只是在表package.preload中查找加载器。 

第二个搜索器（把模块）作为Lua库使用存储于package.path中的路径查找加载器。路径是由分号分隔的一系列模板（template）。对每个模板，搜索器将模板中的每个问号改为filename，后者是模块名，它的每个点号都被替换为“目录分隔符（directory separator）”（例如Unix中的/）；然后它将尝试打开合成的文件名。因此，例如，如果Lua路径是字符串 

     "./?.lua;./?.lc;/usr/local/?/init.lua"

对模块foo的Lua文件的搜索将尝试按顺序打开文件./foo.lua、./foo.lc和/usr/local/foo/init.lua。 

第三个搜索器（把模块）作为C库用变量package.cpath给出的路径查找加载器。例如，如果C路径是字符串 

     "./?.so;./?.dll;/usr/local/?/init.so"

对模块foo的搜索将尝试按顺序打开文件./foo.so、./foo.dll和/usr/local/foo/init.so。一旦找到C库，该搜索器首先用动态链接设备链接应用和库。然后尝试在库内查找一个将用作加载器的C函数。该C函数的名字是“luaopen_”同模块名的拷贝连接得到的字符串，模块名的每个点号被下划线替换。此外，如果模块名有个连字符，它的直到（并且包括）第一个连字符的前缀被移除。例如，如果模块名是a.v1-b.c，函数名将是luaopen_b_c。 

第四个搜索器尝试一个一体化加载器。它在C路径中为给定模块的根名搜索库。例如，当请求a.b.c时，它将为a搜索C库。如果找到了，在其中为子模块查找打开函数；在我们的例子中是luaopen_a_b_c。利用该设备，包可以将若干C子模块打包在单个库中，其中的每个子模块持有自己的原始打开函数。 



--------------------------------------------------------------------------------

package.loadlib (libname, funcname)
Dynamically links the host program with the C library libname. Inside this library, looks for a function funcname and returns this function as a C function. (So, funcname must follow the protocol (see lua_CFunction)). 

This is a low-level function. It completely bypasses the package and module system. Unlike require, it does not perform any path searching and does not automatically adds extensions. libname must be the complete file name of the C library, including if necessary a path and extension. funcname must be the exact name exported by the C library (which may depend on the C compiler and linker used). 

This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard). 

--------------------------------------------------------------------------------
（注：TODO）

package.loadlib (libname, funcname)
把C库libname动态链接到宿主程序。在库内查找函数funcname并作为C函数返回。（所以，funcname必须遵循协议（见lua_CFunction））。 

这是个低级函数。它完全绕过包和模块系统。不像require，它不执行任何陆路径搜索也不会自动地增加扩展名。libname必须是C库的完全文件名，如果需要还包括路径和扩展名。funcname必须是确切的C库导出的名字（依赖C编译器和链接器）。 

该函数不被ANSI C支持。同样，它只在某些平台可用（Windows、Linux、Mac OS X、Solaris、BSD，以及支持dlfcn标准的其他Unix系统）。 



--------------------------------------------------------------------------------

package.path
The path used by require to search for a Lua loader. 

At start-up, Lua initializes this variable with the value of the environment variable LUA_PATH or with a default path defined in luaconf.h, if the environment variable is not defined. Any ";;" in the value of the environment variable is replaced by the default path. 


--------------------------------------------------------------------------------
（注：TODO）

package.path
该路径被require用来搜索一个Lua加载器。 

Lua在启动时用环境变量LUA_PATH的值初始化该变量，或者如果该环境变量未定义则用定义在luaconf.h中的缺省路径。环境变量的值中的任何“;;”都被替换为缺省路径。 



--------------------------------------------------------------------------------

package.preload
A table to store loaders for specific modules (see require). 

--------------------------------------------------------------------------------
（注：TODO）

package.preload
用于特定模块存储加载器的表。（见require）。 


--------------------------------------------------------------------------------

package.seeall (module)
Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function module. 

--------------------------------------------------------------------------------
（注：TODO）

package.seeall (module)
为module设置元表，其__index字段引用全局变量，所以该模块继承全局变量的值。将要被用作函数module的一个选项。 










5.4 - String Manipulation
This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on. 

The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style. For instance, string.byte(s, i) can be written as s:byte(i). 

The string library assumes one-byte character encodings. 


（注：TODO）
5.4 - 字符串操作
该库为字符串操作提供常规函数，例如查找和抽取子串以及模式匹配。在Lua中索引字符串时，第一个字符在位置1（不像C是在0处）。索引允许为负数，被解释为从字符串末尾往回索引。因此，最后一个字符在-1位置，依此类推。 

字符串库在表string内提供所有函数。它也给字符串设置元表，其中的__index字段指向string表。因此，你可以使用面向对象风格的字符串函数。例如，string.byte(s, i)可写为s:byte(i)。 

字符串库采取单字节字符编码方式。 






--------------------------------------------------------------------------------

string.byte (s [, i [, j]])
Returns the internal numerical codes of the characters s[i], s[i+1], ・・・, s[j]. The default value for i is 1; the default value for j is i. 
Note that numerical codes are not necessarily portable across platforms. 

--------------------------------------------------------------------------------
（注：TODO）

string.byte (s [, i [, j]])
返回字符s[i], s[i+1], ・・・, s[j]的内部数字代码。i缺省为1；j缺省为i。 
注意数字代码不一定是跨平台可移植的。 



--------------------------------------------------------------------------------

string.char (・・・)
Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument. 
Note that numerical codes are not necessarily portable across platforms. 

--------------------------------------------------------------------------------
（注：TODO）

string.char (・・・)
接受0获多个整数。返回一个字符串，其长度等于参数个数，其中的每个字符的内部数字代码等于相应的参数。 
注意数字代码不一定是跨平台可移植的。 


--------------------------------------------------------------------------------

string.dump (function)
Returns a string containing a binary representation of the given function, so that a later loadstring on this string returns a copy of the function. function must be a Lua function without upvalues. 

--------------------------------------------------------------------------------
（注：TODO）

string.dump (function)
返回给定函数的二进制表示的字符串，之后在其上应用loadstring返回函数的拷贝。function必须是不带upvalueLua函数。 


--------------------------------------------------------------------------------

string.find (s, pattern [, init [, plain]])
Looks for the first match of pattern in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain "find substring" operation, with no characters in pattern being considered "magic". Note that if plain is given, then init must be given as well. 
If the pattern has captures, then in a successful match the captured values are also returned, after the two indices. 

--------------------------------------------------------------------------------
（注：TODO）

string.find (s, pattern [, init [, plain]])
在字符串s中查找pattern的第一个匹配。如果找到则返回它开始和结束处在s中的索引；否则，返回nil。可选的第三参数init是数字，指定从哪儿开始搜索；其缺省值是1并且可为负数。如果真值作为可选的第四参数plain，则关闭模式匹配设备，所以函数执行无格式的“查找子串”操作，pattern中的字符并不被认为是“魔术的（magic）”。注意，如果给出了plain，则init也必须给出。 
如果模式具有捕获（capture），则在成功的匹配中被捕获的值也在两个索引后面返回。 


--------------------------------------------------------------------------------

string.format (formatstring, ・・・)
Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the printf family of standard C functions. The only differences are that the options/modifiers *, l, L, n, p, and h are not supported and that there is an extra option, q. The q option formats a string in a form suitable to be safely read back by the Lua interpreter: the string is written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes in the string are correctly escaped when written. For instance, the call 
     string.format('%q', 'a string with "quotes" and \n new line')

will produce the string: 

     "a string with \"quotes\" and \
      new line"

The options c, d, E, e, f, g, G, i, o, u, X, and x all expect a number as argument, whereas q and s expect a string. 

This function does not accept string values containing embedded zeros, except as arguments to the q option. 

--------------------------------------------------------------------------------
（注：TODO）

string.format (formatstring, ・・・)
Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). 格式字符串遵循同printf族标准C函数同样的规则。仅有的区别是不支持*、l、L、n、p和h等选项/修饰符，而且有个额外选项q。q选项以可安全地为Lua解释器读取的适当形式格式化字符串：字符串被写在双引号之间，而且字符串中的所有双引号、换行、内嵌的0和反斜杠被恰当地转义。例如，调用 
     string.format('%q', 'a string with "quotes" and \n new line')

产生字符串： 

     "a string with \"quotes\" and \
      new line"

选项c、d、E、e、f, g、G、i、o、u、X和x都预期得到数字作为参数，然而q和s期望得到字符串。 

该函数不接受含有内嵌的0的字符串值，除了作为q选项的参数。 


--------------------------------------------------------------------------------

string.gmatch (s, pattern)
Returns an iterator function that, each time it is called, returns the next captures from pattern over string s. If pattern specifies no captures, then the whole match is produced in each call. 
As an example, the following loop 

     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end

will iterate over all the words from string s, printing one per line. The next example collects all pairs key=value from the given string into a table: 

     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end

For this function, a '^' at the start of a pattern does not work as an anchor, as this would prevent the iteration. 

--------------------------------------------------------------------------------
（注：TODO）

string.gmatch (s, pattern)
返回一个迭代器函数，每次调用返回来自pattern的下一个捕获，从字符串s开头直到结尾。如果pattern没指定捕获则每次调用产生整个匹配。 
作为例子，下面的循环 

     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end

将迭代来自字符串s的所有单词，每行打印一个。下一个例子从给定的字符串收集所有的键=值对放在表中： 

     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "^(%w+)=(%w+)") do
       t[k] = v
     end

对于该函数，模式起始处的‘^’不能作为锚点，因为这会阻止迭代。 




--------------------------------------------------------------------------------

string.gsub (s, pattern, repl [, n])
Returns a copy of s in which all (or the first n, if given) occurrences of the pattern have been replaced by a replacement string specified by repl, which can be a string, a table, or a function. gsub also returns, as its second value, the total number of matches that occurred. 
If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %n, with n between 1 and 9, stands for the value of the n-th captured substring (see below). The sequence %0 stands for the whole match. The sequence %% stands for a single %. 

If repl is a table, then the table is queried for every match, using the first capture as the key; if the pattern specifies no captures, then the whole match is used as the key. 

If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument. 

If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string). 

Here are some examples: 

     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --> x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --> x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --> x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --> x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --> x="4+5 = 9"
     
     local t = {name="lua", version="5.1"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --> x="lua-5.1.tar.gz"

--------------------------------------------------------------------------------
（注：TODO）

string.gsub (s, pattern, repl [, n])
返回s的拷贝，其中出现的所有（或前n个，如果指定）pattern被替换为repl――可以是字符串、表或函数，指定的替换串。gsub也返回出现的匹配的总数作为第二个值。 
如果repl是字符串，它的值被用作替换式。字符%用作转义字符：repl中的任何形如%n的序列代表第n个捕获的子串（见下面），其中n在1和9之间。序列%0代表整个匹配。序列%%代表单个%。 

如果repl是表，则对于每个匹配，用第一个捕获作为键查询表；如果模式未指定捕获，则整个匹配被用作键。 

如果repl是函数，则每次匹配发生时都按顺序传入所有捕获的子串作为参数调用该函数；如果模式没指定捕获，则整个匹配作为单个参数传入。 

如果表查询或函数调用返回的结果是个字符串或数字，则被用作替换串；否则，如果是false或nil，则不发生替换（即原始匹配被保持在字符串中）。 

这里有一些例子： 

     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --> x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --> x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --> x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --> x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --> x="4+5 = 9"
     
     local t = {name="lua", version="5.1"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --> x="lua-5.1.tar.gz"



--------------------------------------------------------------------------------

string.len (s)
Receives a string and returns its length. The empty string "" has length 0. Embedded zeros are counted, so "a\000bc\000" has length 5. 

--------------------------------------------------------------------------------
（注：TODO）

string.len (s)
接受字符串并返回其长度。空串""长度为0。内嵌的0被计算在内，所以"a\000bc\000"长度为5。 

--------------------------------------------------------------------------------

string.lower (s)
Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale. 

--------------------------------------------------------------------------------
（注：TODO）

string.lower (s)
接受字符串并返回其所有大写字母变为小写的拷贝。所有其他字符不变。大写字母的定义依赖于当前locale。 


--------------------------------------------------------------------------------

string.match (s, pattern [, init])
Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative. 

--------------------------------------------------------------------------------
（注：TODO）

string.match (s, pattern [, init])
在字符串s中查找pattern的首次匹配。如果找到一个，则返回来自模式的捕获；否则返回nil。如果pattern未指定捕获则返回整个匹配。可选的第三个参数init是数字，指定从哪儿开始搜索；其缺省值是1并且可为负。 



--------------------------------------------------------------------------------

string.rep (s, n)
Returns a string that is the concatenation of n copies of the string s. 

--------------------------------------------------------------------------------
（注：TODO）

string.rep (s, n)
返回字符串s的n个拷贝拼接字符串。 


--------------------------------------------------------------------------------

string.reverse (s)
Returns a string that is the string s reversed. 

--------------------------------------------------------------------------------
（注：TODO）

string.reverse (s)
返回字符串s的颠倒的字符串。 


--------------------------------------------------------------------------------

string.sub (s, i [, j])
Returns the substring of s that starts at i and continues until j; i and j can be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i. 

--------------------------------------------------------------------------------
（注：TODO）

string.sub (s, i [, j])
返回s的子串，它起始于i并延续到j；i和j可为负数。如果省略j，则它被假定为-1（同字符串长度一样）。特别地，调用string.sub(s,1,j)返回s长为j的前缀，而且string.sub(s, -i)返回s长为i的后缀。 


--------------------------------------------------------------------------------

string.upper (s)
Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale. 


--------------------------------------------------------------------------------
（注：TODO）

string.upper (s)
接受字符串并返回其所有小写字母变为大写的拷贝。所有其他字符不变。小写字母的定义依赖于当前locale。 









5.4.1 - Patterns
Character Class:
A character class is used to represent a set of characters. The following combinations are allowed in describing a character class: 

x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself. 
.: (a dot) represents all characters. 
%a: represents all letters. 
%c: represents all control characters. 
%d: represents all digits. 
%l: represents all lowercase letters. 
%p: represents all punctuation characters. 
%s: represents all space characters. 
%u: represents all uppercase letters. 
%w: represents all alphanumeric characters. 
%x: represents all hexadecimal digits. 
%z: represents the character with representation 0. 
%x: (where x is any non-alphanumeric character) represents the character x. This is the standard way to escape the magic characters. Any punctuation character (even the non magic) can be preceded by a '%' when used to represent itself in a pattern. 
[set]: represents the class which is the union of all characters in set. A range of characters can be specified by separating the end characters of the range with a '-'. All classes %x described above can also be used as components in set. All other characters in set represent themselves. For example, [%w_] (or [_%w]) represents all alphanumeric characters plus the underscore, [0-7] represents the octal digits, and [0-7%l%-] represents the octal digits plus the lowercase letters plus the '-' character. 
The interaction between ranges and classes is not defined. Therefore, patterns like [%a-z] or [a-%%] have no meaning. 

[^set]: represents the complement of set, where set is interpreted as above. 
For all classes represented by single letters (%a, %c, etc.), the corresponding uppercase letter represents the complement of the class. For instance, %S represents all non-space characters. 

The definitions of letter, space, and other character groups depend on the current locale. In particular, the class [a-z] may not be equivalent to %l. 

Pattern Item:
A pattern item can be 

a single character class, which matches any single character in the class; 
a single character class followed by '*', which matches 0 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence; 
a single character class followed by '+', which matches 1 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence; 
a single character class followed by '-', which also matches 0 or more repetitions of characters in the class. Unlike '*', these repetition items will always match the shortest possible sequence; 
a single character class followed by '?', which matches 0 or 1 occurrence of a character in the class; 
%n, for n between 1 and 9; such item matches a substring equal to the n-th captured string (see below); 
%bxy, where x and y are two distinct characters; such item matches strings that start with x, end with y, and where the x and y are balanced. This means that, if one reads the string from left to right, counting +1 for an x and -1 for a y, the ending y is the first y where the count reaches 0. For instance, the item %b() matches expressions with balanced parentheses. 
Pattern:
A pattern is a sequence of pattern items. A '^' at the beginning of a pattern anchors the match at the beginning of the subject string. A '$' at the end of a pattern anchors the match at the end of the subject string. At other positions, '^' and '$' have no special meaning and represent themselves. 

Captures:
A pattern can contain sub-patterns enclosed in parentheses; they describe captures. When a match succeeds, the substrings of the subject string that match captures are stored (captured) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the part of the string matching "a*(.)%w(%s*)" is stored as the first capture (and therefore has number 1); the character matching "." is captured with number 2, and the part matching "%s*" has number 3. 

As a special case, the empty capture () captures the current string position (a number). For instance, if we apply the pattern "()aa()" on the string "flaaap", there will be two captures: 3 and 5. 

A pattern cannot contain embedded zeros. Use %z instead. 



（注：TODO）

5.4.1 - 模式
字符类（Character Class）：
一个字符类被用于表示一组字符。允许用下面的组合描述字符类： 

x: （此处x不是魔术字符^$()%.[]*+-?中的一个）表示字符x本身。 
.: （一个点）表示所有字符。 
%a: 表示所有字母。 
%c: 表示所有控制字符。 
%d: 表示所有十进制数字。 
%l: 表示所有小写字母。 
%p: 表示所有标点符号。 
%s: 表示所有空白字符。 
%u: 表示所有大写字母。 
%w: 表示所有字母数字字符。 
%x: 表示所有十六进制数字。 
%z: 表示0值字符。 
%x: （此处x是任何非字母数字字符）表示字符x。这是转义魔术字符的标准方式。当被用于在模式中表示自身时，任何标点符号（甚至非魔术的）都能前缀一个‘%’。 
[set]: 表示set中的所有字符的联合构成的分类。通过用‘-’分隔截止字符可以指定某个范围的字符。上面描述的所有种类的%x都可用作set的部件。set中的所有其他字符表示它们自身。例如[%w_]（或[_%w]）表示所有字母数字字符和下划线，[0-7]表示八进制数字，[0-7%l%-]表示八进制数字和小写字母以及‘-’字符。 
字符范围和字符类之间的相互作用是未定义的。因此类似[%a-z]或[a-%%]的模式没有意义。 

[^set]: 表示set的补集，其中的set在上面解释了。 
所有单字母表示的字符类（%a、%c，等等），相应的大写字母表示该字符类的补集。例如，%S表示所有非空白符。 

字母、空白和其他字符组合的定义依赖于当前locale。特别地，字符类[a-z]可能不等于%l。 

模式项（Pattern Item）:
模式项可为 

单个字符类，它匹配该类中的任意单个字符； 
后跟‘*’的单个字符类，它匹配该类中的0或多个字符。这些重复项将总是匹配最长的可能序列； 
后跟‘+’的单个字符类，它匹配该类中的1或多个字符。这些重复项将总是匹配最长的可能序列； 
后跟‘-’的单个字符类，它也匹配该类中的0或多个字符。与‘*’不同，这些重复项将总是匹配最短的可能序列； 
后跟‘?’的单个字符类，它匹配出现0或1次该类中的字符； 
%n，其中n在1和9之间；这种项匹配一个等价于捕获的字符串的第n个子串（见下面）； 
%bxy其中x和y是两个不同的字符；这种项匹配始于x终于y的字符串，并且x和y是对称的。这表示，如果一个人从左到右读字符串，对x计数为+1，对y计数为-1，结尾的y是第一个遇到计数为0的y 。例如，项%b()匹配带有平衡的圆括号的表达式。 
模式（Pattern）:
模式是一系列的模式项。在模式开头的‘^’将匹配固定在源串的开头。 在模式结尾的‘$’将匹配固定在源串的结尾。在其他位置上，‘^’和‘$’没有特殊含义，表示它们自身。 

捕获（Captures）:
模式可以含有括在圆括号内的子模式；它们描述捕获。当成功进行一个匹配，源串中匹配捕获的子串被存储（捕获）以便将来使用。捕获根据它们的左圆括号进行编号。例如，在模式"(a*(.)%w(%s*))"中，字符串的匹配"a*(.)%w(%s*)"的部分作为第一个捕获被存储（因此被编号为1）；匹配“.”的字符被捕获并编号为2，匹配“%s*”的部分被编号为3。 

作为一种特殊情况，空捕获()捕获当前字符串位置（一个数字）。例如，如果我们把模式"()aa()"用于字符串"flaaap"，将有两个捕获：3和5。 

模式不能含有内嵌的0。使用%z代替。 















5.5 - Table Manipulation
This library provides generic functions for table manipulation. It provides all its functions inside the table table. 

Most functions in the table library assume that the table represents an array or a list. For these functions, when we talk about the "length" of a table we mean the result of the length operator. 


（注：TODO）
5.5 - 表操作
该库为表操作处理提供常规函数。它在表table内提供其所有函数。 

表中的多数函数假定给定的表表示数组或列表。对于这些函数，当我们谈到表的“长度”时，我们意指取长操作符的结果。 




--------------------------------------------------------------------------------

table.concat (table [, sep [, i [, j]]])
Given an array where all elements are strings or numbers, returns table[i]..sep..table[i+1] ・・・ sep..table[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is the length of the table. If i is greater than j, returns the empty string. 

--------------------------------------------------------------------------------
（注：TODO）

table.concat (table [, sep [, i [, j]]])
给定一个数组，其所有元素是字符串或数字，返回table[i]..sep..table[i+1] ・・・ sep..table[j]。sep的缺省值是空字符串，i的缺省值是1，j的缺省值是表的长度。如果i比j大，返回空字符串。 


--------------------------------------------------------------------------------

table.insert (table, [pos,] value)
Inserts element value at position pos in table, shifting up other elements to open space, if necessary. The default value for pos is n+1, where n is the length of the table (see §2.5.5), so that a call table.insert(t,x) inserts x at the end of table t. 

--------------------------------------------------------------------------------
（注：TODO）

table.insert (table, [pos,] value)
在表table的pos位置插入元素value，如果需要将其他元素上移到开放空间。pos的缺省值是n+1，其中n是表的长度（见§2.5.5），所以调用table.insert(t,x)在表t结尾插入x。 


--------------------------------------------------------------------------------

table.maxn (table)
Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices. (To do its job this function does a linear traversal of the whole table.) 

--------------------------------------------------------------------------------
（注：TODO）

table.maxn (table)
返回给定表的最大正数索引，如果没有正数索引则返回0。（该函数执行一次整个表的线性遍历来做这个工作。） 


--------------------------------------------------------------------------------

table.remove (table [, pos])
Removes from table the element at position pos, shifting down other elements to close the space, if necessary. Returns the value of the removed element. The default value for pos is n, where n is the length of the table, so that a call table.remove(t) removes the last element of table t. 

--------------------------------------------------------------------------------
（注：TODO）

table.remove (table [, pos])
从table中删除在位置pos处的元素，如果需要会下移其他元素以缩紧空格。返回被删除的值。pos的缺省值是表的长度n，所以调用table.remove(t)删除表t的最后一个元素。 


--------------------------------------------------------------------------------

table.sort (table [, comp])
Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table. If comp is given, then it must be a function that receives two table elements, and returns true when the first is less than the second (so that not comp(a[i+1],a[i]) will be true after the sort). If comp is not given, then the standard Lua operator < is used instead. 
The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort. 

--------------------------------------------------------------------------------
（注：TODO）

table.sort (table [, comp])
从table[1]到table[n]将表元素排序为给定顺序的适当位置，其中n是表的长度。如果给出了comp，它必须是个函数，接受两个表元素并当第一个小于第二个时返回true（所以排序后not comp(a[i+1],a[i])将为true）。如果未给出comp，则使用标准的Lua操作符<代替。 
排序算法不稳定；就是说，被指定顺序认为相等的元素可能被排序改变相对位置。 










5.6 - Mathematical Functions
This library is an interface to the standard C math library. It provides all its functions inside the table math. 


（注：TODO）

5.6 - 数学运算函数
该库是标准C数学库的接口。它在表math中提供所有函数。 



--------------------------------------------------------------------------------

math.abs (x)
Returns the absolute value of x. 

--------------------------------------------------------------------------------
（注：TODO）

math.abs (x)
返回x的绝对值。 


--------------------------------------------------------------------------------

math.acos (x)
Returns the arc cosine of x (in radians). 

--------------------------------------------------------------------------------
（注：TODO）

math.acos (x)
返回x（弧度）的反余弦值。 


--------------------------------------------------------------------------------

math.asin (x)
Returns the arc sine of x (in radians). 

--------------------------------------------------------------------------------
（注：TODO）

math.asin (x)
返回x（弧度）的反正弦值。 


--------------------------------------------------------------------------------

math.atan (x)
Returns the arc tangent of x (in radians). 

--------------------------------------------------------------------------------
（注：TODO）

math.atan (x)
返回x（弧度）的反正切值。 


--------------------------------------------------------------------------------

math.atan2 (y, x)
Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.) 


--------------------------------------------------------------------------------
（注：TODO）

math.atan2 (y, x)
返回y/x（弧度）的反正切值，但用两个参数的正负号找到结果的象限。（它也能正确地处理x为0的情况。） 



--------------------------------------------------------------------------------

math.ceil (x)
Returns the smallest integer larger than or equal to x. 

--------------------------------------------------------------------------------

math.ceil (x)
返回大于等于x的最小整数。


--------------------------------------------------------------------------------

math.cos (x)
Returns the cosine of x (assumed to be in radians). 

--------------------------------------------------------------------------------

math.cos (x)
返回x的余弦（假设以弧度为单位）。


--------------------------------------------------------------------------------

math.cosh (x)
Returns the hyperbolic cosine of x. 

--------------------------------------------------------------------------------

math.cosh (x)
返回x的双曲余弦。


--------------------------------------------------------------------------------

math.deg (x)
Returns the angle x (given in radians) in degrees. 

--------------------------------------------------------------------------------

math.deg (x)
返回角度x（以弧度为单位）为角度值。


--------------------------------------------------------------------------------

math.exp (x)
Returns the value ex. 

--------------------------------------------------------------------------------

math.exp (x)
返回值e^x


--------------------------------------------------------------------------------

math.floor (x)
Returns the largest integer smaller than or equal to x. 

--------------------------------------------------------------------------------

math.floor (x)
返回小于等于x的最大整数。 


--------------------------------------------------------------------------------

math.fmod (x, y)
Returns the remainder of the division of x by y that rounds the quotient towards zero. 

--------------------------------------------------------------------------------

math.fmod (x, y)
Returns the remainder of the division of x by y that rounds the quotient towards zero. 
返回x除于y的余数使商偏向于0。


--------------------------------------------------------------------------------

math.frexp (x)
Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero). 

--------------------------------------------------------------------------------

math.frexp (x)
返回满足x = m*2^e的m和e，e是一个整数且绝对值m在范围[0.5, 1)（或者当x为0时m为0）


--------------------------------------------------------------------------------

math.huge
The value HUGE_VAL, a value larger than or equal to any other numerical value. 

--------------------------------------------------------------------------------

math.huge
值HUGE_VAL，一个大于等于任意数字值。 


--------------------------------------------------------------------------------

math.ldexp (m, e)
Returns m2e (e should be an integer). 

--------------------------------------------------------------------------------

math.ldexp (m, e)
返回m*2^e（e应该为一个整数）


--------------------------------------------------------------------------------

math.log (x)
Returns the natural logarithm of x. 

--------------------------------------------------------------------------------

math.log (x)
返回x的自然对数。


--------------------------------------------------------------------------------

math.log10 (x)
Returns the base-10 logarithm of x. 

--------------------------------------------------------------------------------

math.log10 (x)
返回以10为底x的对数


--------------------------------------------------------------------------------

math.max (x, ・・・)
Returns the maximum value among its arguments. 

--------------------------------------------------------------------------------

math.max (x, ・・・)
返回参数中的最大值。


--------------------------------------------------------------------------------

math.min (x, ・・・)
Returns the minimum value among its arguments. 

--------------------------------------------------------------------------------

math.min (x, ・・・)
返回参数中的最小值。


--------------------------------------------------------------------------------

math.modf (x)
Returns two numbers, the integral part of x and the fractional part of x. 

--------------------------------------------------------------------------------

math.modf (x)
返回两个数，x的整数部分和x的分数部分。


--------------------------------------------------------------------------------

math.pi
The value of pi. 

--------------------------------------------------------------------------------

math.pi
圆周率的值


--------------------------------------------------------------------------------

math.pow (x, y)
Returns xy. (You can also use the expression x^y to compute this value.) 

--------------------------------------------------------------------------------

math.pow (x, y)
返回x的y次方。（你也可以使用表达式x^y计算这个值）


--------------------------------------------------------------------------------

math.rad (x)
Returns the angle x (given in degrees) in radians. 

--------------------------------------------------------------------------------

math.rad (x)
返回角度x（以度数为单位）的弧度值。


--------------------------------------------------------------------------------

math.random ([m [, n]])
This function is an interface to the simple pseudo-random generator function rand provided by ANSI C. (No guarantees can be given for its statistical properties.) 

When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n]. 

--------------------------------------------------------------------------------
（注：TODO）

math.random ([m [, n]])
该函数是ANSI C提供的简单的伪随机产生器函数rand的接口。（不担保其统计特性。） 

当不带参数调用时，返回[0,1)区间内的一致的伪随机实数。当带一个整数m调用时，返回[1, m]区间内的一致的伪随机实数。当带两个整数m和n调用时，返回[m, n]区间内的一致的伪随机实数。 



--------------------------------------------------------------------------------

math.randomseed (x)
Sets x as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers. 


--------------------------------------------------------------------------------

math.randomseed (x)
设置x为伪随机数生成器的“种子”：相同的种子产生相同的数字序列。


--------------------------------------------------------------------------------

math.sin (x)
Returns the sine of x (assumed to be in radians). 

--------------------------------------------------------------------------------

math.sin (x)
返回x的正弦（假设以弧度为单位）


--------------------------------------------------------------------------------

math.sinh (x)
Returns the hyperbolic sine of x. 

--------------------------------------------------------------------------------

math.sinh (x)
返回x的双曲正弦


--------------------------------------------------------------------------------

math.sqrt (x)
Returns the square root of x. (You can also use the expression x^0.5 to compute this value.) 

--------------------------------------------------------------------------------

math.sqrt (x)
返回x的开方根。（你也可以使用表达式x^0.5计算此值）


--------------------------------------------------------------------------------

math.tan (x)
Returns the tangent of x (assumed to be in radians). 

--------------------------------------------------------------------------------

math.tan (x)
返回x的正切（假设以弧度为单位）

--------------------------------------------------------------------------------

math.tanh (x)
Returns the hyperbolic tangent of x. 

--------------------------------------------------------------------------------

math.tanh (x)
返回x的双曲正切。











5.7 - Input and Output Facilities
The I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file descriptors. 

When using implicit file descriptors, all operations are supplied by table io. When using explicit file descriptors, the operation io.open returns a file descriptor and then all operations are supplied as methods of the file descriptor. 

The table io also provides three predefined file descriptors with their usual meanings from C: io.stdin, io.stdout, and io.stderr. The I/O library never closes these files. 

Unless otherwise stated, all I/O functions return nil on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from nil on success. 


5.7 - 输入输出工具
输入输出库提供两种不同操作文件的风格。
第一种是隐式文件描述符；有操作默认输入文件和默认输出文件的操作，以及所有输入输出操作作用于这些默认文件之上。
第二种风格是使用显式文件描述符。
当使用隐式文件描述符时，所有操作由表io提供。
当使用显式文件描述符时，操作io.open返回一个文件描述符，并且所有操作会作为这个文件描述符的方法来提供。
表io也提供三个带有C的普遍意义的预定义文件描述符：io.stdin，io.stdout和io.stderr。
输入输出库从不关闭这些文件。
除了特别说明，所有输入输出库在失败时返回nil（外加作为第二结果的错误信息和一个作为第三结果的依赖系统的错误码），成功时则返回非nil的值。


--------------------------------------------------------------------------------

io.close ([file])
Equivalent to file:close(). Without a file, closes the default output file. 

--------------------------------------------------------------------------------

io.close ([file])
等效于file:close()。
不指定file时，关闭默认的输出文件。 

--------------------------------------------------------------------------------

io.flush ()
Equivalent to file:flush over the default output file. 

--------------------------------------------------------------------------------

io.flush ()
等效于对默认输出文件执行file:flush 

--------------------------------------------------------------------------------

io.input ([file])
When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file. 

In case of errors this function raises the error, instead of returning an error code. 

--------------------------------------------------------------------------------
（注：TODO）

io.input ([file])
用文件名调用时，它打开该命名文件（以文本模式），并设置其句柄为缺省的输入文件。用文件句柄调用时，它只是设置该文件句柄为缺省的输入文件。不带参数调用时，它返回当前的缺省的输入文件。 

在错误的情况下，该函数抛出错误而不是返回错误代码。 



--------------------------------------------------------------------------------

io.lines ([filename])
Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction 

     for line in io.lines(filename) do body end

will iterate over all lines of the file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file. 

The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends. 

--------------------------------------------------------------------------------
（注：TODO）

io.lines ([filename])
以读取模式打开给定的文件名并返回一个迭代函数，每次调用会返回来自文件的新行。因此，结构 

     for line in io.lines(filename) do body end

会迭代文件的所有行。当迭代函数监测到文件结尾时，返回nil（以结束循环）并自动关闭文件。 

调用io.lines()（不带参数）等价于io.input():lines()；即迭代缺省输入文件的所有行。该情况下当循环结束时不会关闭文件。 



--------------------------------------------------------------------------------

io.open (filename [, mode])
This function opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message. 

The mode string can be any of the following: 

"r": read mode (the default); 
"w": write mode; 
"a": append mode; 
"r+": update mode, all previous data is preserved; 
"w+": update mode, all previous data is erased; 
"a+": append update mode, previous data is preserved, writing is only allowed at the end of file. 
The mode string can also have a 'b' at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function fopen. 


--------------------------------------------------------------------------------

io.open (filename [, mode])
这个函数以字符串mode所指定的模式打开一个文件。
它返回一个新的文件句柄，如果出错则返回nil外加一个错误信息。
模式字符串可以是下列任意：
"r": 读模式（默认）； 
"w": 写模式；
"a": 追加模式；
"r+": 更新模式，所有以前的数据被保留；
"w+": 更新模式，所有以前的数据被删除； 
"a+": 追加更新模式，以前的数据被保留,只允许在文件结尾写. 
模式字符串可以在结束加上'b'，某些系统需要用二进制模式打开文件。
这个字符串正好就是标准C函数fopen所用的。


--------------------------------------------------------------------------------

io.output ([file])
Similar to io.input, but operates over the default output file. 


--------------------------------------------------------------------------------

io.output ([file])
类似于io.input，但操作在默认的输出文件。


--------------------------------------------------------------------------------

io.popen (prog [, mode])
Starts program prog in a separated process and returns a file handle that you can use to read data from this program (if mode is "r", the default) or to write data to this program (if mode is "w"). 

This function is system dependent and is not available on all platforms. 

--------------------------------------------------------------------------------

io.popen (prog [, mode])
以一个单独地进程启动程序prog并且返回一个文件句柄，你可以用它从这个程序中读取数据
（如果模式为"r"，缺省下），或者写数据到程序（如果模式为"w"）。
这个函数依赖于系统，不是所有平台都可用。

--------------------------------------------------------------------------------

io.read (・・・)
Equivalent to io.input():read. 

--------------------------------------------------------------------------------

io.read (・・・)
等效于io.input():read. 


--------------------------------------------------------------------------------

io.tmpfile ()
Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends. 

--------------------------------------------------------------------------------

io.tmpfile ()
返回一个临时文件的句柄。
这个文件以update模式打开并且在程序结束时自动删除。


--------------------------------------------------------------------------------

io.type (obj)
Checks whether obj is a valid file handle. Returns the string "file" if obj is an open file handle, "closed file" if obj is a closed file handle, or nil if obj is not a file handle. 

--------------------------------------------------------------------------------

io.type (obj)
检查obj是否合法的文件句柄。
如果obj是一个打开的文件句柄则返回字符串"file"，如果obj是关闭的文件句柄则返回"closed file"，如果obj不是一个文件句柄则返回nil。


--------------------------------------------------------------------------------

io.write (・・・)
Equivalent to io.output():write. 

--------------------------------------------------------------------------------

io.write (・・・)
等效于io.output():write. 


--------------------------------------------------------------------------------

file:close ()
Closes file. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen. 


--------------------------------------------------------------------------------

file:close ()
关闭文件。
注意当他们的句柄被垃圾回收时，文件会被自动关闭，但这会花费一段不可预测的时间才会发生。

--------------------------------------------------------------------------------

file:flush ()
Saves any written data to file. 

--------------------------------------------------------------------------------

file:flush ()
保存所有写的数据到文件。

--------------------------------------------------------------------------------

file:lines ()
Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction 

     for line in file:lines() do body end

will iterate over all lines of the file. (Unlike io.lines, this function does not close the file when the loop ends.) 

--------------------------------------------------------------------------------
file:lines ()
返回一个迭代器函数，每次调用它，返回文件的一个新行。
因此，结构
for line in file:lines() do body end
将迭代文件的所有行。
（不同于io.lines，这个函数不会在循环结束时关闭文件）


--------------------------------------------------------------------------------

file:read (・・・)
Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below). 

The available formats are 

"*n": reads a number; this is the only format that returns a number instead of a string. 
"*a": reads the whole file, starting at the current position. On end of file, it returns the empty string. 
"*l": reads the next line (skipping the end of line), returning nil on end of file. This is the default format. 
number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file. 

--------------------------------------------------------------------------------
（注：TODO）

file:read (・・・)
依照给定格式读取文件file，该格式制定要读取什么。对于每种格式，该函数返回读取得字符串（或数字），或者如果不能读取指定格式的数据则返回nil。当不带格式调用时，它用读取整个下一行的缺省格式（见下面）。 

可用格式是 

"*n": 读取一个数字；这是返回数字而非字符串的唯一格式。 
"*a": 从当前位置开始读取整个文件。在文件结尾时返回空串。 
"*l": 读取下一行（跳过行尾），在文件结尾时返回nil。这是缺省格式。 
number: 读取字符串直到该数量的字符串，在文件结尾时返回nil。如果数字是0，它什么也不读并返回空串，或在文件结尾时返回nil。 


--------------------------------------------------------------------------------

file:seek ([whence] [, offset])
Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence, as follows: 

"set": base is position 0 (beginning of the file); 
"cur": base is current position; 
"end": base is end of file; 
In case of success, function seek returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns nil, plus a string describing the error. 

The default value for whence is "cur", and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek("set") sets the position to the beginning of the file (and returns 0); and the call file:seek("end") sets the position to the end of the file, and returns its size. 

--------------------------------------------------------------------------------
（注：TODO）

file:seek ([whence] [, offset])
设置和获取由文件开头开始量度的文件位置，目标位置由offset加字符串whence指定的基点给出。如下： 

"set": 基点是位置0（文件开头）； 
"cur": 基点是当前位置； 
"end": 基点是文件结尾； 
成功返回由文件开头开始亮度以字节为单位的最终文件位置。失败则返回nil以及一个描述错误的字符串。 

whence的缺省值是"cur"，offset是0。因此调用file:seek()返回当前文件位置而不改变它；调用file:seek("set")设置位置到文件开头（并返回0）；调用file:seek("end")设置位置到文件结尾，并返回其尺寸。 




--------------------------------------------------------------------------------

file:setvbuf (mode [, size])
Sets the buffering mode for an output file. There are three available modes: 

"no": no buffering; the result of any output operation appears immediately. 
"full": full buffering; output operation is performed only when the buffer is full (or when you explicitly flush the file (see io.flush)). 
"line": line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device). 
For the last two cases, size specifies the size of the buffer, in bytes. The default is an appropriate size. 

--------------------------------------------------------------------------------
（注：TODO）

file:setvbuf (mode [, size])
设置输出文件的缓冲模式。有三种可用模式： 

"no": 无缓冲；任何输出操作的结果立刻出现。 
"full": 完全缓冲；只在缓冲区满时（或者当你显式flush文件（见io.flush））执行输出操作。 
"line": 行缓冲；缓冲输出直到输出了换行或有来自某些特定文件（例如终端设备）的任何输入。 
对于最后两种情况，size指定缓冲区大小，以字节为单位。缺省是个适当的大小。 




--------------------------------------------------------------------------------

file:write (・・・)
Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write. 

--------------------------------------------------------------------------------
（注：TODO）

file:write (・・・)
将每个参数的值写入file。参数必须是字符串或数字。要写其他值，在write之前使用tostring或string.format。 





5.8 - Operating System Facilities
This library is implemented through table os. 


5.8 - 操作系统工具
这个库通过表os实现

--------------------------------------------------------------------------------

os.clock ()
Returns an approximation of the amount in seconds of CPU time used by the program. 

--------------------------------------------------------------------------------

os.clock ()
返回一个程序所用CPU时间秒数的近似值。


--------------------------------------------------------------------------------

os.date ([format [, time]])
Returns a string or a table containing date and time, formatted according to the given string format. 

If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time. 

If format starts with '!', then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string "*t", then date returns a table with the following fields: year (four digits), month (1--12), day (1--31), hour (0--23), min (0--59), sec (0--61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean). 

If format is not "*t", then date returns the date as a string, formatted according to the same rules as the C function strftime. 

When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date("%c")). 

--------------------------------------------------------------------------------

os.date ([format [, time]])
返回一个包含日期和时间的字符串或表，根据所给字符串格式进行格式化。
如果参数time给定，这就是要被格式化的时间（参考os.time函数关于这个值的描述）。
否则，date格式化当前时间。
如果格式以'!'开始，那么日期以协调世界时（注：即UTC）方式格式化。
在这个可选字符后面，如果格式是字符串"*t"，那么日期返回带有以下域的一个表：
year（四位数字），month（1到12）,day（1到31）,hour（0到23），min（0到59），sec（0到61），wday（星期，星期日为1），yday（一年内第几日），以及isdst（夏令时标志，一个布尔型）
如果格式不是"*t"，那么date返回一个和C函数strftime相同的规则格式化的日期字符串，
当不带参数调用，date返回一个含义依赖于宿主系统和在当前语言环境的合理日期和时间（即，os.date()等效于os.date("%c")）。


--------------------------------------------------------------------------------

os.difftime (t2, t1)
Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1. 


--------------------------------------------------------------------------------

os.difftime (t2, t1)
返回从事件t1到时间t2的秒数。
在POSIX，Windows，和一些其它系统，这个值就是t2-t1。

--------------------------------------------------------------------------------

os.execute ([command])
This function is equivalent to the C function system. It passes command to be executed by an operating system shell. It returns a status code, which is system-dependent. If command is absent, then it returns nonzero if a shell is available and zero otherwise. 

--------------------------------------------------------------------------------

os.execute ([command])
这个函数等效于C函数system。
它传递command被操作系统shell执行。
它返回一个依赖系统的状态值。
如果没有指定command，它在shell可用时返回非0值，否则返回0。


--------------------------------------------------------------------------------

os.exit ([code])
Calls the C function exit, with an optional code, to terminate the host program. The default value for code is the success code. 

--------------------------------------------------------------------------------

os.exit ([code])
调用C函数exit，带有一个可选的code，以结束宿主程序。code的默认值是表示成功的代码。

--------------------------------------------------------------------------------

os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined. 

--------------------------------------------------------------------------------

os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined. 
返回进程环境变量变量varname的值，如果这个变量没有定义则返回nil。

--------------------------------------------------------------------------------

os.remove (filename)
Deletes the file or directory with the given name. Directories must be empty to be removed. If this function fails, it returns nil, plus a string describing the error. 

--------------------------------------------------------------------------------

os.remove (filename)
删除所给名称的文件或目录。
目录必须为空才可删除。
如果这个函数失败。它返回nil，外加一个描述错误的字符串。


--------------------------------------------------------------------------------

os.rename (oldname, newname)
Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error. 

--------------------------------------------------------------------------------

os.rename (oldname, newname)
重命名文件或目录的名称oldname为newname。
如果这个函数失败，它返回nil，外加一个描述错误的字符串。


--------------------------------------------------------------------------------

os.setlocale (locale [, category])
Sets the current locale of the program. locale is a string specifying a locale; category is an optional string describing which category to change: "all", "collate", "ctype", "monetary", "numeric", or "time"; the default category is "all". The function returns the name of the new locale, or nil if the request cannot be honored. 

If locale is the empty string, the current locale is set to an implementation-defined native locale. If locale is the string "C", the current locale is set to the standard C locale. 

When called with nil as the first argument, this function only returns the name of the current locale for the given category. 

--------------------------------------------------------------------------------

os.setlocale (locale [, category])
设置当前程序的本地环境。
locale是一个指定本地环境的字符串；category是一个描述哪些分类被改变的可选字符串："all", "collate", "ctype", "monetary", "numeric", or "time"；
缺省分类为"all"。
函数返回新的本地环境的名称，如果请求未被兑现则返回nil。
如果本地环境是空字符串，当前本地环境被设置为一种由实现定义的原生本地环境。
如果local是字符串"C"，当前本地环境设置为标准C本地环境。
当第一参数为nil调用时，这个函数只会返回所给分类下的当前本地环境的名称。


--------------------------------------------------------------------------------

os.time ([table])
Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour, min, sec, and isdst (for a description of these fields, see the os.date function). 

The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the "epoch"). In other systems, the meaning is not specified, and the number returned by time can be used only as an argument to date and difftime. 

--------------------------------------------------------------------------------

os.time ([table])
当不带参数时调用则返回当前时间，否则是一个被所给表指定的代表日期和时间一个时间值。
这个表必须拥有域year, month, 和day, 以及可能有的域hour, min, sec 以及isdst（对于这些域的描述，参考os.date函数）。
返回值是一个数，其含义依赖于你的系统。
在POSIX, Windows, 以及其它一些系统，这个数是从某个给定的开始时间算起的秒数（“纪元”）。在其它系统，这个意思并不规范，并且返回的表示时间的数只是作为一个传给date和difftime的参数。


--------------------------------------------------------------------------------

os.tmpname ()
Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed. 

On some systems (POSIX), this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it). 

When possible, you may prefer to use io.tmpfile, which automatically removes the file when the program ends. 


--------------------------------------------------------------------------------

os.tmpname ()
返回一个带文件名的字符串，可用于一个临时文件。
文件必须在使用前显式打开并且在不再需要的时候显式删除。
在一些系统（POSIX），这个函数还创建一个带有那个名称的文件，以避免安全风险。
（其它人可能在获得名称和创建文件之间的时间内创建带错误权限的文件。）
你仍必须打开该文件以使用它并且删除它（就算你没有用它）。
如果可以用，你可能更倾向于用io.tmpfile，它会在程序结束的时候自动删除临时文件。





5.9 - The Debug Library
This library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: they can be very slow. Moreover, several of these functions violate some assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside or that userdata metatables cannot be changed by Lua code) and therefore can compromise otherwise secure code. 

All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread. 



5.9 - 调试库
这个库提供Lua程序的调试界面工具。
用这个库时应该尽量小心。
这里提供的函数应该仅仅用于调试和相关的任务，例如性能剖析。
请避免像普通的编程工具那样滥用它们：它们可能会变得非常慢。
此外，这几个函数破坏关于Lua代码部分的假设（例如，函数的局部变量不能在外部访问，或者userdata的元表不能被Lua代码修改），并因此可能会危及其它安全的代码。
这个库的所有函数在debug表中提供
所有跨线程的函数带有一个可选的第一参数，允许传入需要操作的线程。
默认总是当前线程。

--------------------------------------------------------------------------------

debug.debug ()
Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution. 

Note that commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables. 

--------------------------------------------------------------------------------
（注：TODO）

debug.debug ()
进入同用户的交互模式，运行用户输入的每个字符串。使用简单的命令和其他调试设备，用户能够检查全局和局部变量，改变它们的值，计算表达式，等等。只含有单词cont的行终止该函数，这样调用者继续它的执行。 

注意，debug.debug的命令不是任何函数的内部词汇，因此没有对本地变量的直接访问。 


--------------------------------------------------------------------------------

debug.getfenv (o)
Returns the environment of object o. 

--------------------------------------------------------------------------------

debug.getfenv (o)
返回对象o的环境表。


--------------------------------------------------------------------------------

debug.gethook ([thread])
Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function). 

--------------------------------------------------------------------------------

debug.gethook ([thread])
返回线程的当前钩子设置，有三个值：当前钩子函数，当前钩子掩码，以及当前钩子数目（对应debug.sethook函数的设置）。


--------------------------------------------------------------------------------

debug.getinfo ([thread,] function [, what])
Returns a table with information about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil. 

The returned table can contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option 'f' adds a field named func with the function itself. If present, the option 'L' adds a field named activelines with the table of valid lines. 

For instance, the expression debug.getinfo(1,"n").name returns a table with a name for the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function. 

--------------------------------------------------------------------------------

debug.getinfo ([thread,] function [, what])
返回关于一个函数的带信息的表。
你可以直接指定函数，或者给定一个代表函数运行于所给线程的调用堆栈的function层的数作为函数的值：
层0是当前函数（getinfo自身）；层1是调用getinfo的函数；如此类推。
如果function是一个大于激活函数个数的数，那么getinfo返回nil。
返回的表可能包含所有lua_getinfo所返回的域，根据描述要填充哪些域的字符串what。
what缺省是获取所有可用信息，除了合法行的表以外。
如果存在，选项'f'添加一个值为function自身的名叫func的域。
如果存在，选项'L'添加值为包含合法行的表的名叫acivelines的域。
例如，表达式debug.getinfo(1,"n").name返回一个当前函数的带有name名称（？）的一个表，如果一个合理的名称可以被找到，则表达式debug.getinfo(print)会返回一个带有关于print函数的所有可用信息的表

--------------------------------------------------------------------------------

debug.getlocal ([thread,] level, local)
This function returns the name and the value of the local variable with index local of the function at level level of the stack. (The first parameter or local variable has index 1, and so on, until the last active local variable.) The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.) 

Variable names starting with '(' (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals). 

--------------------------------------------------------------------------------

debug.getlocal ([thread,] level, local)
这个函数返回名称以及带索引local的在堆栈level层的局部变量的值。
（第一个参数或局部变量索引为1，如此类推，直到最后激活的局部变量）
如果参数索引处没有局部变量，这个函数返回空，并且在一层范围以外调用时引生一个错误。
（你可以调用debug.getinfo去检查level是否合法。）
变量名以'('（左括号）开始表示内部变量（循环控制变量，临时变量，和C函数局部变量）

--------------------------------------------------------------------------------

debug.getmetatable (object)
Returns the metatable of the given object or nil if it does not have a metatable. 

--------------------------------------------------------------------------------

debug.getmetatable (object)
返回参数对象的元表，如果没有元表则返回空。 

--------------------------------------------------------------------------------

debug.getregistry ()
Returns the registry table (see §3.5). 

--------------------------------------------------------------------------------

debug.getregistry ()
返回注册表(参考§3.5). 

--------------------------------------------------------------------------------

debug.getupvalue (func, up)

This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. 

--------------------------------------------------------------------------------

debug.getupvalue (func, up)
这个函数返回名称以及函数func的上的带索引upvalue的值。
如果指定的索引没有upvalue的话，这个函数返回空值。

--------------------------------------------------------------------------------
debug.setfenv (object, table)

Sets the environment of the given object to the given table. Returns object. 

--------------------------------------------------------------------------------

debug.setfenv (对象, 表)

设置所给对象的环境到给定的表中。
返回对象. 

--------------------------------------------------------------------------------

debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning: 

"c": the hook is called every time Lua calls a function; 
"r": the hook is called every time Lua returns from a function; 
"l": the hook is called every time Lua enters a new line of code. 
With a count different from zero, the hook is called after every count instructions. 

When called without arguments, debug.sethook turns off the hook. 

When the hook is called, its first parameter is a string describing the event that has triggered its call: "call", "return" (or "tail return", when simulating a return from a tail call), "line", and "count". For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function), unless the event is "tail return". In this case, Lua is only simulating the return, and a call to getinfo will return invalid data. 

--------------------------------------------------------------------------------

debug.sethook ([thread,] hook, mask [, count])
把所给函数设置为钩子。
字符串mask和数count描述钩子何时被调用。
字符串mask可以拥有以下字符，带有所给出的意思：

"c": 钩子在每次Lua调用一个函数时调用； 
"r": 钩子在每次Lua从一个函数返回时调用； 
"l": 钩子在每次Lua进入新的一行代码时调用。
当count不等于0时，钩子在每次count到达（？）时被调用。 
当不带参数调用时，debug.sethook关闭钩子。
当钩子被调用时，它第一个参数是一个描述触发这次调用的事件的字符串："call","return"(或"tail return"，当模拟一次从尾调用产生的返回），"line"，以及"count"。
对于行事件，钩子还可以获得新的行数作为其第二参数。
在钩子内部，你可以调用带层2的getinfo去获得更多关于运行中函数的信息（0层是getinfo函数，1层是钩子函数），除非事件是“尾返回”。
在这种情况下，Lua只是模拟返回，而调用getinfo将返回非法的数据。


--------------------------------------------------------------------------------

debug.setlocal ([thread,] level, local, value)
This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable. 

--------------------------------------------------------------------------------

debug.setlocal ([thread,] level, local, value)
这个函数把值value赋给在索引local处的局部变量给堆栈中处于level层的函数。
如果所给的索引处没有局部变量，则函数返回nil，并且当调用超出范围的一个层时引发一个错误。
（你可以调用getinfo去检查level是否合法。）
否则，它返回局部变量的名称。


--------------------------------------------------------------------------------

debug.setmetatable (object, table)
Sets the metatable for the given object to the given table (which can be nil). 

--------------------------------------------------------------------------------

debug.setmetatable (object, table)
设置所给对象的元表为所给的表（可以为nil）。 

--------------------------------------------------------------------------------

debug.setupvalue (func, up, value)
This function assigns the value value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue. 

--------------------------------------------------------------------------------

debug.setupvalue (func, up, value)
这个函数把值value赋给函数func以上带索引up的upvalue。
如果所给索引上没有upvalue则这个函数返回nil。
否则，返回upvalue的名称。


--------------------------------------------------------------------------------

debug.traceback ([thread,] [message] [, level])
Returns a string with a traceback of the call stack. An optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback). 

--------------------------------------------------------------------------------

debug.traceback ([thread,] [message] [, level])
返回一个带有调用堆栈的traceback信息的字符串。
一个可选的message字符串追加在traceback信息的开头。
一个可选的level数指明从哪一层开始traceback
（默认是1，该函数调用的traceback）



















6 - Lua Stand-alone
Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a stand-alone language. An interpreter for Lua as a stand-alone language, called simply lua, is provided with the standard distribution. The stand-alone interpreter includes all standard libraries, including the debug library. Its usage is: 

     lua [options] [script [args]]

The options are: 

-e stat: executes string stat; 
-l mod: "requires" mod; 
-i: enters interactive mode after running script; 
-v: prints version information; 
--: stops handling options; 
-: executes stdin as a file and stops handling options. 
After handling its options, lua runs the given script, passing to it the given args as string arguments. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise. 

Before running any argument, the interpreter checks for an environment variable LUA_INIT. If its format is @filename, then lua executes the file. Otherwise, lua executes the string itself. 

All options are handled in order, except -i. For instance, an invocation like 

     $ lua -e'a=1' -e 'print(a)' script.lua

will first set a to 1, then print the value of a (which is '1'), and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.) 

Before starting to run the script, lua collects all arguments in the command line in a global table called arg. The script name is stored at index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call 

     $ lua -la b.lua t1 t2

the interpreter first runs the file a.lua, then creates a table 

     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }

and finally runs the file b.lua. The script is called with arg[1], arg[2], ・・・ as arguments; it can also access these arguments with the vararg expression '...'. 

In interactive mode, if you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt. 

If the global variable _PROMPT contains a string, then its value is used as the prompt. Similarly, if the global variable _PROMPT2 contains a string, its value is used as the secondary prompt (issued during incomplete statements). Therefore, both prompts can be changed directly on the command line or in any Lua programs by assigning to _PROMPT. See the next example: 

     $ lua -e"_PROMPT='myprompt> '" -i

(The outer pair of quotes is for the shell, the inner pair is for Lua.) Note the use of -i to enter interactive mode; otherwise, the program would just end silently right after the assignment to _PROMPT. 

To allow the use of Lua as a script interpreter in Unix systems, the stand-alone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in 

     #!/usr/local/bin/lua

(Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then 

     #!/usr/bin/env lua

is a more portable solution.) 



6 - Lua的独立程序
 虽然Lua被设计为一种嵌入C宿主程序的扩展语言，但它还常常被当作一种独立运行的语言来使用。
Lua解释器作为一种可独立运行的语言，简称lua，作为标准发布的一部分提供。
独立运行的解释器包含所有标准库，包含调试库。
它的用法是
lua [options] [script [args]]
其中options选项包括
-e stat: 执行字符串stat； 
-l mod: 包含库mod； 
-i: 在执行脚本后进入交互模式； 
-v: 打印版本信息； 
--: 停止处理选项； 
-: 把stdin作为文件来执行，并且停止处理选项。
在处理选项后，lua运行所给的脚本，传递所给的args作为它的字符串参数。
当不带参数调用时，如果标准输入（stdin）是一个终端则lua的行为如lua -v -i那样，否则如lua -那样。
在执行任何参数前，解释器会检查环境变量LUA_INIT。
如果它的格式是@文件名，那么lua执行该文件。否则，lua执行字符串本身。
所有选项都是按顺序处理，除了-i以外。
例如，像这样的调用
$ lua -e'a=1' -e 'print(a)' script.lua
首先把a设置为1，然后打印a的值（即'1'），最后不带参数地运行文件script.lua。
（这里$是shell命令提示符。你的提示可能会不同。）
在开始运行脚本前，Lua把命令行中的所有参数收集到一个叫arg的全局表中。
脚本名存储在索引0，脚本名后的第一个参数为索引1，如此类推。
任何在脚本名前的参数（即解释器名和选项参数）以负索引排列。
例如在如下调用中：
$ lua -la b.lua t1 t2
解析器首先运行文件a.lua，然后创建一个表
arg = { [-2] = "lua", [-1] = "-la",
	 [0] = "b.lua",
	 [1] = "t1", [2] = "t2" }
最后运行文件b.lua。该脚本以arg[1]，arg[2]，・・・作为参数来调用；
它也可以通过变长参数表达式'...'访问这些参数。
在交互模式下，如果你写了一个不完整的语句，解释器通过发出不同的提示符等待它的完成。
如果全局变量_PROMPT包含一个字符串，那么它的值用作提示符。
同样，如果全局变量_PROMPT2包含一个字符串，那么它的值是用作第二提示符（在出现不完整语句时发出）。
因此，可以通过给_PROMPT赋值而直接在命令行中或者任何Lua程序中改变这两个提示符。
看下面的例子：
$ lua -e"_PROMPT='myprompt> '" -i
（外引号对用于shell，内引号对用于lua。）
注意使用-i进入交互模式；否则程序在赋值给_PROMPT后就安静地结束。
为了让Lua在Unix系统中作为脚本解释器来使用，如果以#开始，独立运行解释器会跳过chunk块的第一行。
因此，Lua脚本可以通过使用chmod +x和#!形式变成可执行程序，例如
#!/usr/local/bin/lua
（当然，Lua解释器的位置可能和你机器的不同。如果lua在你的PATH中，那么
#!/usr/bin/env lua
是一种更方便的解决方案。） 















7 - Incompatibilities with the Previous Version
Here we list the incompatibilities that you may find when moving a program from Lua 5.0 to Lua 5.1. You can avoid most of the incompatibilities compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the next version of Lua. 



7 - 与以前版本的不兼容 
在这里，我们列举不兼容性，你会在把lua 5.0的代码迁移到Lua 5.1时发现。
你可以通过使用合适的选项（见文件luaconf.h）编译Lua来避免大部分不兼容性。
然而，所有这些兼容性选项都将在Lua的下一个版本中删除。







7.1 - Changes in the Language
The vararg system changed from the pseudo-argument arg with a table with the extra arguments to the vararg expression. (See compile-time option LUA_COMPAT_VARARG in luaconf.h.) 
There was a subtle change in the scope of the implicit variables of the for statement and for the repeat statement. 
The long string/long comment syntax ([[string]]) does not allow nesting. You can use the new syntax ([=[string]=]) in these cases. (See compile-time option LUA_COMPAT_LSTR in luaconf.h.) 



7.1 - 语言的改变 
变长参数系统从带额外参数的表的伪参数arg改为变长参数表达式。
（见luaconf.h的编译期选项LUA_COMPAT_VARARG。）
在for语句的显式变量作用域和repeat语句中存在微妙的改变。
长字符串和长注释语法（[[string]]）不允许嵌套。
在这些场合下你可以使用新的语法（[=[string]=]）。
（见luaconf.h的编译期选项LUA_COMPAT_LSTR。）





7.2 - Changes in the Libraries
Function string.gfind was renamed string.gmatch. (See compile-time option LUA_COMPAT_GFIND in luaconf.h.) 
When string.gsub is called with a function as its third argument, whenever this function returns nil or false the replacement string is the whole match, instead of the empty string. 
Function table.setn was deprecated. Function table.getn corresponds to the new length operator (#); use the operator instead of the function. (See compile-time option LUA_COMPAT_GETN in luaconf.h.) 
Function loadlib was renamed package.loadlib. (See compile-time option LUA_COMPAT_LOADLIB in luaconf.h.) 
Function math.mod was renamed math.fmod. (See compile-time option LUA_COMPAT_MOD in luaconf.h.) 
Functions table.foreach and table.foreachi are deprecated. You can use a for loop with pairs or ipairs instead. 
There were substantial changes in function require due to the new module system. However, the new behavior is mostly compatible with the old, but require gets the path from package.path instead of from LUA_PATH. 
Function collectgarbage has different arguments. Function gcinfo is deprecated; use collectgarbage("count") instead. 



7.2 - 库的改变 
函数string.gfind更名为string.gmatch。
（见luaconf.h的编译期选项LUA_COMPAT_GFIND。） 
当string.gsub以一个函数作为它的第三参数，不管这个函数返回nil还是false，替换字符串都是完全匹配，而不是一个空字符串。
函数table.setn被废弃。
函数table.getn对应新的长度运算符（#）；使用运算符取代函数。
（见luaconf.h的编译期选项LUA_COMPAT_GETN。） 
函数loadlib更名为package.loadlib。
（见luaconf.h的编译期选项LUA_COMPAT_LOADLIB。） 
函数math.mod更名为math.fmod。
（见luaconf.h的编译期选项LUA_COMPAT_MOD。） 
函数table.foreach和table.foreachi已废弃。
你可以使用带pairs或ipairs的for循环代替它们。
由于新的模块系统，require函数有很大的改变。
然而，新的行为与旧的大部分兼容，但require得到的是来自package.path的路径而不是来自LUA_PATH的路径。 
函数collectgarbage有不同的参数。
函数gcinfo已经废弃；用collectgarbage("count")代替。 




7.3 - Changes in the API
The luaopen_* functions (to open libraries) cannot be called directly, like a regular C function. They must be called through Lua, like a Lua function. 
Function lua_open was replaced by lua_newstate to allow the user to set a memory-allocation function. You can use luaL_newstate from the standard library to create a state with a standard allocation function (based on realloc). 
Functions luaL_getn and luaL_setn (from the auxiliary library) are deprecated. Use lua_objlen instead of luaL_getn and nothing instead of luaL_setn. 
Function luaL_openlib was replaced by luaL_register. 
Function luaL_checkudata now throws an error when the given value is not a userdata of the expected type. (In Lua 5.0 it returned NULL.) 



7.3 - API的改变
luaopen_*函数（用于打开库）想普通的C函数那样不能直接调用。
它们必须通过Lua来调用，就像一个Lua函数。
函数lua_open改为lua_newstate，允许用户设置一个内存分配函数。
你可以使用标准库的luaL_newstate创建具有一个具有标准分配函数的状态（基于realloc）。 
函数luaL_getn和luaL_setn（出自辅助库）已废弃。
使用lua_objlen代替luaL_getn，没有函数代替luaL_setn。 
函数luaL_openlib改为luaL_register。
当给定的值不是所期望类型的userdata时，函数luaL_checkudata现在会抛出一个错误。（在Lua 5.0中它返回NULL。）














8 - The Complete Syntax of Lua
Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.) 


	chunk ::= {stat [`;′]} [laststat [`;′]]

	block ::= chunk

	stat ::=  varlist `=′ explist | 
		 functioncall | 
		 do block end | 
		 while exp do block end | 
		 repeat block until exp | 
		 if exp then block {elseif exp then block} [else block] end | 
		 for Name `=′ exp `,′ exp [`,′ exp] do block end | 
		 for namelist in explist do block end | 
		 function funcname funcbody | 
		 local function Name funcbody | 
		 local namelist [`=′ explist] 

	laststat ::= return [explist] | break

	funcname ::= Name {`.′ Name} [`:′ Name]

	varlist ::= var {`,′ var}

	var ::=  Name | prefixexp `[′ exp `]′ | prefixexp `.′ Name 

	namelist ::= Name {`,′ Name}

	explist ::= {exp `,′} exp

	exp ::=  nil | false | true | Number | String | `...′ | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `(′ exp `)′

	functioncall ::=  prefixexp args | prefixexp `:′ Name args 

	args ::=  `(′ [explist] `)′ | tableconstructor | String 

	function ::= function funcbody

	funcbody ::= `(′ [parlist] `)′ block end

	parlist ::= namelist [`,′ `...′] | `...′

	tableconstructor ::= `{′ [fieldlist] `}′

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `[′ exp `]′ `=′ exp | Name `=′ exp | exp

	fieldsep ::= `,′ | `;′

	binop ::= `+′ | `-′ | `*′ | `/′ | `^′ | `%′ | `..′ | 
		 `<′ | `<=′ | `>′ | `>=′ | `==′ | `~=′ | 
		 and | or

	unop ::= `-′ | not | `#′



8 - Lua的完整语法 
这里是以扩展巴科斯范式（扩展BNF）描述的Lua完整语法。
（它不描述操作的优先级。）
chunk ::= {stat [';']} [laststat [';']]
block ::= chunk
stat ::=  varlist '=' explist | 
	 functioncall | 
	 do block end | 
	 while exp do block end | 
	 repeat block until exp | 
	 if exp then block {elseif exp then block} [else block] end | 
	 for Name '=' exp ',' exp [',' exp] do block end | 
	 for namelist in explist do block end | 
	 function funcname funcbody | 
	 local function Name funcbody | 
	 local namelist ['=' explist] 
laststat ::= return [explist] | break
funcname ::= Name {'.' Name} [':' Name]
varlist ::= var {',' var}
var ::=  Name | prefixexp '[' exp ']' | prefixexp '.' Name 
namelist ::= Name {',' Name}
explist ::= {exp ','} exp
exp ::=  nil | false | true | Number | String | '...' | function | 
	 prefixexp | tableconstructor | exp binop exp | unop exp 
prefixexp ::= var | functioncall | '(' exp ')'
functioncall ::=  prefixexp args | prefixexp ':' Name args 
args ::=  '(' [explist] ')' | tableconstructor | String 
function ::= function funcbody
funcbody ::= '(' [parlist] ')' block end
parlist ::= namelist [',' '...'] | '...'
tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= '[' exp ']' '=' exp | Name '=' exp | exp
fieldsep ::= ',' | ';'
binop ::= '+' | '-' | '*' | '/' | '^' | '%' | '..' | 
	 '<' | '<=' | '>' | '>=' | '==' | '~=' | 
	 and | or
unop ::= '-' | not | '#'




--------------------------------------------------------------------------------
Last update: Mon Aug 18 13:25:46 BRT 2008 

--------------------------------------------------------------------------------
（注：TODO）

最近更新：巴西利亚时间2008/08/18 周一 13:25:46 










