io.close ([file])
Equivalent to file:close(). Without a file, closes the default output file. 

--------------------------------------------------------------------------------

io.close ([file])
等效于file:close()。
不指定file时，关闭默认的输出文件。 

--------------------------------------------------------------------------------

io.flush ()
Equivalent to file:flush over the default output file. 

--------------------------------------------------------------------------------

io.flush ()
等效于对默认输出文件执行file:flush 

--------------------------------------------------------------------------------

io.input ([file])
When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file. 

In case of errors this function raises the error, instead of returning an error code. 

--------------------------------------------------------------------------------
（注：TODO）

io.input ([file])
用文件名调用时，它打开该命名文件（以文本模式），并设置其句柄为缺省的输入文件。用文件句柄调用时，它只是设置该文件句柄为缺省的输入文件。不带参数调用时，它返回当前的缺省的输入文件。 

在错误的情况下，该函数抛出错误而不是返回错误代码。 



--------------------------------------------------------------------------------

io.lines ([filename])
Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction 

     for line in io.lines(filename) do body end

will iterate over all lines of the file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file. 

The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends. 

--------------------------------------------------------------------------------
（注：TODO）

io.lines ([filename])
以读取模式打开给定的文件名并返回一个迭代函数，每次调用会返回来自文件的新行。因此，结构 

     for line in io.lines(filename) do body end

会迭代文件的所有行。当迭代函数监测到文件结尾时，返回nil（以结束循环）并自动关闭文件。 

调用io.lines()（不带参数）等价于io.input():lines()；即迭代缺省输入文件的所有行。该情况下当循环结束时不会关闭文件。 



--------------------------------------------------------------------------------

io.open (filename [, mode])
This function opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message. 

The mode string can be any of the following: 

"r": read mode (the default); 
"w": write mode; 
"a": append mode; 
"r+": update mode, all previous data is preserved; 
"w+": update mode, all previous data is erased; 
"a+": append update mode, previous data is preserved, writing is only allowed at the end of file. 
The mode string can also have a 'b' at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function fopen. 


--------------------------------------------------------------------------------

io.open (filename [, mode])
这个函数以字符串mode所指定的模式打开一个文件。
它返回一个新的文件句柄，如果出错则返回nil外加一个错误信息。
模式字符串可以是下列任意：
"r": 读模式（默认）； 
"w": 写模式；
"a": 追加模式；
"r+": 更新模式，所有以前的数据被保留；
"w+": 更新模式，所有以前的数据被删除； 
"a+": 追加更新模式，以前的数据被保留,只允许在文件结尾写. 
模式字符串可以在结束加上'b'，某些系统需要用二进制模式打开文件。
这个字符串正好就是标准C函数fopen所用的。


--------------------------------------------------------------------------------

io.output ([file])
Similar to io.input, but operates over the default output file. 


--------------------------------------------------------------------------------

io.output ([file])
类似于io.input，但操作在默认的输出文件。


--------------------------------------------------------------------------------

io.popen (prog [, mode])
Starts program prog in a separated process and returns a file handle that you can use to read data from this program (if mode is "r", the default) or to write data to this program (if mode is "w"). 

This function is system dependent and is not available on all platforms. 

--------------------------------------------------------------------------------

io.popen (prog [, mode])
以一个单独地进程启动程序prog并且返回一个文件句柄，你可以用它从这个程序中读取数据
（如果模式为"r"，缺省下），或者写数据到程序（如果模式为"w"）。
这个函数依赖于系统，不是所有平台都可用。

--------------------------------------------------------------------------------

io.read (・・・)
Equivalent to io.input():read. 

--------------------------------------------------------------------------------

io.read (・・・)
等效于io.input():read. 


--------------------------------------------------------------------------------

io.tmpfile ()
Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends. 

--------------------------------------------------------------------------------

io.tmpfile ()
返回一个临时文件的句柄。
这个文件以update模式打开并且在程序结束时自动删除。


--------------------------------------------------------------------------------

io.type (obj)
Checks whether obj is a valid file handle. Returns the string "file" if obj is an open file handle, "closed file" if obj is a closed file handle, or nil if obj is not a file handle. 

--------------------------------------------------------------------------------

io.type (obj)
检查obj是否合法的文件句柄。
如果obj是一个打开的文件句柄则返回字符串"file"，如果obj是关闭的文件句柄则返回"closed file"，如果obj不是一个文件句柄则返回nil。


--------------------------------------------------------------------------------

io.write (・・・)
Equivalent to io.output():write. 

--------------------------------------------------------------------------------

io.write (・・・)
等效于io.output():write. 


--------------------------------------------------------------------------------

file:close ()
Closes file. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen. 


--------------------------------------------------------------------------------

file:close ()
关闭文件。
注意当他们的句柄被垃圾回收时，文件会被自动关闭，但这会花费一段不可预测的时间才会发生。

--------------------------------------------------------------------------------

file:flush ()
Saves any written data to file. 

--------------------------------------------------------------------------------

file:flush ()
保存所有写的数据到文件。

--------------------------------------------------------------------------------

file:lines ()
Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction 

     for line in file:lines() do body end

will iterate over all lines of the file. (Unlike io.lines, this function does not close the file when the loop ends.) 

--------------------------------------------------------------------------------
file:lines ()
返回一个迭代器函数，每次调用它，返回文件的一个新行。
因此，结构
for line in file:lines() do body end
将迭代文件的所有行。
（不同于io.lines，这个函数不会在循环结束时关闭文件）


--------------------------------------------------------------------------------

file:read (・・・)
Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below). 

The available formats are 

"*n": reads a number; this is the only format that returns a number instead of a string. 
"*a": reads the whole file, starting at the current position. On end of file, it returns the empty string. 
"*l": reads the next line (skipping the end of line), returning nil on end of file. This is the default format. 
number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file. 

--------------------------------------------------------------------------------
（注：TODO）

file:read (・・・)
依照给定格式读取文件file，该格式制定要读取什么。对于每种格式，该函数返回读取得字符串（或数字），或者如果不能读取指定格式的数据则返回nil。当不带格式调用时，它用读取整个下一行的缺省格式（见下面）。 

可用格式是 

"*n": 读取一个数字；这是返回数字而非字符串的唯一格式。 
"*a": 从当前位置开始读取整个文件。在文件结尾时返回空串。 
"*l": 读取下一行（跳过行尾），在文件结尾时返回nil。这是缺省格式。 
number: 读取字符串直到该数量的字符串，在文件结尾时返回nil。如果数字是0，它什么也不读并返回空串，或在文件结尾时返回nil。 


--------------------------------------------------------------------------------

file:seek ([whence] [, offset])
Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence, as follows: 

"set": base is position 0 (beginning of the file); 
"cur": base is current position; 
"end": base is end of file; 
In case of success, function seek returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns nil, plus a string describing the error. 

The default value for whence is "cur", and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek("set") sets the position to the beginning of the file (and returns 0); and the call file:seek("end") sets the position to the end of the file, and returns its size. 

--------------------------------------------------------------------------------
（注：TODO）

file:seek ([whence] [, offset])
设置和获取由文件开头开始量度的文件位置，目标位置由offset加字符串whence指定的基点给出。如下： 

"set": 基点是位置0（文件开头）； 
"cur": 基点是当前位置； 
"end": 基点是文件结尾； 
成功返回由文件开头开始亮度以字节为单位的最终文件位置。失败则返回nil以及一个描述错误的字符串。 

whence的缺省值是"cur"，offset是0。因此调用file:seek()返回当前文件位置而不改变它；调用file:seek("set")设置位置到文件开头（并返回0）；调用file:seek("end")设置位置到文件结尾，并返回其尺寸。 




--------------------------------------------------------------------------------

file:setvbuf (mode [, size])
Sets the buffering mode for an output file. There are three available modes: 

"no": no buffering; the result of any output operation appears immediately. 
"full": full buffering; output operation is performed only when the buffer is full (or when you explicitly flush the file (see io.flush)). 
"line": line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device). 
For the last two cases, size specifies the size of the buffer, in bytes. The default is an appropriate size. 

--------------------------------------------------------------------------------
（注：TODO）

file:setvbuf (mode [, size])
设置输出文件的缓冲模式。有三种可用模式： 

"no": 无缓冲；任何输出操作的结果立刻出现。 
"full": 完全缓冲；只在缓冲区满时（或者当你显式flush文件（见io.flush））执行输出操作。 
"line": 行缓冲；缓冲输出直到输出了换行或有来自某些特定文件（例如终端设备）的任何输入。 
对于最后两种情况，size指定缓冲区大小，以字节为单位。缺省是个适当的大小。 




--------------------------------------------------------------------------------

file:write (・・・)
Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write. 

--------------------------------------------------------------------------------
（注：TODO）

file:write (・・・)
将每个参数的值写入file。参数必须是字符串或数字。要写其他值，在write之前使用tostring或string.format。 





5.8 - Operating System Facilities
This library is implemented through table os. 


5.8 - 操作系统工具
这个库通过表os实现

--------------------------------------------------------------------------------

os.clock ()
Returns an approximation of the amount in seconds of CPU time used by the program. 

--------------------------------------------------------------------------------

os.clock ()
返回一个程序所用CPU时间秒数的近似值。


--------------------------------------------------------------------------------

os.date ([format [, time]])
Returns a string or a table containing date and time, formatted according to the given string format. 

If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time. 

If format starts with '!', then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string "*t", then date returns a table with the following fields: year (four digits), month (1--12), day (1--31), hour (0--23), min (0--59), sec (0--61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean). 

If format is not "*t", then date returns the date as a string, formatted according to the same rules as the C function strftime. 

When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date("%c")). 

--------------------------------------------------------------------------------

os.date ([format [, time]])
返回一个包含日期和时间的字符串或表，根据所给字符串格式进行格式化。
如果参数time给定，这就是要被格式化的时间（参考os.time函数关于这个值的描述）。
否则，date格式化当前时间。
如果格式以'!'开始，那么日期以协调世界时（注：即UTC）方式格式化。
在这个可选字符后面，如果格式是字符串"*t"，那么日期返回带有以下域的一个表：
year（四位数字），month（1到12）,day（1到31）,hour（0到23），min（0到59），sec（0到61），wday（星期，星期日为1），yday（一年内第几日），以及isdst（夏令时标志，一个布尔型）
如果格式不是"*t"，那么date返回一个和C函数strftime相同的规则格式化的日期字符串，
当不带参数调用，date返回一个含义依赖于宿主系统和在当前语言环境的合理日期和时间（即，os.date()等效于os.date("%c")）。


--------------------------------------------------------------------------------

os.difftime (t2, t1)
Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1. 


--------------------------------------------------------------------------------

os.difftime (t2, t1)
返回从事件t1到时间t2的秒数。
在POSIX，Windows，和一些其它系统，这个值就是t2-t1。

--------------------------------------------------------------------------------

os.execute ([command])
This function is equivalent to the C function system. It passes command to be executed by an operating system shell. It returns a status code, which is system-dependent. If command is absent, then it returns nonzero if a shell is available and zero otherwise. 

--------------------------------------------------------------------------------

os.execute ([command])
这个函数等效于C函数system。
它传递command被操作系统shell执行。
它返回一个依赖系统的状态值。
如果没有指定command，它在shell可用时返回非0值，否则返回0。


--------------------------------------------------------------------------------

os.exit ([code])
Calls the C function exit, with an optional code, to terminate the host program. The default value for code is the success code. 

--------------------------------------------------------------------------------

os.exit ([code])
调用C函数exit，带有一个可选的code，以结束宿主程序。code的默认值是表示成功的代码。

--------------------------------------------------------------------------------

os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined. 

--------------------------------------------------------------------------------

os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined. 
返回进程环境变量变量varname的值，如果这个变量没有定义则返回nil。

--------------------------------------------------------------------------------

os.remove (filename)
Deletes the file or directory with the given name. Directories must be empty to be removed. If this function fails, it returns nil, plus a string describing the error. 

--------------------------------------------------------------------------------

os.remove (filename)
删除所给名称的文件或目录。
目录必须为空才可删除。
如果这个函数失败。它返回nil，外加一个描述错误的字符串。


--------------------------------------------------------------------------------

os.rename (oldname, newname)
Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error. 

--------------------------------------------------------------------------------

os.rename (oldname, newname)
重命名文件或目录的名称oldname为newname。
如果这个函数失败，它返回nil，外加一个描述错误的字符串。


--------------------------------------------------------------------------------

os.setlocale (locale [, category])
Sets the current locale of the program. locale is a string specifying a locale; category is an optional string describing which category to change: "all", "collate", "ctype", "monetary", "numeric", or "time"; the default category is "all". The function returns the name of the new locale, or nil if the request cannot be honored. 

If locale is the empty string, the current locale is set to an implementation-defined native locale. If locale is the string "C", the current locale is set to the standard C locale. 

When called with nil as the first argument, this function only returns the name of the current locale for the given category. 

--------------------------------------------------------------------------------

os.setlocale (locale [, category])
设置当前程序的本地环境。
locale是一个指定本地环境的字符串；category是一个描述哪些分类被改变的可选字符串："all", "collate", "ctype", "monetary", "numeric", or "time"；
缺省分类为"all"。
函数返回新的本地环境的名称，如果请求未被兑现则返回nil。
如果本地环境是空字符串，当前本地环境被设置为一种由实现定义的原生本地环境。
如果local是字符串"C"，当前本地环境设置为标准C本地环境。
当第一参数为nil调用时，这个函数只会返回所给分类下的当前本地环境的名称。


--------------------------------------------------------------------------------

os.time ([table])
Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour, min, sec, and isdst (for a description of these fields, see the os.date function). 

The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the "epoch"). In other systems, the meaning is not specified, and the number returned by time can be used only as an argument to date and difftime. 

--------------------------------------------------------------------------------

os.time ([table])
当不带参数时调用则返回当前时间，否则是一个被所给表指定的代表日期和时间一个时间值。
这个表必须拥有域year, month, 和day, 以及可能有的域hour, min, sec 以及isdst（对于这些域的描述，参考os.date函数）。
返回值是一个数，其含义依赖于你的系统。
在POSIX, Windows, 以及其它一些系统，这个数是从某个给定的开始时间算起的秒数（“纪元”）。在其它系统，这个意思并不规范，并且返回的表示时间的数只是作为一个传给date和difftime的参数。


--------------------------------------------------------------------------------

os.tmpname ()
Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed. 

On some systems (POSIX), this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it). 

When possible, you may prefer to use io.tmpfile, which automatically removes the file when the program ends. 


--------------------------------------------------------------------------------

os.tmpname ()
返回一个带文件名的字符串，可用于一个临时文件。
文件必须在使用前显式打开并且在不再需要的时候显式删除。
在一些系统（POSIX），这个函数还创建一个带有那个名称的文件，以避免安全风险。
（其它人可能在获得名称和创建文件之间的时间内创建带错误权限的文件。）
你仍必须打开该文件以使用它并且删除它（就算你没有用它）。
如果可以用，你可能更倾向于用io.tmpfile，它会在程序结束的时候自动删除临时文件。





5.9 - The Debug Library
This library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: they can be very slow. Moreover, several of these functions violate some assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside or that userdata metatables cannot be changed by Lua code) and therefore can compromise otherwise secure code. 

All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread. 



5.9 - 调试库
这个库提供Lua程序的调试界面工具。
用这个库时应该尽量小心。
这里提供的函数应该仅仅用于调试和相关的任务，例如性能剖析。
请避免像普通的编程工具那样滥用它们：它们可能会变得非常慢。
此外，这几个函数破坏关于Lua代码部分的假设（例如，函数的局部变量不能在外部访问，或者userdata的元表不能被Lua代码修改），并因此可能会危及其它安全的代码。
这个库的所有函数在debug表中提供
所有跨线程的函数带有一个可选的第一参数，允许传入需要操作的线程。
默认总是当前线程。

--------------------------------------------------------------------------------

debug.debug ()
Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution. 

Note that commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables. 

--------------------------------------------------------------------------------
（注：TODO）

debug.debug ()
进入同用户的交互模式，运行用户输入的每个字符串。使用简单的命令和其他调试设备，用户能够检查全局和局部变量，改变它们的值，计算表达式，等等。只含有单词cont的行终止该函数，这样调用者继续它的执行。 

注意，debug.debug的命令不是任何函数的内部词汇，因此没有对本地变量的直接访问。 


--------------------------------------------------------------------------------

debug.getfenv (o)
Returns the environment of object o. 

--------------------------------------------------------------------------------

debug.getfenv (o)
返回对象o的环境表。


--------------------------------------------------------------------------------

debug.gethook ([thread])
Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function). 

--------------------------------------------------------------------------------

debug.gethook ([thread])
返回线程的当前钩子设置，有三个值：当前钩子函数，当前钩子掩码，以及当前钩子数目（对应debug.sethook函数的设置）。


--------------------------------------------------------------------------------

debug.getinfo ([thread,] function [, what])
Returns a table with information about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil. 

The returned table can contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option 'f' adds a field named func with the function itself. If present, the option 'L' adds a field named activelines with the table of valid lines. 

For instance, the expression debug.getinfo(1,"n").name returns a table with a name for the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function. 

--------------------------------------------------------------------------------

debug.getinfo ([thread,] function [, what])
返回关于一个函数的带信息的表。
你可以直接指定函数，或者给定一个代表函数运行于所给线程的调用堆栈的function层的数作为函数的值：
层0是当前函数（getinfo自身）；层1是调用getinfo的函数；如此类推。
如果function是一个大于激活函数个数的数，那么getinfo返回nil。
返回的表可能包含所有lua_getinfo所返回的域，根据描述要填充哪些域的字符串what。
what缺省是获取所有可用信息，除了合法行的表以外。
如果存在，选项'f'添加一个值为function自身的名叫func的域。
如果存在，选项'L'添加值为包含合法行的表的名叫acivelines的域。
例如，表达式debug.getinfo(1,"n").name返回一个当前函数的带有name名称（？）的一个表，如果一个合理的名称可以被找到，则表达式debug.getinfo(print)会返回一个带有关于print函数的所有可用信息的表

--------------------------------------------------------------------------------

debug.getlocal ([thread,] level, local)
This function returns the name and the value of the local variable with index local of the function at level level of the stack. (The first parameter or local variable has index 1, and so on, until the last active local variable.) The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.) 

Variable names starting with '(' (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals). 

--------------------------------------------------------------------------------

debug.getlocal ([thread,] level, local)
这个函数返回名称以及带索引local的在堆栈level层的局部变量的值。
（第一个参数或局部变量索引为1，如此类推，直到最后激活的局部变量）
如果参数索引处没有局部变量，这个函数返回空，并且在一层范围以外调用时引生一个错误。
（你可以调用debug.getinfo去检查level是否合法。）
变量名以'('（左括号）开始表示内部变量（循环控制变量，临时变量，和C函数局部变量）

--------------------------------------------------------------------------------

debug.getmetatable (object)
Returns the metatable of the given object or nil if it does not have a metatable. 

--------------------------------------------------------------------------------

debug.getmetatable (object)
返回参数对象的元表，如果没有元表则返回空。 

--------------------------------------------------------------------------------

debug.getregistry ()
Returns the registry table (see §3.5). 

--------------------------------------------------------------------------------

debug.getregistry ()
返回注册表(参考§3.5). 

--------------------------------------------------------------------------------

debug.getupvalue (func, up)

This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. 

--------------------------------------------------------------------------------

debug.getupvalue (func, up)
这个函数返回名称以及函数func的上的带索引upvalue的值。
如果指定的索引没有upvalue的话，这个函数返回空值。

--------------------------------------------------------------------------------
debug.setfenv (object, table)

Sets the environment of the given object to the given table. Returns object. 

--------------------------------------------------------------------------------

debug.setfenv (对象, 表)

设置所给对象的环境到给定的表中。
返回对象. 

--------------------------------------------------------------------------------

debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning: 

"c": the hook is called every time Lua calls a function; 
"r": the hook is called every time Lua returns from a function; 
"l": the hook is called every time Lua enters a new line of code. 
With a count different from zero, the hook is called after every count instructions. 

When called without arguments, debug.sethook turns off the hook. 

When the hook is called, its first parameter is a string describing the event that has triggered its call: "call", "return" (or "tail return", when simulating a return from a tail call), "line", and "count". For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function), unless the event is "tail return". In this case, Lua is only simulating the return, and a call to getinfo will return invalid data. 

--------------------------------------------------------------------------------

debug.sethook ([thread,] hook, mask [, count])
把所给函数设置为钩子。
字符串mask和数count描述钩子何时被调用。
字符串mask可以拥有以下字符，带有所给出的意思：

"c": 钩子在每次Lua调用一个函数时调用； 
"r": 钩子在每次Lua从一个函数返回时调用； 
"l": 钩子在每次Lua进入新的一行代码时调用。
当count不等于0时，钩子在每次count到达（？）时被调用。 
当不带参数调用时，debug.sethook关闭钩子。
当钩子被调用时，它第一个参数是一个描述触发这次调用的事件的字符串："call","return"(或"tail return"，当模拟一次从尾调用产生的返回），"line"，以及"count"。
对于行事件，钩子还可以获得新的行数作为其第二参数。
在钩子内部，你可以调用带层2的getinfo去获得更多关于运行中函数的信息（0层是getinfo函数，1层是钩子函数），除非事件是“尾返回”。
在这种情况下，Lua只是模拟返回，而调用getinfo将返回非法的数据。


--------------------------------------------------------------------------------

debug.setlocal ([thread,] level, local, value)
This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable. 

--------------------------------------------------------------------------------

debug.setlocal ([thread,] level, local, value)
这个函数把值value赋给在索引local处的局部变量给堆栈中处于level层的函数。
如果所给的索引处没有局部变量，则函数返回nil，并且当调用超出范围的一个层时引发一个错误。
（你可以调用getinfo去检查level是否合法。）
否则，它返回局部变量的名称。


--------------------------------------------------------------------------------

debug.setmetatable (object, table)
Sets the metatable for the given object to the given table (which can be nil). 

--------------------------------------------------------------------------------

debug.setmetatable (object, table)
设置所给对象的元表为所给的表（可以为nil）。 

--------------------------------------------------------------------------------

debug.setupvalue (func, up, value)
This function assigns the value value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue. 

--------------------------------------------------------------------------------

debug.setupvalue (func, up, value)
这个函数把值value赋给函数func以上带索引up的upvalue。
如果所给索引上没有upvalue则这个函数返回nil。
否则，返回upvalue的名称。


--------------------------------------------------------------------------------

debug.traceback ([thread,] [message] [, level])
Returns a string with a traceback of the call stack. An optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback). 

--------------------------------------------------------------------------------

debug.traceback ([thread,] [message] [, level])
返回一个带有调用堆栈的traceback信息的字符串。
一个可选的message字符串追加在traceback信息的开头。
一个可选的level数指明从哪一层开始traceback
（默认是1，该函数调用的traceback）



















6 - Lua Stand-alone
Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a stand-alone language. An interpreter for Lua as a stand-alone language, called simply lua, is provided with the standard distribution. The stand-alone interpreter includes all standard libraries, including the debug library. Its usage is: 

     lua [options] [script [args]]

The options are: 

-e stat: executes string stat; 
-l mod: "requires" mod; 
-i: enters interactive mode after running script; 
-v: prints version information; 
--: stops handling options; 
-: executes stdin as a file and stops handling options. 
After handling its options, lua runs the given script, passing to it the given args as string arguments. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise. 

Before running any argument, the interpreter checks for an environment variable LUA_INIT. If its format is @filename, then lua executes the file. Otherwise, lua executes the string itself. 

All options are handled in order, except -i. For instance, an invocation like 

     $ lua -e'a=1' -e 'print(a)' script.lua

will first set a to 1, then print the value of a (which is '1'), and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.) 

Before starting to run the script, lua collects all arguments in the command line in a global table called arg. The script name is stored at index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call 

     $ lua -la b.lua t1 t2

the interpreter first runs the file a.lua, then creates a table 

     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }

and finally runs the file b.lua. The script is called with arg[1], arg[2], ・・・ as arguments; it can also access these arguments with the vararg expression '...'. 

In interactive mode, if you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt. 

If the global variable _PROMPT contains a string, then its value is used as the prompt. Similarly, if the global variable _PROMPT2 contains a string, its value is used as the secondary prompt (issued during incomplete statements). Therefore, both prompts can be changed directly on the command line or in any Lua programs by assigning to _PROMPT. See the next example: 

     $ lua -e"_PROMPT='myprompt> '" -i

(The outer pair of quotes is for the shell, the inner pair is for Lua.) Note the use of -i to enter interactive mode; otherwise, the program would just end silently right after the assignment to _PROMPT. 

To allow the use of Lua as a script interpreter in Unix systems, the stand-alone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in 

     #!/usr/local/bin/lua

(Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then 

     #!/usr/bin/env lua

is a more portable solution.) 



6 - Lua的独立程序
 虽然Lua被设计为一种嵌入C宿主程序的扩展语言，但它还常常被当作一种独立运行的语言来使用。
Lua解释器作为一种可独立运行的语言，简称lua，作为标准发布的一部分提供。
独立运行的解释器包含所有标准库，包含调试库。
它的用法是
lua [options] [script [args]]
其中options选项包括
-e stat: 执行字符串stat； 
-l mod: 包含库mod； 
-i: 在执行脚本后进入交互模式； 
-v: 打印版本信息； 
--: 停止处理选项； 
-: 把stdin作为文件来执行，并且停止处理选项。
在处理选项后，lua运行所给的脚本，传递所给的args作为它的字符串参数。
当不带参数调用时，如果标准输入（stdin）是一个终端则lua的行为如lua -v -i那样，否则如lua -那样。
在执行任何参数前，解释器会检查环境变量LUA_INIT。
如果它的格式是@文件名，那么lua执行该文件。否则，lua执行字符串本身。
所有选项都是按顺序处理，除了-i以外。
例如，像这样的调用
$ lua -e'a=1' -e 'print(a)' script.lua
首先把a设置为1，然后打印a的值（即'1'），最后不带参数地运行文件script.lua。
（这里$是shell命令提示符。你的提示可能会不同。）
在开始运行脚本前，Lua把命令行中的所有参数收集到一个叫arg的全局表中。
脚本名存储在索引0，脚本名后的第一个参数为索引1，如此类推。
任何在脚本名前的参数（即解释器名和选项参数）以负索引排列。
例如在如下调用中：
$ lua -la b.lua t1 t2
解析器首先运行文件a.lua，然后创建一个表
arg = { [-2] = "lua", [-1] = "-la",
	 [0] = "b.lua",
	 [1] = "t1", [2] = "t2" }
最后运行文件b.lua。该脚本以arg[1]，arg[2]，・・・作为参数来调用；
它也可以通过变长参数表达式'...'访问这些参数。
在交互模式下，如果你写了一个不完整的语句，解释器通过发出不同的提示符等待它的完成。
如果全局变量_PROMPT包含一个字符串，那么它的值用作提示符。
同样，如果全局变量_PROMPT2包含一个字符串，那么它的值是用作第二提示符（在出现不完整语句时发出）。
因此，可以通过给_PROMPT赋值而直接在命令行中或者任何Lua程序中改变这两个提示符。
看下面的例子：
$ lua -e"_PROMPT='myprompt> '" -i
（外引号对用于shell，内引号对用于lua。）
注意使用-i进入交互模式；否则程序在赋值给_PROMPT后就安静地结束。
为了让Lua在Unix系统中作为脚本解释器来使用，如果以#开始，独立运行解释器会跳过chunk块的第一行。
因此，Lua脚本可以通过使用chmod +x和#!形式变成可执行程序，例如
#!/usr/local/bin/lua
（当然，Lua解释器的位置可能和你机器的不同。如果lua在你的PATH中，那么
#!/usr/bin/env lua
是一种更方便的解决方案。） 















7 - Incompatibilities with the Previous Version
Here we list the incompatibilities that you may find when moving a program from Lua 5.0 to Lua 5.1. You can avoid most of the incompatibilities compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the next version of Lua. 



7 - 与以前版本的不兼容 
在这里，我们列举不兼容性，你会在把lua 5.0的代码迁移到Lua 5.1时发现。
你可以通过使用合适的选项（见文件luaconf.h）编译Lua来避免大部分不兼容性。
然而，所有这些兼容性选项都将在Lua的下一个版本中删除。







7.1 - Changes in the Language
The vararg system changed from the pseudo-argument arg with a table with the extra arguments to the vararg expression. (See compile-time option LUA_COMPAT_VARARG in luaconf.h.) 
There was a subtle change in the scope of the implicit variables of the for statement and for the repeat statement. 
The long string/long comment syntax ([[string]]) does not allow nesting. You can use the new syntax ([=[string]=]) in these cases. (See compile-time option LUA_COMPAT_LSTR in luaconf.h.) 



7.1 - 语言的改变 
变长参数系统从带额外参数的表的伪参数arg改为变长参数表达式。
（见luaconf.h的编译期选项LUA_COMPAT_VARARG。）
在for语句的显式变量作用域和repeat语句中存在微妙的改变。
长字符串和长注释语法（[[string]]）不允许嵌套。
在这些场合下你可以使用新的语法（[=[string]=]）。
（见luaconf.h的编译期选项LUA_COMPAT_LSTR。）





7.2 - Changes in the Libraries
Function string.gfind was renamed string.gmatch. (See compile-time option LUA_COMPAT_GFIND in luaconf.h.) 
When string.gsub is called with a function as its third argument, whenever this function returns nil or false the replacement string is the whole match, instead of the empty string. 
Function table.setn was deprecated. Function table.getn corresponds to the new length operator (#); use the operator instead of the function. (See compile-time option LUA_COMPAT_GETN in luaconf.h.) 
Function loadlib was renamed package.loadlib. (See compile-time option LUA_COMPAT_LOADLIB in luaconf.h.) 
Function math.mod was renamed math.fmod. (See compile-time option LUA_COMPAT_MOD in luaconf.h.) 
Functions table.foreach and table.foreachi are deprecated. You can use a for loop with pairs or ipairs instead. 
There were substantial changes in function require due to the new module system. However, the new behavior is mostly compatible with the old, but require gets the path from package.path instead of from LUA_PATH. 
Function collectgarbage has different arguments. Function gcinfo is deprecated; use collectgarbage("count") instead. 



7.2 - 库的改变 
函数string.gfind更名为string.gmatch。
（见luaconf.h的编译期选项LUA_COMPAT_GFIND。） 
当string.gsub以一个函数作为它的第三参数，不管这个函数返回nil还是false，替换字符串都是完全匹配，而不是一个空字符串。
函数table.setn被废弃。
函数table.getn对应新的长度运算符（#）；使用运算符取代函数。
（见luaconf.h的编译期选项LUA_COMPAT_GETN。） 
函数loadlib更名为package.loadlib。
（见luaconf.h的编译期选项LUA_COMPAT_LOADLIB。） 
函数math.mod更名为math.fmod。
（见luaconf.h的编译期选项LUA_COMPAT_MOD。） 
函数table.foreach和table.foreachi已废弃。
你可以使用带pairs或ipairs的for循环代替它们。
由于新的模块系统，require函数有很大的改变。
然而，新的行为与旧的大部分兼容，但require得到的是来自package.path的路径而不是来自LUA_PATH的路径。 
函数collectgarbage有不同的参数。
函数gcinfo已经废弃；用collectgarbage("count")代替。 




7.3 - Changes in the API
The luaopen_* functions (to open libraries) cannot be called directly, like a regular C function. They must be called through Lua, like a Lua function. 
Function lua_open was replaced by lua_newstate to allow the user to set a memory-allocation function. You can use luaL_newstate from the standard library to create a state with a standard allocation function (based on realloc). 
Functions luaL_getn and luaL_setn (from the auxiliary library) are deprecated. Use lua_objlen instead of luaL_getn and nothing instead of luaL_setn. 
Function luaL_openlib was replaced by luaL_register. 
Function luaL_checkudata now throws an error when the given value is not a userdata of the expected type. (In Lua 5.0 it returned NULL.) 



7.3 - API的改变
luaopen_*函数（用于打开库）想普通的C函数那样不能直接调用。
它们必须通过Lua来调用，就像一个Lua函数。
函数lua_open改为lua_newstate，允许用户设置一个内存分配函数。
你可以使用标准库的luaL_newstate创建具有一个具有标准分配函数的状态（基于realloc）。 
函数luaL_getn和luaL_setn（出自辅助库）已废弃。
使用lua_objlen代替luaL_getn，没有函数代替luaL_setn。 
函数luaL_openlib改为luaL_register。
当给定的值不是所期望类型的userdata时，函数luaL_checkudata现在会抛出一个错误。（在Lua 5.0中它返回NULL。）














8 - The Complete Syntax of Lua
Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.) 


	chunk ::= {stat [`;′]} [laststat [`;′]]

	block ::= chunk

	stat ::=  varlist `=′ explist | 
		 functioncall | 
		 do block end | 
		 while exp do block end | 
		 repeat block until exp | 
		 if exp then block {elseif exp then block} [else block] end | 
		 for Name `=′ exp `,′ exp [`,′ exp] do block end | 
		 for namelist in explist do block end | 
		 function funcname funcbody | 
		 local function Name funcbody | 
		 local namelist [`=′ explist] 

	laststat ::= return [explist] | break

	funcname ::= Name {`.′ Name} [`:′ Name]

	varlist ::= var {`,′ var}

	var ::=  Name | prefixexp `[′ exp `]′ | prefixexp `.′ Name 

	namelist ::= Name {`,′ Name}

	explist ::= {exp `,′} exp

	exp ::=  nil | false | true | Number | String | `...′ | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `(′ exp `)′

	functioncall ::=  prefixexp args | prefixexp `:′ Name args 

	args ::=  `(′ [explist] `)′ | tableconstructor | String 

	function ::= function funcbody

	funcbody ::= `(′ [parlist] `)′ block end

	parlist ::= namelist [`,′ `...′] | `...′

	tableconstructor ::= `{′ [fieldlist] `}′

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `[′ exp `]′ `=′ exp | Name `=′ exp | exp

	fieldsep ::= `,′ | `;′

	binop ::= `+′ | `-′ | `*′ | `/′ | `^′ | `%′ | `..′ | 
		 `<′ | `<=′ | `>′ | `>=′ | `==′ | `~=′ | 
		 and | or

	unop ::= `-′ | not | `#′



8 - Lua的完整语法 
这里是以扩展巴科斯范式（扩展BNF）描述的Lua完整语法。
（它不描述操作的优先级。）
chunk ::= {stat [';']} [laststat [';']]
block ::= chunk
stat ::=  varlist '=' explist | 
	 functioncall | 
	 do block end | 
	 while exp do block end | 
	 repeat block until exp | 
	 if exp then block {elseif exp then block} [else block] end | 
	 for Name '=' exp ',' exp [',' exp] do block end | 
	 for namelist in explist do block end | 
	 function funcname funcbody | 
	 local function Name funcbody | 
	 local namelist ['=' explist] 
laststat ::= return [explist] | break
funcname ::= Name {'.' Name} [':' Name]
varlist ::= var {',' var}
var ::=  Name | prefixexp '[' exp ']' | prefixexp '.' Name 
namelist ::= Name {',' Name}
explist ::= {exp ','} exp
exp ::=  nil | false | true | Number | String | '...' | function | 
	 prefixexp | tableconstructor | exp binop exp | unop exp 
prefixexp ::= var | functioncall | '(' exp ')'
functioncall ::=  prefixexp args | prefixexp ':' Name args 
args ::=  '(' [explist] ')' | tableconstructor | String 
function ::= function funcbody
funcbody ::= '(' [parlist] ')' block end
parlist ::= namelist [',' '...'] | '...'
tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= '[' exp ']' '=' exp | Name '=' exp | exp
fieldsep ::= ',' | ';'
binop ::= '+' | '-' | '*' | '/' | '^' | '%' | '..' | 
	 '<' | '<=' | '>' | '>=' | '==' | '~=' | 
	 and | or
unop ::= '-' | not | '#'




--------------------------------------------------------------------------------
Last update: Mon Aug 18 13:25:46 BRT 2008 

--------------------------------------------------------------------------------
（注：TODO）

最近更新：巴西利亚时间2008/08/18 周一 13:25:46 

