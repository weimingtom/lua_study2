Lua 5.1 Reference Manual 
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes 
Copyright ? 2006-2008 Lua.org, PUC-Rio. Freely available under the terms of the Lua license. 

Lua 5.1参考手册
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
版权所有 2006-2008 Lua.org, PUC-Rio. 根据Lua许可证自由（免费）可用


contents ・ index 
目录 索引

1 - Introduction
1 - 简介

Lua is an extension programming language designed to support general procedural programming with data description facilities. It also offers good support for object-oriented programming, functional programming, and data-driven programming. Lua is intended to be used as a powerful, light-weight scripting language for any program that needs one. Lua is implemented as a library, written in clean C (that is, in the common subset of ANSI C and C++). 

Lua是一种为支持带数据描述功能的泛型过程式编程而设计的扩展编程语言。
它还提供对面向对象编程的良好支持，函数式编程，以及数据驱动编程。
Lua致力于成为一种强大和轻量级的脚本语言供任何需要它的程序使用。
Lua被实现为一个库，用纯C(即ANSI C和C++的公共子集)编写。

Being an extension language, Lua has no notion of a "main" program: it only works embedded in a host client, called the embedding program or simply the host. This host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework. The Lua distribution includes a sample host program called lua, which uses the Lua library to offer a complete, stand-alone Lua interpreter. 

作为一种扩展语言，Lua没有"main"程序的概念：它只是嵌入在称为嵌入式语言或者简称为宿主的宿主客户端中工作。
这个宿主程序可以调用函数去执行一段Lua代码，可以读写Lua变量，还可以注册C函数供Lua代码调用。
虽然使用了C函数，Lua可以被扩充，以应付广泛的不同领域，从而创建共享一个语法框架的可定制编程语言。
Lua发布版包含一个称为lua的示例宿主程序,使用Lua库去提供一个完整、可单独运行的Lua解析器。

Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, www.lua.org. 

Lua是自由（免费）软件，并且一般不作保证地提供，正如它的许可证所述。
在这个手册中所描述的实现可以在Lua的官方网站www.lua.org中找到。

Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, Programming in Lua (Second Edition). 

像其它参考手册那样，这个文档很多地方都很枯燥。
关于Lua设计背后的决策的讨论，请参考Lua官网上的技术文档。
关于Lua编程的详细介绍，参考Roberto的书，《Lua程序设计（第二版）》

2 - The Language
2 - 语言

This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean. 

这个部分描述词汇，语法，以及语义。
换而言之，这个部分描述那些符号是有效，它们如何可以组合，以及它们组合的含义。


The language constructs will be explained using the usual extended BNF notation, in which {a} means 0 or more a's, and [a] means an optional a. Non-terminals are shown like non-terminal, keywords are shown like kword, and other terminal symbols are shown like '='. The complete syntax of Lua can be found in §8 at the end of this manual. 

语言构造将解析通用扩展BNF表示法的使用，{a}表示0和更多a，[a]表示一个可选的a。
非最终符号表示为非最终符号（无黑体），关键词表示为kword（黑体），其他非终结符号表示为'='。
完整的Lua语法可以在本手册最后的第八章找到。


2.1 - Lexical Conventions
2.1 - 词法约定

Names (also called identifiers) in Lua can be any string of letters, digits, and underscores, not beginning with a digit. This coincides with the definition of names in most languages. (The definition of letter depends on the current locale: any character considered alphabetic by the current locale can be used in an identifier.) Identifiers are used to name variables and table fields. 

在Lua中，名称（也成为标识符）可以是任意字母，数字和下划线组成但不是以一个数字开头的字符串。
这正好和大多数语言的名称定义相符。
（这个字母的定义依赖于当前的本地环境：任何被当前本地环境当作字母的字符都可以被用于标识符）
标识符用于命名变量和表的域。

The following keywords are reserved and cannot be used as names: 

下面的关键词被保留，不可以用于名称：

    and       break     do        else      elseif
    end       false     for       function  if
    in        local     nil       not       or
    repeat    return    then      true      until     while

and（逻辑与） break（跳出循环）do（循环块开始）else（其它条件）elseif（其它条件判断）
end（循环、条件、闭包块结束）false（逻辑假） for（固定步长循环或迭代） 
function（闭包块开始）if（条件判断）
in（遍历）local（局部变量） nil（空） not（逻辑非）or（逻辑或）
repeat（条件假时循环） return（函数返回） then（条件块开始）true（逻辑真）
until（条件假循环判断）while（条件真时循环判断）


Lua is a case-sensitive language: and is a reserved word, but And and AND are two different, valid names. As a convention, names starting with an underscore followed by uppercase letters (such as _VERSION) are reserved for internal global variables used by Lua. 

Lua是大小写区分的语言：并且虽然作为保留字，但And和AND是两个与and不同的的词，也可以作为合法的名称。
作为一种约定，以下环线开头并且后面是全大写的名称（例如_VERSION）是被保留作为Lua的内部全局变量使用。

The following strings denote other tokens: 

下面的字符串表示其他标记：

+     -     *     /     %     ^     #
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]
;     :     ,     .     ..    ...


+（加）-（减或负号）*（乘）/（除）%（取模）^（指数幂）#（字符串或表长度）
==（相等）~=（不等）<=（小于等于）>=（大于等于）<（小于）>（大于）=（赋值）
(     )（小括号）{     }（大括号，表）[     ]（中括号，下标）
;（分号，分割语句）:（冒号，取对象成员）,（逗号）.（取表成员）..（字符串串联） ...（变长参数列表）

Literal strings can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '\a' (bell), '\b' (backspace), '\f' (form feed), '\n' (newline), '\r' (carriage return), '\t' (horizontal tab), '\v' (vertical tab), '\\' (backslash), '\"' (quotation mark [double quote]), and '\'' (apostrophe [single quote]). Moreover, a backslash followed by a real newline results in a newline in the string. A character in a string can also be specified by its numerical value using the escape sequence \ddd, where ddd is a sequence of up to three decimal digits. (Note that if a numerical escape is to be followed by a digit, it must be expressed using exactly three digits.) Strings in Lua can contain any 8-bit value, including embedded zeros, which can be specified as '\0'. 

字面值的字符串可以由匹配的单引号或双引号分隔，还可以包含下面的C风格转义字符序列：
'\a'（响铃），'\b'（退格），'\f'（表格回退），'\n'（换行），'\r'作为（回车），
'\t'（水平制表符），'\v'（垂直制表符），'\\'（反斜杠），'\"'（引号[双引号]），和'\''（单引号[单引号]）。
此外，反斜杠后的真实换行将在字符串中产生换行。
一个字符串中的字符，也可以用带转义序列\ddd的数值来指定，ddd是最多3个十进制数字的序列。
（注意，如果一个数值转义后面是一个数字，则它必须准确地使用三个数字表示）
在Lua中字符串可以包含任何8位数值，包括中间夹杂的零（注：区别于C风格的必须以\0结束而且前面不能包括\0的字符串），可以被指定为'\0'。（注：相比而言，Lua没有规定一定要以\0结束字符串）

Literal strings can also be defined using a long format enclosed by long brackets. We define an opening long bracket of level n as an opening square bracket followed by n equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as [[, an opening long bracket of level 1 is written as [=[, and so on. A closing long bracket is defined similarly; for instance, a closing long bracket of level 4 is written as ]====]. A long string starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. They can contain anything except a closing bracket of the proper level. 

字面值的字符串还可以使用一个长括号封闭的长格式来定义。
我们把一个n层的左长括号定义为一个左方括号，然后跟着另一个带相同n层的左方括号。
因此，一个0层左长括号写成[[，一个1层左长括号写成[=[，如此类推。
右长括号的定义类似；例如，一个4层右长括号写成]====]。
一个字符串以任意层的左长括号开始，以第一个出现的带相同层数的右长括号结束。
方括号内的字面值可以拆分为几行，不需要使用任何转义序列，忽略其他任何级别的长括号。
它们可以包含除了合适层数的右长括号以外的其它任意字符。



For convenience, when the opening long bracket is immediately followed by a newline, the newline is not included in the string. As an example, in a system using ASCII (in which 'a' is coded as 97, newline is coded as 10, and '1' is coded as 49), the five literal strings below denote the same string: 

     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]



为方便起见，当左长方括号后面立刻跟着一个换行时，这个换行不包括在字符串中。作为一个例子，在一个使用ASCII的系统中（其中'a'编码为97，换行编码为10，'1'编码为49），下面五个字符串字面值表示相同的字符串值：
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]



A numerical constant can be written with an optional decimal part and an optional decimal exponent. Lua also accepts integer hexadecimal constants, by prefixing them with 0x. Examples of valid numerical constants are 

     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56

一个数值常数可以写成一个可选的小数部分加上一个可选的十进制指数。Lua还接受十六进制整数常量，它们以0x作为前缀。合法数值常数的例子如下
3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56


A comment starts with a double hyphen (--) anywhere outside a string. If the text immediately after -- is not an opening long bracket, the comment is a short comment, which runs until the end of the line. Otherwise, it is a long comment, which runs until the corresponding closing long bracket. Long comments are frequently used to disable code temporarily. 

注释开始于字符串以外任何地方的一个双连字符（--）。如果--后紧跟着的文本不是一个左长方括号，这个注释就是一个短注释，它的注释直到行结束为止。否则，它是一个长注释，注释直到相应的右长方括号。长注释常常被用来暂时的代码禁用。








2.2 - Values and Types
Lua is a dynamically typed language. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type. 

2.2 - 值 and 类型
Lua是动态类型的语言。这意味着，变量没有类型，但值拥有。语言中没有类型定义。所有值携带它们自己的类型。



All values in Lua are first-class values. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results. 


Lua中所有值都是第一类值。这意味着所有的值都可以存储变量中，作为参数传递给其他函数，以及作为结果返回。





There are eight basic types in Lua: nil, boolean, number, string, function, userdata, thread, and table. Nil is the type of the value nil, whose main property is to be different from any other value; it usually represents the absence of a useful value. Boolean is the type of the values false and true. Both nil and false make a condition false; any other value makes it true. Number represents real (double-precision floating-point) numbers. (It is easy to build Lua interpreters that use other internal representations for numbers, such as single-precision float or long integers; see file luaconf.h.) String represents arrays of characters. Lua is 8-bit clean: strings can contain any 8-bit character, including embedded zeros ('\0') (see §2.1). 


Lua有八种基本类型：空型，布尔型，数型，字符串，函数，用户数据，线程和表。空型是nil的类型，其主要属性是不同于其它任何值，它通常代表缺少一个有用的值。布尔型是值false和true的类型。nil和false使条件为假；其他任何值都使条件为真。数型表示实数（双精度浮点数）。（在构建Lua解释器时很容易为数型值使用其他内部表示，例如单精度浮点数或者长整数。参考文件luaconf.h）字符串表示字符数组。Lua对8位字符是干净的：字符串可以包含任何8位字符，包括内嵌零（'\0'）（见§2.1）。







Lua can call (and manipulate) functions written in Lua and functions written in C (see §2.5.8). 

Lua中可以调用（和操纵）用lua编写的函数和用C编写的函数（见§2.5.8）。 



The type userdata is provided to allow arbitrary C data to be stored in Lua variables. This type corresponds to a block of raw memory and has no pre-defined operations in Lua, except assignment and identity test. However, by using metatables, the programmer can define operations for userdata values (see §2.8). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program. 

提供userdata类型，允许用户把任意C数据保存在Lua变量中。
此类型对应原始内存块并在lua中没有预定义的操作，除了赋值和唯一性检查。
但是，通过使用元表，程序员可以定义userdata值的操作（见§2.8）。
userdata值不能用Lua创建或修改，只能通过C API。
这保证了宿主程序所拥有数据的完整性。 





The type thread represents independent threads of execution and it is used to implement coroutines (see §2.11). Do not confuse Lua threads with operating-system threads. Lua supports coroutines on all systems, even those that do not support threads. 


线程类型代表可执行的独立线程，它用于实现协程（见§2.11）。
不要把Lua的线程和操作系统的线程混淆。 
Lua在所有系统上支持协程，即使在那些不支持线程的系统。




The type table implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any value (except nil). Tables can be heterogeneous; that is, they can contain values of all types (except nil). Tables are the sole data structuring mechanism in Lua; they can be used to represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing a.name as syntactic sugar for a["name"]. There are several convenient ways to create tables in Lua (see §2.5.7). 

表类型实现关联数组，即数组可以不仅仅用数字索引，还可以用任何值（除了nil）。
表可以是异构的，即它们可以包含所有类型的值（除了nil）。
表是在Lua中唯一的数据结构机制；它们可以被用于表示普通数组，符号表，集合，记录，图，树等。
为了表示记录，Lua使用域（字段）名作为一个索引。
语言通过提供a.name这种表示作为a["name"]的语法糖。
用Lua有几种简便方法可以创建表（见§2.5.7）。





Like indices, the value of a table field can be of any type (except nil). In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry methods (see §2.5.9). 

类似索引，表的字段值可以是任意类型（除了nil）。
特别地，因为函数是第一类值，表的字段可以包含函数。
因此，表也可以携带方法（见§2.5.9）。




Tables, functions, threads, and (full) userdata values are objects: variables do not actually contain these values, only references to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy. 

表，函数，线程和（完全）userdata值都是对象：变量实际上并不包含这些值，只是包含他们的引用。
赋值，参数传递，函数返回总是对其值的引用的操作，这些操作并不暗示有任何类型副本的存在。




The library function type returns a string describing the type of a given value. 

库函数type返回一个描述所给值的类型的字符串。






2.2.1 - Coercion
Lua provides automatic conversion between string and number values at run time. Any arithmetic operation applied to a string tries to convert this string to a number, following the usual conversion rules. Conversely, whenever a number is used where a string is expected, the number is converted to a string, in a reasonable format. For complete control over how numbers are converted to strings, use the format function from the string library (see string.format). 


2.2.1 - 强制转换
Lua中提供在运行时字符串和数值之间的自动转换。
应用到任何一个字符串的任意算术运算都会试图按照通常的转换规则，将这个字符串转换为数字。
相反，当一个数在预计使用一个字符串的场合被使用，这个数会以一个合理的格式转换为字符串。
关于如何把数字转换为字符串的完整控制，请使用string库的format函数（见string.format）。





2.3 - Variables
Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields. 

2.3 - 变量 
变量是存储值的地方。
Lua有三种变量：全局变量，局部变量和表字段（表域）。






A single name can denote a global variable or a local variable (or a function's formal parameter, which is a particular kind of local variable): 

	var ::= Name
	
一个单一的名称可以表示一个全局变量或局部变量（或函数的形式参数，一种特殊的局部变量）： 
var ::= Name



Name denotes identifiers, as defined in §2.1. 

名称表示标识符，在§2.1定义。



Any variable is assumed to be global unless explicitly declared as a local (see §2.4.7). Local variables are lexically scoped: local variables can be freely accessed by functions defined inside their scope (see §2.6). 

任何变量被假设为全局的，除非明确声明为局部（见§2.4.7）。
局部变量是词法作用域：局部变量可以被那些在它们范围内定义的函数自由访问（见§2.6）。




Before the first assignment to a variable, its value is nil. 

在第一次给一个变量赋值前，它的值是nil。



Square brackets are used to index a table: 

	var ::= prefixexp `[′ exp `]′

方括号用于索引表： 
var ::= prefixexp '[' exp ']'


The meaning of accesses to global variables and table fields can be changed via metatables. An access to an indexed variable t[i] is equivalent to a call gettable_event(t,i). (See §2.8 for a complete description of the gettable_event function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.) 

对全局变量和表字段的访问的含义可以通过元表来改变。
对一个索引变量t[i]的访问等效于对gettable_event(t,i)的调用。 
（请参考§2.8中关于gettable_event函数的完整说明。这个函数没有用Lua定义或者可以在Lua中调用。
我们在这里用它只是方便说明。）



The syntax var.Name is just syntactic sugar for var["Name"]: 

	var ::= prefixexp `.′ Name

语法var.Name只是var["Name"]的语法糖： 
var ::= prefixexp '.' Name



All global variables live as fields in ordinary Lua tables, called environment tables or simply environments (see §2.9). Each function has its own reference to an environment, so that all global variables in this function will refer to this environment table. When a function is created, it inherits the environment from the function that created it. To get the environment table of a Lua function, you call getfenv. To replace it, you call setfenv. (You can only manipulate the environment of C functions through the debug library; (see §5.9).) 

所有全局变量正如普通Lua表的字段那样存在，被称为环境表或简称环境（见§2.9）。
每个函数都有一个自己的对应环境的引用，因此在这个函数中所有全局变量将参考这个环境表。
当一个函数被创建时，它从创造它的函数中继承环境。
要想获得一个Lua函数的环境表，你可以调用getfenv。
要想替换它，你可以调用setfenv。
（您只能通过debug库操作C函数的环境；（见§ 5.9）。）


An access to a global variable x is equivalent to _env.x, which in turn is equivalent to 

     gettable_event(_env, "x")

访问全局变量x等效于访问_env.x，而这又相当于执行
gettable_event(_env, "x")



where _env is the environment of the running function. (See §2.8 for a complete description of the gettable_event function. This function is not defined or callable in Lua. Similarly, the _env variable is not defined in Lua. We use them here only for explanatory purposes.) 


其中_env是正在运行的函数的环境。（见§2.8关于gettable_event函数的完整描述。
这个函数不是用Lua定义或者被Lua代码调用。
同样，_env变量也不是用Lua定义。
在这里我们仅仅为了方便解析而使用它们。）



2.4 - Statements
Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations. 


2.4 - 语句 
Lua支持一个大多数都很常规的语句集合，类似于在Pascal或C中使用的语句集合。
这个集合包括赋值，控制结构，函数调用以及变量声明。




2.4.1 - Chunks
The unit of execution of Lua is called a chunk. A chunk is simply a sequence of statements, which are executed sequentially. Each statement can be optionally followed by a semicolon: 

	chunk ::= {stat [`;′]}

2.4.1 - chunk块（注：chunk，不同于下面提到的block显式块）
Lua的执行单元称为chunk块。
chunk块简单来说就是一连串顺序执行的语句序列，
每个语句后面可以可选地跟着一个分号：
chunk ::= {stat [';']}




There are no empty statements and thus ';;' is not legal. 

没有空语句，因此';;'是不合法的。





Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see §2.5.9). As such, chunks can define local variables, receive arguments, and return values. 


Lua把一个块处理成一个带可变数目参数的匿名函数体（见§2.5.9）。
因此，块可以定义局部变量，接收参数，以及返回值。





A chunk can be stored in a file or in a string inside the host program. To execute a chunk, Lua first pre-compiles the chunk into instructions for a virtual machine, and then it executes the compiled code with an interpreter for the virtual machine. 


块可以存储在一个文件中或在宿主程序内的字符串中。
要执行块，Lua首先会把块预编译成一种虚拟机的指令，然后用带虚拟机的解析器执行编译好的编码（注：即字节码）。







Chunks can also be pre-compiled into binary form; see program luac for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly. 



块也可以被预编译成二进制形式；详见程序luac。
源代码形式的程序和编译好的形态是可互换的；Lua会自动检测文件类型并执行相应的处理。




2.4.2 - Blocks
A block is a list of statements; syntactically, a block is the same as a chunk: 

	block ::= chunk

2.4.2 - block块（注：即显式块）
一个block块是一列语句；语法上程序块等于块
block ::= chunk




A block can be explicitly delimited to produce a single statement: 

	stat ::= do block end

一个block块可以被显式划定成一个单独的语句： 
stat ::= do block end






Explicit blocks are useful to control the scope of variable declarations. Explicit blocks are also sometimes used to add a return or break statement in the middle of another block (see §2.4.4). 


显式block块有利于控制变量声明的作用域。
显式block块有时也用于另一个块中添加一个return或break语句（见§2.4.4）。





2.4.3 - Assignment
Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas: 

	stat ::= varlist `=′ explist
	varlist ::= var {`,′ var}
	explist ::= exp {`,′ exp}

2.4.3 - 赋值 
Lua允许多重赋值。
因此，赋值语法定义左侧是一列变量，右侧是一列变量。
两个队列的元素用逗号分隔：
stat ::= varlist '=' explist
varlist ::= var {',' var}
explist ::= exp {',' exp}







Expressions are discussed in §2.5. 

表达式在§2.5中讨论。




Before the assignment, the list of values is adjusted to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many nil's as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see §2.5). 


在赋值前，值列表根据变量列表（注：即左值列表）大小调整长度。
如果值个数超过所需个数，超出个数的值被丢弃。
如果值个数少于所需个数，列表会用所需个数的nil扩充。
如果表达式列表以函数调用结束，那么该调用返回的所有值在调整前进入值列表（除非该调用被括号括起，见§2.5）。



The assignment statement first evaluates all its expressions and only then are the assignments performed. Thus the code 

     i = 3
     i, a[i] = i+1, 20

sets a[3] to 20, without affecting a[4] because the i in a[i] is evaluated (to 3) before it is assigned 4. Similarly, the line 

     x, y = y, x

exchanges the values of x and y, and 

     x, y, z = y, z, x

cyclically permutes the values of x, y, and z. 


赋值语句首先计算它所有的表达式，然后才执行赋值。
因此，代码
i = 3
i, a[i] = i+1, 20
把a[3]设置为20，而不是把a[r]设置为20，因为在a[i]中的i在赋值为4之前被计算（为3）
类似地，代码行
x, y = y, x
交换x和y的值，而
x, y, z = y, z, x
循环交换x，y和z的值





The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable t[i] = val is equivalent to settable_event(t,i,val). (See §2.8 for a complete description of the settable_event function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.) 


全局变量的赋值和表字段的赋值含义可以通过元表来改变。
一个对带索引变量的赋值t[i] = val等效于settable_event(t,i,val)。
（见§2.8关于settable_event的完整描述。
这个函数不是用Lua定义或者在Lua中可访问。
我们在这里用它只是为了方便解析）





An assignment to a global variable x = val is equivalent to the assignment _env.x = val, which in turn is equivalent to 

     settable_event(_env, "x", val)


对一个全局变量的赋值x = val等效于赋值_env.x = val，还等效于 
settable_event(_env, "x", val)








where _env is the environment of the running function. (The _env variable is not defined in Lua. We use it here only for explanatory purposes.) 


其中_env是正在运行的函数的环境。
（_env变量不是用Lua定义。
我们在这里用它只是为了方便解释。）









2.4.4 - Control Structures
The control structures if, while, and repeat have the usual meaning and familiar syntax: 

	stat ::= while exp do block end
	stat ::= repeat block until exp
	stat ::= if exp then block {elseif exp then block} [else block] end

2.4.4 - 控制结构 
控制结构if，while，和repeat拥有通常和熟悉的语法： 
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
	



Lua also has a for statement, in two flavors (see §2.4.5). 


Lua也有for语句，有两种（见§2.4.5）。







The condition expression of a control structure can return any value. Both false and nil are considered false. All values different from nil and false are considered true (in particular, the number 0 and the empty string are also true). 


控制结构的条件表达式可以返回任何值。
false和nil都被视是false。
所有不同于nil和false的值被视为true
（特别的，数字0和空字符串也是true）。
（注：在C的条件表达式中0被视为false，而在Lua中则被视为true）





In the repeatCuntil loop, the inner block does not end at the until keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block. 


在repeat-until循环中，内部块不是在util关键字结束，而是在该条件判断后结束。
因此，条件可以引用loop块内的当地循环内声明的变量块。





The return statement is used to return values from a function or a chunk (which is just a function). Functions and chunks can return more than one value, and so the syntax for the return statement is 

	stat ::= return [explist]

The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop: 

	stat ::= break

A break ends the innermost enclosing loop. 

The return and break statements can only be written as the last statement of a block. If it is really necessary to return or break in the middle of a block, then an explicit inner block can be used, as in the idioms do return end and do break end, because now return and break are the last statements in their (inner) blocks. 


return语句用于从一个函数或一个chunk块（仅仅是一个函数）中返回值。
函数和chunk块可以返回多于一个值，所以return语句的语法是
stat ::= return [explist]
break语句是用来终止了while，repeat，或者for循环，跳到循环之后的下一个语句：
stat ::= break
break结束最内层的封闭循环
return和break语句只可以作为block块的最后语句。
如果真的有必要从block块的中间返回或者结束循环，那么可以使用显式的内部block块，即作为习惯用语的do return end以及do break end，因为现在return和break是它们（内部）block块的最后语句。













2.4.5 - For Statement
The for statement has two forms: one numeric and one generic. 

The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax: 

	stat ::= for Name `=′ exp `,′ exp [`,′ exp] do block end

The block is repeated for name starting at the value of the first exp, until it passes the second exp by steps of the third exp. More precisely, a for statement like 

     for v = e1, e2, e3 do block end

is equivalent to the code: 

     do
       local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
       if not (var and limit and step) then error() end
       while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do
         local v = var
         block
         var = var + step
       end
     end

Note the following: 

All three control expressions are evaluated only once, before the loop starts. They must all result in numbers. 
var, limit, and step are invisible variables. The names shown here are for explanatory purposes only. 
If the third expression (the step) is absent, then a step of 1 is used. 
You can use break to exit a for loop. 
The loop variable v is local to the loop; you cannot use its value after the for ends or is broken. If you need this value, assign it to another variable before breaking or exiting the loop. 
The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil. The generic for loop has the following syntax: 

	stat ::= for namelist in explist do block end
	namelist ::= Name {`,′ Name}

A for statement like 

     for var_1, ・・・, var_n in explist do block end

is equivalent to the code: 

     do
       local f, s, var = explist
       while true do
         local var_1, ・・・, var_n = f(s, var)
         var = var_1
         if var == nil then break end
         block
       end
     end

Note the following: 

explist is evaluated only once. Its results are an iterator function, a state, and an initial value for the first iterator variable. 
f, s, and var are invisible variables. The names are here for explanatory purposes only. 
You can use break to exit a for loop. 
The loop variables var_i are local to the loop; you cannot use their values after the for ends. If you need these values, then assign them to other variables before breaking or exiting the loop. 




2.4.5 - for语句
for语句有两种形式：数字形式和泛型形式。
数字形式的循环当控制变量以算术级数变化时重复执行一段代码块。
它具有以下语法：
stat ::= for Name '=' exp ',' exp [',' exp] do block end
block块对name以第一个表达式的值开始循环，直至它通过第三个表达式的值的步进值，到达第二个表达式的值。
更确切地，一个for语句像这样：
for v = e1, e2, e3 do block end
等效于这样的语句
do
	local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)
	if not (var and limit and step) then error() end
	while (step > 0 and var <= limit) or (step <= 0 and var >= limit) do
		local v = var
		block
		var = var + step
	end
end 
注意如下：
这三个控制表达式都只会在循环开始之前计算一次。
它们必须返回数字。
var，limit，和step是不可见变量。
这里展示的名字只是为了方便解释。
如果缺少第三个表达式（step），那么使用步长值1。
你可以使用break退出一个for循环。
新欢变量v在循环中局部可见；你不能再for结束后或者跳出之后使用它的值。
如果你需要这个值，在跳出或退出循环之前把它的值赋给另一个变量。
泛型for语句工作于被称为迭代器的函数上。
在每次迭代时，调用迭代器函数产生新的值，当新的值是nil时停止循环。
泛型for循环拥有以下语法：
stat ::= for namelist in explist do block end
namelist ::= Name {',' Name} 
一个像这样的for语句
for var_1, ・・・, var_n in explist do block end
等效于代码：
do
	local f, s, var = explist
	while true do
		local var_1, ・・・, var_n = f(s, var)
		var = var_1
		if var == nil then break end
		block
	end
end
注意如下：
explist只计算一次。
其结果是一个迭代函数，一个状态，以及第一个迭代器变量的初始值。
f，s，和var是不可见变量。
这里的名字只是为了方便解释。
你可以使用break退出for循环。
循环变量var_i在循环中局部可见，你不能在for循环结束后使用它们的值。
如果你需要这些值，那么在跳出或者退出循环之前把它们的值赋给其它变量。




























2.4.6 - Function Calls as Statements
To allow possible side-effects, function calls can be executed as statements: 

	stat ::= functioncall

In this case, all returned values are thrown away. Function calls are explained in §2.5.8. 


2.4.6 - 作为语句的函数调用 
为了允许可能的副作用，函数调用可以以语句的形式执行： 
stat ::= functioncall
在这种情况下，所有的返回值被丢弃。函数调用在§2.5.8中解释。 









2.4.7 - Local Declarations
Local variables can be declared anywhere inside a block. The declaration can include an initial assignment: 

	stat ::= local namelist [`=′ explist]

If present, an initial assignment has the same semantics of a multiple assignment (see §2.4.3). Otherwise, all variables are initialized with nil. 

A chunk is also a block (see §2.4.1), and so local variables can be declared in a chunk outside any explicit block. The scope of such local variables extends until the end of the chunk. 

The visibility rules for local variables are explained in §2.6. 



2.4.7 - 局部变量声明
局部变量可以在block块内的任意位置声明。
该声明可以包含一个初始化赋值：
stat ::= local namelist ['=' explist]
如果存在，初始化赋值具有和多重赋值相同的语义（见§2.4.3）。
否则，所有变量都被初始化为nil。
chunk块也属于block块（见§2.4.1），因此局部变量可以在任何显式block块外的chunk块中声明。
这种局部变量的作用域延伸至chunk块结束。
局部变量的可见性规则在§2.6中解释。












2.5 - Expressions
The basic expressions in Lua are the following: 

	exp ::= prefixexp
	exp ::= nil | false | true
	exp ::= Number
	exp ::= String
	exp ::= function
	exp ::= tableconstructor
	exp ::= `...′
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | `(′ exp `)′

Numbers and literal strings are explained in §2.1; variables are explained in §2.3; function definitions are explained in §2.5.9; function calls are explained in §2.5.8; table constructors are explained in §2.5.7. Vararg expressions, denoted by three dots ('...'), can only be used when directly inside a vararg function; they are explained in §2.5.9. 

Binary operators comprise arithmetic operators (see §2.5.1), relational operators (see §2.5.2), logical operators (see §2.5.3), and the concatenation operator (see §2.5.4). Unary operators comprise the unary minus (see §2.5.1), the unary not (see §2.5.3), and the unary length operator (see §2.5.5). 

Both function calls and vararg expressions can result in multiple values. If an expression is used as a statement (only possible for function calls (see §2.4.6)), then its return list is adjusted to zero elements, thus discarding all returned values. If an expression is used as the last (or the only) element of a list of expressions, then no adjustment is made (unless the call is enclosed in parentheses). In all other contexts, Lua adjusts the result list to one element, discarding all values except the first one. 

Here are some examples: 

     f()                -- adjusted to 0 results
     g(f(), x)          -- f() is adjusted to 1 result
     g(x, f())          -- g gets x plus all results from f()
     a,b,c = f(), x     -- f() is adjusted to 1 result (c gets nil)
     a,b = ...          -- a gets the first vararg parameter, b gets
                        -- the second (both a and b can get nil if there
                        -- is no corresponding vararg parameter)
     
     a,b,c = x, f()     -- f() is adjusted to 2 results
     a,b,c = f()        -- f() is adjusted to 3 results
     return f()         -- returns all results from f()
     return ...         -- returns all received vararg parameters
     return x,y,f()     -- returns x, y, and all results from f()
     {f()}              -- creates a list with all results from f()
     {...}              -- creates a list with all vararg parameters
     {f(), nil}         -- f() is adjusted to 1 result

Any expression enclosed in parentheses always results in only one value. Thus, (f(x,y,z)) is always a single value, even if f returns several values. (The value of (f(x,y,z)) is the first value returned by f or nil if f does not return any values.) 






2.5 - 表达式
Lua基本表达式如下：
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Number
exp ::= String
exp ::= function
exp ::= tableconstructor
exp ::= '...'
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | '(' exp ')'
数和字符串字面值在§2.1中解释；
变量在§2.3中解释；
函数定义在§2.5.9中解释；
函数调用在§2.5.8中解释；
表构造式在§2.5.7中解释；
变长参数表达式，指三点运算符（'...'），只能直接在变长参数函数中使用；它们在§2.5.9中解释。
二元运算符包括算术运算符（见§2.5.1），关系运算符（见§2.5.2），逻辑运算符（见§2.5.3），一元not（见§2.5.3），以及一元长度操作符（见§2.5.5）。
函数调用和变长参数表达式都可以返回多个值。
如果一个表达式用作语句（只可以用于函数调用（见§2.4.6）），那么它的返回列表调整为0个元素，从而丢弃所有返回值。
如果一个表达式用于表达式列表的最后（或者唯一）的元素，那么不会进行调整（除非调用被括号括起）。
在所有其它场合中，Lua把返回列表调整为一个元素，丢弃第一个值以外的所有值。
这里是一些例子：
f()                -- 调整为0个结果
g(f(), x)          -- f()调整为1个结果
g(x, f())          -- g获得x和f()的所有结果
a,b,c = f(), x     -- f()调整为1个结果(c获得nil)
a,b = ...          -- a获得第一个变长参数的参数, b获得第二个（如果没有相应的变长参数表的参数，a和b可能获得nil）
a,b,c = x, f()     -- f()调整为2个结果
a,b,c = f()        -- f()调整为3个结果
return f()         -- 返回f()的所有结果
return ...         -- 返回所有接受的变长参数表的参数
return x,y,f()     -- 返回x，y，和所有f()的结果
{f()}              -- 创建一个f()结果的列表。
{...}              -- 创建一个变长参数表的所有参数的列表
{f(), nil}         -- f()被调整为1个结果
任意用括号括起的表达式总是返回一个值。
因此，(f(x,y,z))总是一个值，即使f返回几个值。
（(f(x,y,z))是f返回的第一个值，如果f不返回任何值，则是nil。）















2.5.1 - Arithmetic Operators
Lua supports the usual arithmetic operators: the binary + (addition), - (subtraction), * (multiplication), / (division), % (modulo), and ^ (exponentiation); and unary - (negation). If the operands are numbers, or strings that can be converted to numbers (see §2.2.1), then all operations have the usual meaning. Exponentiation works for any exponent. For instance, x^(-0.5) computes the inverse of the square root of x. Modulo is defined as 

     a % b == a - math.floor(a/b)*b

That is, it is the remainder of a division that rounds the quotient towards minus infinity. 



2.5.1 - 算术运算符 
Lua支持普通的算术运算符：二元+（加），-（减），*（乘），/（除），％（取模），和^（指数幂）和一元-（负号）。
如果操作数是数字或可转换为数字的字符串（见§2.2.1），那么所有操作拥有普通的含义。
幂适用于任何指数。
例如x ^（-0.5）计算出x的平方根。
取模定义为
a % b == a - math.floor(a/b)*b
其中它是除法的余数，使商靠近负无穷。






2.5.2 - Relational Operators
The relational operators in Lua are 

     ==    ~=    <     >     <=    >=

These operators always result in false or true. 

Equality (==) first compares the type of its operands. If the types are different, then the result is false. Otherwise, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata, threads, and functions) are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, thread, or function), this new object is different from any previously existing object. 

You can change the way that Lua compares tables and userdata by using the "eq" metamethod (see §2.8). 

The conversion rules of §2.2.1 do not apply to equality comparisons. Thus, "0"==0 evaluates to false, and t[0] and t["0"] denote different entries in a table. 

The operator ~= is exactly the negation of equality (==). 

The order operators work as follows. If both arguments are numbers, then they are compared as such. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the "lt" or the "le" metamethod (see §2.8). A comparison a > b is translated to b < a and a >= b is translated to b <= a. 



2.5.2 - 关系运算符 
Lua的关系运算符有
==    ~=    <     >     <=    >=
这些运算符总是返回false或者true。
相等（==）首先比较操作数的类型。
如果类型不同，那么结果为false。
否则比较操作数的值。
数字和字符串以通常的方式比较。
对象（表，用户数据，线程和函数）用引用进行比较：两个对象仅在它们引用相同对象时才被视为相等。
每次创建一个新的对象（表，用户数据，线程，或功能），这个新的对象是从任何以前存在的对象不同。 
你可以通过使用"eq"元方法改变Lua比较表和userdata的方式。
§2.2.1的转换规则并不适用于相等比较。
因此，"0"==0的计算结果为false，T[0]和T["0"]表示表的不同条目。 
运算符~=是等号（==）的准确否定。
顺序运算符工作方式如下。
如果参数都为数，它们以原本方式比较。否则，如果参数都是字符串，那么它们的值根据当前的本地环境进行比较。
否则，Lua尝试调用"lt"和"le"元方法（见§2.8）
比较式a > b被翻译为b < a，而a >= b被翻译为b <= a。









2.5.3 - Logical Operators
The logical operators in Lua are and, or, and not. Like the control structures (see §2.4.4), all logical operators consider both false and nil as false and anything else as true. 

The negation operator not always returns false or true. The conjunction operator and returns its first argument if this value is false or nil; otherwise, and returns its second argument. The disjunction operator or returns its first argument if this value is different from nil and false; otherwise, or returns its second argument. Both and and or use short-cut evaluation; that is, the second operand is evaluated only if necessary. Here are some examples: 

     10 or 20            --> 10
     10 or error()       --> 10
     nil or "a"          --> "a"
     nil and 10          --> nil
     false and error()   --> false
     false and nil       --> false
     false or nil        --> nil
     10 and 20           --> 20

(In this manual, --> indicates the result of the preceding expression.) 



2.5.3 - 逻辑运算符 
Lua的逻辑运算符有and，or，和not。
像控制结构那样（见§2.4.4），所有逻辑运算符把false和nil视为false，其它视为true。 
否定运算符不总是返回false或true。
如果第一个参数的值是false或nil，组合运算符and会返回这个值；
否则，and返回第二个参数。
如果第一个参数的值不是nil或false，分离运算符or会返回这个值；
否则，or返回第二个参数。
and和or使用短路计算；即第二操作数只在必要时计算。
这里有一些例子：
10 or 20            --> 10
10 or error()       --> 10
nil or "a"          --> "a"
nil and 10          --> nil
false and error()   --> false
false and nil       --> false
false or nil        --> nil
10 and 20           --> 20
（在本手册中，-->表示前面表达式的结果。）（注：同时也是注释的写法）








2.5.4 - Concatenation
The string concatenation operator in Lua is denoted by two dots ('..'). If both operands are strings or numbers, then they are converted to strings according to the rules mentioned in §2.2.1. Otherwise, the "concat" metamethod is called (see §2.8). 



2.5.4 - 连接 
在Lua中字符串连接运算符是指两个点（'..'）。
如果两个操作数都是字符串或数，那么它们都会按照§ 2.2.1中提到的规则转换为字符串。
否则调用"concat"元方法（见§2.8）。










2.5.5 - The Length Operator
The length operator is denoted by the unary operator #. The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte). 

The length of a table t is defined to be any integer index n such that t[n] is not nil and t[n+1] is nil; moreover, if t[1] is nil, n can be zero. For a regular array, with non-nil values from 1 to a given n, its length is exactly that n, the index of its last value. If the array has "holes" (that is, nil values between other non-nil values), then #t can be any of the indices that directly precedes a nil value (that is, it may consider any such nil value as the end of the array). 


2.5.5 - 长度运算符 
长度运算符是指一元运算符#。
字符串的长度是它的字节数（即字符串长度的通常意义，每个字符是一个字节）。 
表t的长度是指任何整数索引n使得T[n]不是nil而T[n+1]是nil；而且，如果t[1]是nil，n可以为零。
对于常规数组，从1到一个给定的n的元素都是非空值，则其长度正好是n，即它最后的值的索引。
如果数组有“洞”（即在其他非空值之间的nil值），则#T可以是在一个非空值前一个值的任何一个索引（即可以把任何一个这种nil值视为数组的结束）。










