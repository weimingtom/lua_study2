<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://www.codingnow.com/2000/download/lua_manual.html -->
<HTML><HEAD><TITLE>Lua 5.1 参考手册</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content="MSHTML 6.00.2900.3395" name=GENERATOR></HEAD>
<BODY>
<HR>

<H1>Lua 5.1 参考手册 </H1>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, 
Waldemar Celes 
<P>云风 译 <A href="http://www.codingnow.com/">http://www.codingnow.com/</A> 
<P><SMALL><A href="http://www.lua.org/copyright.html">Copyright</A> &copy; 2006 
Lua.org, PUC-Rio. All rights reserved. </SMALL>
<HR>
<!-- ====================================================================== -->
<P>
<H1>1 - <A name=1>介绍</A></H1>
<P>Lua 是一个扩展式程序设计语言，它被设计成支持通用的过程式编程，并有相关数据描述的设施。 Lua 
也能对面向对象编程，函数式编程，数据驱动式编程提供很好的支持。它可以作为一个强大、轻量的脚本语言，供任何需要的程序使用。 Lua 以一个用 
<EM>clean</EM> C 写成的库形式提供。（所谓 Clean C ，指的 ANSI C 和 C++ 中共通的一个子集） 
<P>作为一个扩展式语言，Lua 没有 "main" 程序的概念：它只能 <EM>嵌入</EM> 一个宿主程序中工作，这个宿主程序被称作 
<EM>embedding program</EM> 或简称为 <EM>host</EM> 。宿主程序可以通过调用函数执行一小段 Lua 代码，可以读写 Lua 
变量，可以注入 C 函数让 Lua 代码调用。这些扩展的 C 函数，可以大大的扩展了 Lua 
可以处理事务的领域，这样就可以订制出各种语言，而它们共享一个统一的句法格式的框架。 Lua 的官方发布版就包含了一个叫做 <CODE>lua</CODE> 
的简单的宿主程序，它用 Lua 库提供了一个保证独立的 Lua 解释器。 
<P>Lua 是一个自由软件，它的使用许可决定了对它的使用过程一般没有任何保证。这份手册中描述的东西的实现，可以在 Lua 的官方网站 
<CODE>www.lua.org</CODE> 找到， 
<P>跟其它的许多参考手册一样，这份文档有些地方比较枯燥。关于 Lua 的设计想法的探讨，可以看看 Lua 网站上提供的技术论文。有关用 Lua 
编程的细节介绍，可以读一下 Roberto 的书，<EM>Programming in Lua (Second Edition)</EM> 。 
<H1>2 - <A name=2>语言</A></H1>
<P>这一节从词法、语法、句法上描述 Lua 。换句话说，这一节描述了哪些 token （符记）是有效的，它们如何被组合起来，这些组合方式有什么含义。 
<P>关于语言的构成概念将用常见的扩展 BNF 表达式写出。也就是这个样子： {<EM>a</EM>} 意思是 0 或多个 <EM>a</EM> ， 
[<EM>a</EM>] 意思是一个可选的 <EM>a</EM> 。非最终的符号会保留原来的样子，关键字则看起来像这样 <B>kword</B> 
，其它最终的符号则写成 `<B>=</B>&acute; 。完整的 Lua 语法可以在本手册最后找到。 
<H2>2.1 - <A name=2.1>词法约定</A></H2>
<P>Lua 中用到的 <EM>名字</EM>（也称作 
<EM>标识符</EM>）可以是任何非数字开头的字母、数字、下划线组成的字符串。这符合几乎所有编程语言中关于名字的定义。（字母的定义依赖于当前环境：系统环境中定义的字母表中的字母都可以被用于标识符。）标识符用来命名变量，或作为表的域名。 

<P>下面的关键字是保留的，不能用作名字： <PRE>     and       break     do        else      elseif
     end       false     for       function  if
     in        local     nil       not       or
     repeat    return    then      true      until     while
</PRE>
<P>Lua 是一个大小写敏感的语言： <CODE>and</CODE> 是一个保留字，但是 <CODE>And</CODE> 和 
<CODE>AND</CODE> 则是两个不同的合法的名字。一般约定，以下划线开头连接一串大写字母的名字（比如 
<CODE>_VERSION</CODE>）被保留用于 Lua 内部全局变量。 
<P>下面这些是其它的 token ： <PRE>     +     -     *     /     %     ^     #
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]
     ;     :     ,     .     ..    ...
</PRE>
<P>字符串既可以用一对单引号引起，也可以是双引号，里面还可以包含类似 C 的转义符： '<CODE>\a</CODE>' （响铃）， 
'<CODE>\b</CODE>' （退格）， '<CODE>\f</CODE>' （表单）， '<CODE>\n</CODE>' （换行）， 
'<CODE>\r</CODE>' （回车）， '<CODE>\t</CODE>' （横向制表）， '<CODE>\v</CODE>' （纵向制表）， 
'<CODE>\\</CODE>' （反斜杠）， '<CODE>\"</CODE>' （双引号），以及 '<CODE>\'</CODE>' 
（单引号)。而且，如果在一个反斜杠后跟了一个真正的换行符，其结果就是在字符串中产生一个换行符。我们还可以用反斜杠加数字的形式 
<CODE>\<EM>ddd</EM></CODE> 来描述一个字符。这里， <EM>ddd</EM> 
是一串最多三位的十进制数字。（注意，如果需要在这种描述方法后接一个是数字的字符，那么反斜杠后必须写满三个数字。）Lua 中的字符串可以包含任何 8 
位的值。包括用 '<CODE>\0</CODE>' 表示的零。 
<P>只有在你需要把不同的引号、换行、反斜杠、或是零结束符这些字符置入字符串时，你才必须使用转义符。别的任何字符都可以直接写在文本里。（一些控制符可以会影响文件系统造成某些问题，但是不会引起 
Lua 的任何问题。） 
<P>字符串还可以用一种长括号括起来的方式定义。我们把两个正的方括号间插入 n 个等号定义为第 n 级正长括号。就是说，0 级正的长括号写作 
<CODE>[[</CODE> ，一级正的长括号写作 <CODE>[=[</CODE> ，如此等等。反的长扩展也作类似定义；举个例子，4 级反的长括号写作 
<CODE>]====]</CODE> 
。一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。整个词法分析过程将不受分行限制，不处理任何转意符，并且忽略掉任何不同级别的长括号。这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。 

<P>另一个约定是，当正的长括号后面立即跟了一个换行符，这个换行符就不包含在这个字符串内。举个例子，假设一个系统使用 ASCII 
码（这时，'<CODE>a</CODE>' 编码为 97 ，换行符编码为 10 ，'<CODE>1</CODE>' 编码为 49 
），下面五种方式描述了完全相同的字符串： <PRE>     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</PRE>
<P>数字常量可以分两部分写，十进制底数部分和十进制的指数部分。指数部分是可选的。 Lua 也支持十六进制整数常量，只需要在前面加上前缀 
<CODE>0x</CODE> 。下面是一些合法的数字常量的例子： <PRE>     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56
</PRE>
<P>注释可以在除字符串内的任何地方是以两横 (<CODE>--</CODE>) 
开始。如果跟在两横后面的不是一个长括号，这就是一个短注释，它的作用范围直到行末；否则就是一个长注释，其作用范围直到遇到反的长括号。长注释通常被用来临时屏蔽代码块。 

<H2>2.2 - <A name=2.2>值与类型</A></H2>
<P>Lua 是一种 <EM>动态类型语言</EM>。这意味着变量没有类型，只有值才有类型。语言中不存在类型定义。而所有的值本身携带它们自己的类型信息。 
<P>Lua 中的所有值都是一致 (first-class) 的。这意味着所有的值都可以被放在变量里，当作参数传递到另一个函数中，并被函数作为结果返回。 
<P>Lua 中有八种基本类型： <EM>nil</EM>, <EM>boolean</EM>, <EM>number</EM>, 
<EM>string</EM>, <EM>function</EM>, <EM>userdata</EM>, <EM>thread</EM>, and 
<EM>table</EM>. <EM>Nil</EM> 类型只有一种值 <B>nil</B> 
，它的主要用途用于标表识和别的任何值的差异；通常，当需要描述一个无意义的值时会用到它。 <EM>Boolean</EM> 
类型只有两种值：<B>false</B> 和 <B>true</B>。 <B>nil</B> 和 <B>false</B> 
都能导致条件为假；而另外所有的值都被当作真。 <EM>Number</EM> 表示实数（双精度浮点数）。（编译一个其它内部数字类型的 Lua 
解释器是件很容易的事；比如把内部数字类型改作单精度浮点数或长整型。参见文件 <CODE>luaconf.h</CODE> 。） <EM>String</EM> 
表示一串字符的数组。 Lua 是 8-bit clean 的：字符串可以包含任何 8 位字符，包括零结束符 ('<CODE>\0</CODE>') （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.1">§2.1</A>）。 
<P>Lua 可以调用（和处理）用 Lua 写的函数以及用 C 写的函数（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.8">§2.5.8</A>）. 

<P><EM>userdata</EM> 类型用来将任意 C 数据保存在 Lua 变量中。这个类型相当于一块原生的内存，除了赋值和相同性判断，Lua 
没有为之预定义任何操作。然而，通过使用 <EM>metatable （元表）</EM> ，程序员可以为 userdata 自定义一组操作（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
userdata 不能在 Lua 中创建出来，也不能在 Lua 中修改。这样的操作只能通过 C API。这一点保证了宿主程序完全掌管其中的数据。 
<P><EM>thread</EM> 类型用来区别独立的执行线程，它被用来实现 coroutine （协同例程）（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.11">§2.11</A>）。不要把 
Lua 线程跟操作系统的线程搞混。 Lua 可以在所有的系统上提供对 coroutine 的支持，即使系统并不支持线程。 
<P><EM>table</EM> 类型实现了一个关联数组。也就是说，数组可以用任何东西（除了<B>nil</B>）做索引，而不限于数字。 table 
可以以不同类型的值构成；它可以包含所有的类型的值（除 <B>nil</B> 外）。 table 是 lua 
中唯一的一种数据结构；它可以用来描述原始的数组、符号表、集合、记录、图、树、等等。用于表述记录时，lua 使用域名作为索引。语言本身采用一种语法糖，支持以 
<CODE>a.name</CODE> 的形式表示 <CODE>a["name"]</CODE>。有很多形式用于在 lua 中创建一个 table （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.7">§2.5.7</A>）。 

<P>跟索引一样， table 每个域中的值也可以是任何类型（除 <B>nil</B>外）。特别的，因为函数本身也是值，所以 table 
的域中也可以放函数。这样 table 中就可以有一些 <EM>methods</EM> 了 （参见see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.9">§2.5.9</A>）。 

<P>table， function ，thread ，和 (full) userdata 
这些类型的值是所谓的对象：变量本身并不会真正的存放它们的值，而只是放了一个对对象的引用。赋值，参数传递，函数返回，都是对这些对象的引用进行操作；这些操作不会做暗地里做任何性质的拷贝。 

<P>库函数 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-type"><CODE>type</CODE></A> 
可以返回一个描述给定值的类型的字符串。 
<H3>2.2.1 - <A name=2.2.1>强制转换</A></H3>
<P>Lua 
提供运行时字符串到数字的自动转换。任何对字符串的数学运算操作都会尝试用一般的转换规则把这个字符串转换成一个数字。相反，无论何时，一个数字需要作为字符串来使用时，数字都会以合理的格式转换为字符串。需要完全控制数字怎样转换为字符串，可以使用字符串库中的 
<CODE>format</CODE> 函数（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.format"><CODE>string.format</CODE></A>）。 

<H2>2.3 - <A name=2.3>变量</A></H2>
<P>写上变量的地方意味着当以其保存的值来替代之。 Lua 中有三类变量：全局变量，局部变量，还有 table 的域。 
<P>一个单一的名字可以表示一个全局变量，也可以表示一个局部变量 （或者是一个函数的参数，这是一种特殊形式的局部变量）： <PRE>	var ::= Name
</PRE>
<P>Name 就是 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.1">§2.1</A> 
中所定义的标识符。 
<P>任何变量都被假定为全局变量，除非显式的以 local 修饰定义 （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.7">§2.4.7</A>）。局部变量有其作用范围：局部变量可以被定义在它作用范围中的函数自由使用（参见 
<A href="http://www.codingnow.com/2000/download/lua_manual.html#2.6">§2.6</A>）。 
<P>在变量的首次赋值之前，变量的值均为 <B>nil</B>。 
<P>方括号被用来对 table 作索引： <PRE>	var ::= prefixexp `<B>[</B>&acute; exp `<B>]</B>&acute;
</PRE>
<P>对全局变量以及 table 域之访问的含义可以通过 metatable 来改变。以取一个变量下标指向的量 <CODE>t[i]</CODE> 等价于调用 
<CODE>gettable_event(t,i)</CODE>。（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A> 
，有一份完整的关于 <CODE>gettable_event</CODE> 函数的说明。这个函数并没有在 lua 中定义出来，也不能在 lua 
中调用。这里我们把它列出来只是方便说明。） 
<P><CODE>var.Name</CODE> 这种语法只是一个语法糖，用来表示 <CODE>var["Name"]</CODE>： <PRE>	var ::= prefixexp `<B>.</B>&acute; Name
</PRE>
<P>所有的全局变量都是放在一个特定 lua table 的诸个域中，这个特定的 table 叫作 <EM>environment （环境）table</EM> 
或者简称为 <EM>环境</EM> （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.9">§2.9</A>）。每个函数都有对一个环境的引用，所以一个函数中可见的所有全局变量都放在这个函数所引用的环境表（environment 
table）中。当一个函数被创建出来，它会从创建它的函数中继承其环境，你可以调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-getfenv"><CODE>getfenv</CODE></A> 
取得其环境。如果想改变环境，可以调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-setfenv"><CODE>setfenv</CODE></A>。（对于 
C 函数，你只能通过 debug 库来改变其环境；参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#5.9">§5.9</A>）。 
<P>对一个全局变量 <CODE>x</CODE> 的访问等价于 <CODE>_env.x</CODE>，而这又可以等价于 <PRE>     gettable_event(_env, "x")
</PRE>
<P>这里，<CODE>_env</CODE> 是当前运行的函数的环境。（函数 <CODE>gettable_event</CODE> 的完整说明参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>。这个函数并没有在 
lua 中定义出来，也不能调用。当然，<CODE>_env</CODE> 这个变量也同样没有在 Lua 中定义出来。我们在这里使用它们，仅仅只是方便解释而已。） 

<H2>2.4 - <A name=2.4>语句段（Statement）</A></H2>
<P>Lua 支持惯例形式的语句段，它和 Pascal 或是 C 很相象。这个集合包括赋值，控制结构，函数调用，还有变量声明。 
<H3>2.4.1 - <A name=2.4.1>Chunk（语句组）</A></H3>
<P>Lua 的一个执行单元被称作 <EM>chunk</EM>。一个 chunk 就是一串语句段，它们会被循序的执行。每个语句段可以以一个分号结束： <PRE>	chunk ::= {stat [`<B>;</B>&acute;]}
</PRE>
<P>这儿不允许有空的语句段，所以 '<CODE>;;</CODE>' 是非法的。 
<P>lua 把一个 chunk 当作一个拥有不定参数的匿名函数（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.9">§2.5.9</A>）处理。正是这样，chunk 
内可以定义局部变量，接收参数，并且返回值。 
<P>chunk 可以被保存在一个文件中，也可以保存在宿主程序的一个字符串中。当一个 chunk 
被执行，首先它会被预编译成虚拟机中的指令序列，然后被虚拟机解释运行这些指令。 
<P>chunk 也可以被预编译成二进制形式；细节参考程序 
<CODE>luac</CODE>。用源码形式提供的程序和被编译过的二进制形式的程序是可以相互替换的； Lua 会自动识别文件类型并做正确的处理。 
<H3>2.4.2 - <A name=2.4.2>语句块</A></H3>
<P>语句块是一列语句段；从语法上来说，一个语句块跟一个 chunk 相同： <PRE>	block ::= chunk
</PRE>
<P>一个语句块可以被显式的写成一个单独的语句段： <PRE>	stat ::= <B>do</B> block <B>end</B>
</PRE>
<P>显式的语句块对于控制变量的作用范围很有用。有时候，显式的语句块被用来在另一个语句块中插入 <B>return</B> 或是 <B>break</B> 
（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.4">§2.4.4</A>）。 

<H3>2.4.3 - <A name=2.4.3>赋值</A></H3>
<P>Lua 允许多重赋值。因此，赋值的语法定义是等号左边放一系列变量，而等号右边放一系列的表达式。两边的元素都用逗号间开： <PRE>	stat ::= varlist1 `<B>=</B>&acute; explist1
	varlist1 ::= var {`<B>,</B>&acute; var}
	explist1 ::= exp {`<B>,</B>&acute; exp}
</PRE>
<P>表达式放在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5">§2.5</A> 里讨论。 
<P>在作赋值操作之前，那一系列的右值会被对齐到左边变量需要的个数。如果右值比需要的更多的话，多余的值就被扔掉。如果右值的数量不够需求，将会按所需扩展若干个 
<B>nil</B>。如果表达式列表以一个函数调用结束，这个函数所返回的所有值都会在对齐操作之前被置入右值序列中。（除非这个函数调用被用括号括了起来；参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5">§2.5</A>）。 
<P>赋值段首先会做运算完所有的表达式，然后仅仅做赋值操作。因此，下面这段代码 <PRE>     i = 3
     i, a[i] = i+1, 20
</PRE>
<P>会把 <CODE>a[3]</CODE> 设置为 20，而不会影响到 <CODE>a[4]</CODE> 。这是因为 <CODE>a[i]</CODE> 
中的 <CODE>i</CODE> 在被赋值为 4 之前就被拿出来了（那时是 3 ）。简单说 ，这样一行 <PRE>     x, y = y, x
</PRE>
<P>可以用来交换 <CODE>x</CODE> 和 <CODE>y</CODE> 中的值。 
<P>对全局变量以及 table 中的域的赋值操作的含义可以通过 metatable 来改变。对变量下标指向的赋值，即 <CODE>t[i] = 
val</CODE> 等价于 <CODE>settable_event(t,i,val)</CODE>。（关于函数 
<CODE>settable_event</CODE> 的详细说明，参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>。这个函数并没有在 
Lua 中定义出来，也不可以被调用。这里我们列出来，仅仅出于方便解释的目的） 
<P>对于全局变量的赋值 <CODE>x = val</CODE> 等价于 <CODE>_env.x = val</CODE>，这个又可以等价于 <PRE>     settable_event(_env, "x", val)
</PRE>
<P>这里，<CODE>_env</CODE> 指的是正在运行中的函数的环境。（变量 <CODE>_env</CODE> 并没有在 Lua 
中定义出来。我们仅仅出于解释的目的在这里写出来。） 
<H3>2.4.4 - <A name=2.4.4>控制结构</A></H3>
<P><B>if</B>、 <B>while</B>、以及 <B>repeat</B> 这些控制结构符合通常的意义，而且也有类似的语法： <PRE>	stat ::= <B>while</B> exp <B>do</B> block <B>end</B>
	stat ::= <B>repeat</B> block <B>until</B> exp
	stat ::= <B>if</B> exp <B>then</B> block {<B>elseif</B> exp <B>then</B> block} [<B>else</B> block] <B>end</B>
</PRE>
<P>Lua 也有一个 <B>for</B> 语句，它有两种形式（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.5">§2.4.5</A>）。 

<P>控制结构中的条件表达式可以返回任何值。 <B>false</B> 和 <B>nil</B> 两者都被认为是假条件。所有不同于 <B>nil</B> 和 
<B>false</B> 的其它值都被认为是真（特别需要注意的是，数字 0 和空字符串也被认为是真）。 
<P>在 <B>repeat</B>C<B>until</B> 循环中，内部语句块的结束点不是在 <B>until</B> 
这个关键字处，它还包括了其后的条件表达式。因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。 
<P><B>return</B> 被用于从函数或是 chunk（其实它就是一个函数）中返回值。 函数和 chunk 可以返回不只一个值，所以 
<B>return</B> 的语法为 <PRE>	stat ::= <B>return</B> [explist1]
</PRE>
<P><B>break</B> 被用来结束 <B>while</B>、 <B>repeat</B>、或 <B>for</B> 
循环，它将忽略掉循环中下面的语句段的运行： <PRE>	stat ::= <B>break</B>
</PRE>
<P><B>break</B> 跳出最内层的循环。 
<P><B>return</B> 和 <B>break</B> 只能被写在一个语句块的最后一句。如果你真的需要从语句块的中间 <B>return</B> 或是 
<B>break</B> ，你可以使用显式的声名一个内部语句块。一般写作 <CODE>do return end</CODE> 或是 <CODE>do 
break end</CODE>，可以这样写是因为现在 <B>return</B> 或 <B>break</B> 都成了一个语句块的最后一句了。 
<H3>2.4.5 - <A name=2.4.5>For 语句</A></H3>
<P><B>for</B> 有两种形式：一种是数字形式，另一种是一般形式。 
<P>数字形式的 <B>for</B> 循环，通过一个数学运算不断的运行内部的代码块。下面是它的语法： <PRE>	stat ::= <B>for</B> Name `<B>=</B>&acute; exp `<B>,</B>&acute; exp [`<B>,</B>&acute; exp] <B>do</B> block <B>end</B>
</PRE>
<P><EM>block</EM> 将把 <EM>name</EM> 作循环变量。从第一个 <EM>exp</EM> 开始起，直到第二个 
<EM>exp</EM> 的值为止，其步长为第三个 <EM>exp</EM> 。更确切的说，一个 <B>for</B> 循环看起来是这个样子 <PRE>     for v = <EM>e1</EM>, <EM>e2</EM>, <EM>e3</EM> do <EM>block</EM> end
</PRE>
<P>这等价于代码： <PRE>     do
       local <EM>var</EM>, <EM>limit</EM>, <EM>step</EM> = tonumber(<EM>e1</EM>), tonumber(<EM>e2</EM>), tonumber(<EM>e3</EM>)
       if not (<EM>var</EM> and <EM>limit</EM> and <EM>step</EM>) then error() end
       while (<EM>step</EM> &gt; 0 and <EM>var</EM> &lt;= <EM>limit</EM>) or (<EM>step</EM> &lt;= 0 and <EM>var</EM> &gt;= <EM>limit</EM>) do
         local v = <EM>var</EM>
         <EM>block</EM>
         <EM>var</EM> = <EM>var</EM> + <EM>step</EM>
       end
     end
</PRE>
<P>注意下面这几点： 
<UL>
  <LI>所有三个控制表达式都只被运算一次，表达式的计算在循环开始之前。这些表达式的结果必须是数字。 
  <LI><CODE><EM>var</EM></CODE> 、<CODE><EM>limit</EM></CODE> 、以及 
  <CODE><EM>step</EM></CODE> 都是一些不可见的变量。这里给它们起的名字都仅仅用于解释方便。 
  <LI>如果第三个表达式（步长）没有给出，会把步长设为 1 。 
  <LI>你可以用 <B>break</B> 来退出 <B>for</B> 循环。 
  <LI>循环变量 <CODE>v</CODE> 是一个循环内部的局部变量；当 <B>for</B> 
  循环结束后，你就不能在使用它。如果你需要这个值，在退出循环前把它赋给另一个变量。 </LI></UL>
<P>一般形式的 <B>for</B> 
通过一个叫作叠代器（<EM>iterators</EM>）的函数工作。每次叠代，叠代器函数都会被调用以产生一个新的值，当这个值为 <B>nil</B> 
时，循环停止。一般形式的 <B>for</B> 循环的语法如下： <PRE>	stat ::= <B>for</B> namelist <B>in</B> explist1 <B>do</B> block <B>end</B>
	namelist ::= Name {`<B>,</B>&acute; Name}
</PRE>
<P><B>for</B> 语句好似这样 <PRE>     for <EM>var_1</EM>, ・・・, <EM>var_n</EM> in <EM>explist</EM> do <EM>block</EM> end
</PRE>
<P>它等价于这样一段代码： <PRE>     do
       local <EM>f</EM>, <EM>s</EM>, <EM>var</EM> = <EM>explist</EM>
       while true do
         local <EM>var_1</EM>, ・・・, <EM>var_n</EM> = <EM>f</EM>(<EM>s</EM>, <EM>var</EM>)
         <EM>var</EM> = <EM>var_1</EM>
         if <EM>var</EM> == nil then break end
         <EM>block</EM>
       end
     end
</PRE>
<P>注意以下几点： 
<UL>
  <LI><CODE><EM>explist</EM></CODE> 只会被计算一次。它返回三个值， 一个叠代器函数，一个状态，一个叠代器的初始值。 
  <LI><CODE><EM>f</EM></CODE>、 <CODE><EM>s</EM></CODE>、 以及 
  <CODE><EM>var</EM></CODE> 都是不可见的变量。这里给它们起的名字都只是为了解说方便。 
  <LI>你可以使用 <B>break</B> 来跳出 <B>for</B> 循环。 
  <LI>循环变量 <CODE><EM>var_i</EM></CODE> 对于循环来说是一个局部变量；你不可以在 <B>for</B> 
  循环结束后继续使用。如果你需要保留这些值，那么就在循环结束前赋值到别的变量里去。 </LI></UL>
<H3>2.4.6 - <A name=2.4.6>把函数调用作为语句段</A></H3>
<P>为了允许使用可能的副作用，函数调用可以被作为一个语句段执行： <PRE>	stat ::= functioncall
</PRE>
<P>在这种情况下，所有的返回值都被舍弃。函数调用在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.8">§2.5.8</A> 
中解释。 
<H3>2.4.7 - <A name=2.4.7>局部变量声名</A></H3>
<P>局部变量可以在语句块中任何地方声名。声名可以包含一个初始化赋值操作： <PRE>	stat ::= <B>local</B> namelist [`<B>=</B>&acute; explist1]
</PRE>
<P>如果有的话，初始化赋值操作的行为等同于赋值操作（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.3">§2.4.3</A>）。否则，所有的变量将被初始化为 
<B>nil</B>。 
<P>一个 chunk 同时也是一个语句块（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.1">§2.4.1</A>），所以局部变量可以放在 
chunk 中那些显式注明的语句块之外。这些局部变量的作用范围从声明起一直延伸到 chunk 末尾。 
<P>局部变量的可见规则在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.6">§2.6</A> 中解释。 
<H2>2.5 - <A name=2.5>表达式</A></H2>
<P>Lua 中有这些基本表达式： <PRE>	exp ::= prefixexp
	exp ::= <B>nil</B> | <B>false</B> | <B>true</B>
	exp ::= Number
	exp ::= String
	exp ::= function
	exp ::= tableconstructor
	exp ::= `<B>...</B>&acute;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | `<B>(</B>&acute; exp `<B>)</B>&acute;
</PRE>
<P>数字和字符串在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.1">§2.1</A> 
中解释；变量在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.3">§2.3</A> 
中解释；函数定义在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.9">§2.5.9</A> 
中解释；函数调用在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.8">§2.5.8</A> 
中解释； table 的构造在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.7">§2.5.7</A> 
中解释；可变参数的表达式写作三个点 ('<CODE>...</CODE>') ，它只能被用在有可变参数的函数中；这些在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.9">§2.5.9</A> 
中解释。 
<P>二元操作符包含有数学运算操作符（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.1">§2.5.1</A>），比较操作符（参见 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.2">§2.5.2</A>），逻辑操作符（参见 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.3">§2.5.3</A>），以及连接操作符（参见 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.4">§2.5.4</A>）。一元操作符包括负号（参见see 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.1">§2.5.1</A>），取反 
<B>not</B>（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.3">§2.5.3</A>），和取长度操作符（参见 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.5">§2.5.5</A>）。 

<P>函数调用和可变参数表达式都可以放在多重返回值中。如果表达式作为一个独立语句段出现（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.6">§2.4.6</A>）（这只能是一个函数调用），它们的返回列表将被对齐到零个元素，也就是忽略所有返回值。如果表达式用于表达式列表的最后（或者是唯一）的元素，就不会有任何的对齐操作（除非函数调用用括号括起来）。在任何其它的情况下，Lua 
将把表达式结果看成单一元素，忽略除第一个之外的任何值。 
<P>这里有一些例子： <PRE>     f()                -- 调整到 0 个结果
     g(f(), x)          -- f() 被调整到一个结果
     g(x, f())          -- g 被传入 x 加上所有 f() 的返回值
     a,b,c = f(), x     -- f() 被调整到一个结果 （ c 在这里被赋为 nil ）
     a,b = ...          -- a 被赋值为可变参数中的第一个，
                        -- b 被赋值为第二个 （如果可变参数中并没有对应的值，
						-- 这里 a 和 b 都有可能被赋为 nil）
     
     a,b,c = x, f()     -- f() 被调整为两个结果
     a,b,c = f()        -- f() 被调整为三个结果
     return f()         -- 返回 f() 返回的所有结果
     return ...         -- 返回所有从可变参数中接收来的值
     return x,y,f()     -- 返回 x, y, 以及所有 f() 的返回值
     {f()}              -- 用 f() 的所有返回值创建一个列表
     {...}              -- 用可变参数中的所有值创建一个列表
     {f(), nil}         -- f() 被调整为一个结果
</PRE>
<P>被括号括起来的表达式永远被当作一个值。所以， <CODE>(f(x,y,z))</CODE> 即使 <CODE>f</CODE> 
返回多个值，这个表达式永远是一个单一值。（<CODE>(f(x,y,z))</CODE> 的值是 <CODE>f</CODE> 返回的第一个值。如果 
<CODE>f</CODE> 不返回值的话，那么它的值就是 <B>nil</B> 。） 
<H3>2.5.1 - <A name=2.5.1>数学运算操作符</A></H3>
<P>Lua 支持常见的数学运算操作符：二元操作 <CODE>+</CODE> （加法）， <CODE>-</CODE> （减法），<CODE>*</CODE> 
（乘法）， <CODE>/</CODE> （除法）， <CODE>%</CODE> （取模），以及 <CODE>^</CODE> （幂）；和一元操作 
<CODE>-</CODE> （取负）。如果对数字操作，或是可以转换为数字的字符串（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.2.1">§2.2.1</A>），所有这些操作都依赖它通常的含义。幂操作可以对任何幂值都正常工作。比如， 
<CODE>x^(-0.5)</CODE> 将计算出 <CODE>x</CODE> 的平方根。取模操作被定义为 <PRE>     a % b == a - math.floor(a/b)*b
</PRE>
<P>这就是说，其结果是商相对负无穷圆整后的余数。（译注：负数对正数取模的结果为正数） 
<H3>2.5.2 - <A name=2.5.2>比较操作符</A></H3>
<P>Lua 中的比较操作符有 <PRE>     ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</PRE>
<P>这些操作的结果不是 <B>false</B> 就是 <B>true</B>。 
<P>等于操作 (<CODE>==</CODE>) 首先比较操作数的类型。如果类型不同，结果就是 
<B>false</B>。否则，继续比较值。数字和字符串都用常规的方式比较。对象 （table ，userdata ，thread 
，以及函数）以引用的形式比较：两个对象只有在它们指向同一个东西时才认为相等。每次你创建一个新对象（一个 table 或是 userdata ，thread 
函数），它们都各不相同，即不同于上次创建的东西。 
<P>你可以改变 Lua 比较 table 和 userdata 的方式，这需要使用 "eq" 这个原方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.2.1">§2.2.1</A> 
中提及的转换规则并不作用于比较操作。所以， <CODE>"0"==0</CODE> 等于 <B>false</B>，而且 <CODE>t[0]</CODE> 和 
<CODE>t["0"]</CODE> 描述的是 table 中不同的域。 
<P>操作符 <CODE>~=</CODE> 完全等价于 (<CODE>==</CODE>) 操作的反值。 
<P>大小比较操作以以下方式进行。如果参数都是数字，那么就直接做数字比较。否则，如果参数都是字符串，就用字符串比较的方式进行。再则，Lua 就试着调用 "lt" 
或是 "le" 元方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<H3>2.5.3 - <A name=2.5.3>逻辑操作符</A></H3>
<P>Lua 中的逻辑操作符有 <B>and</B>, <B>or</B>, 以及 <B>not</B>。和控制结构（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.4">§2.4.4</A>）一样，所有的逻辑操作符把 
<B>false</B> 和 <B>nil</B> 都作为假，而其它的一切都当作真。 
<P>取反操作 <B>not</B> 总是返回 <B>false</B> 或 <B>true</B> 中的一个。与操作符 <B>and</B> 在第一个参数为 
<B>false</B> 或 <B>nil</B> 时返回这第一个参数；否则，<B>and</B> 返回第二个参数。或操作符 <B>or</B> 
在第一个参数不为 <B>nil</B> 也不为 <B>false</B> 时，返回这第一个参数，否则返回第二个参数。 <B>and</B> 和 
<B>or</B> 都遵循短路规则；也就是说，第二个操作数只在需要的时候去求值。这里有一些例子： <PRE>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</PRE>
<P>（在这本手册中， --&gt; 指前面表达式的结果。） 
<H3>2.5.4 - <A name=2.5.4>连接符</A></H3>
<P>Lua 中字符串的连接操作符写作两个点 ('<CODE>..</CODE>')。如果两个操作数都是字符串或都是数字，连接操作将以 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.2.1">§2.2.1</A> 
中提到的规则把其转换为字符串。否则，会取调用元方法 "concat" （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<H3>2.5.5 - <A name=2.5.5>取长度操作符</A></H3>
<P>取长度操作符写作一元操作 <CODE>#</CODE>。字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。 
<P>table <CODE>t</CODE> 的长度被定义成一个整数下标 <CODE>n</CODE> 。它满足 <CODE>t[n]</CODE> 不是 
<B>nil</B> 而 <CODE>t[n+1]</CODE> 为 <B>nil</B>；此外，如果 <CODE>t[1]</CODE> 为 
<B>nil</B> ，<CODE>n</CODE> 就可能是零。对于常规的数组，里面从 1 到 <CODE>n</CODE> 
放着一些非空的值的时候，它的长度就精确的为 <CODE>n</CODE>，即最后一个值的下标。如果数组有一个“空洞” （就是说，<B>nil</B> 
值被夹在非空值之间），那么 <CODE>#t</CODE> 可能是指向任何一个是 <B>nil</B> 值的前一个位置的下标（就是说，任何一个 
<B>nil</B> 值都有可能被当成数组的结束）。 
<H3>2.5.6 - <A name=2.5.6>优先级</A></H3>
<P>Lua 中操作符的优先级写在下表中，从低到高优先级排序： <PRE>     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     ..
     +     -
     *     /     %
     not   #     - (unary)
     ^
</PRE>
<P>通常，你可以用括号来改变运算次序。连接操作符 ('<CODE>..</CODE>') 和幂操作 ('<CODE>^</CODE>') 
是从右至左的。其它所有的操作都是从左至右。 
<H3>2.5.7 - <A name=2.5.7>Table 构造</A></H3>
<P>table 构造子是一个构造 table 的表达式。每次构造子被执行，都会构造出一个新的 table 。构造子可以被用来构造一个空的 
table，也可以用来构造一个 table 并初始化其中的一些域。一般的构造子的语法如下 <PRE>	tableconstructor ::= `<B>{</B>&acute; [fieldlist] `<B>}</B>&acute;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= `<B>[</B>&acute; exp `<B>]</B>&acute; `<B>=</B>&acute; exp | Name `<B>=</B>&acute; exp | exp
	fieldsep ::= `<B>,</B>&acute; | `<B>;</B>&acute;
</PRE>
<P>每个形如 <CODE>[exp1] = exp2</CODE> 的域向 table 中增加新的一项，其键值为 <CODE>exp1</CODE> 而值为 
<CODE>exp2</CODE>。形如 <CODE>name = exp</CODE> 的域等价于 <CODE>["name"] = 
exp</CODE>。最后，形如 <CODE>exp</CODE> 的域等价于 <CODE>[i] = exp</CODE> ， 这里的 
<CODE>i</CODE> 是一个从 1 开始不断增长的数字。这这个格式中的其它域不会破坏其记数。举个例子： <PRE>     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</PRE>
<P>等价于 <PRE>     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</PRE>
<P>如果表单中最后一个域的形式是 <CODE>exp</CODE> 
，而且其表达式是一个函数调用或者是一个可变参数，那么这个表达式所有的返回值将连续的进入列表（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.8">§2.5.8</A>）。为了避免这一点，你可以用括号把函数调用（或是可变参数）括起来（参见 
<A href="http://www.codingnow.com/2000/download/lua_manual.html#2.5">§2.5</A>）。 
<P>初始化域表可以在最后多一个分割符，这样设计可以方便由机器生成代码。 
<H3>2.5.8 - <A name=2.5.8>函数调用</A></H3>
<P>Lua 中的函数调用的语法如下： <PRE>	functioncall ::= prefixexp args
</PRE>
<P>函数调用时，第一步，prefixexp 和 args 先被求值。如果 prefixexp 的值的类型是 
<EM>function</EM>，那么这个函数就被用给出的参数调用。否则 prefixexp 的元方法 "call" 就被调用，第一个参数就是 
prefixexp 的值，跟下来的是原来的调用参数（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<P>这样的形式 <PRE>	functioncall ::= prefixexp `<B>:</B>&acute; Name args
</PRE>
<P>可以用来调用 "方法"。这是 Lua 支持的一种语法糖。像 <CODE>v:name(<EM>args</EM>)</CODE> 这个样子，被解释成 
<CODE>v.name(v,<EM>args</EM>)</CODE>，这里 <CODE>v</CODE> 只会被求值一次。 
<P>参数的语法如下： <PRE>	args ::= `<B>(</B>&acute; [explist1] `<B>)</B>&acute;
	args ::= tableconstructor
	args ::= String
</PRE>
<P>所有参数的表达式求值都在函数调用之前。这样的调用形式 <CODE>f{<EM>fields</EM>}</CODE> 是一种语法糖用于表示 
<CODE>f({<EM>fields</EM>})</CODE>；这里指参数列表是一个单一的新创建出来的列表。而这样的形式 
<CODE>f'<EM>string</EM>'</CODE> （或是 <CODE>f"<EM>string</EM>"</CODE> 亦或是 
<CODE>f[[<EM>string</EM>]]</CODE>）也是一种语法糖，用于表示 
<CODE>f('<EM>string</EM>')</CODE>；这里指参数列表是一个单独的字符串。 
<P>因为表达式语法在 Lua 中比较自由，所以你不能在函数调用的 '<CODE>(</CODE>' 前换行。这个限制可以避免语言中的一些歧义。比如你这样写 <PRE>     a = f
     (g).x(a)
</PRE>
<P>Lua 将把它当作一个单一语句段， <CODE>a = f(g).x(a)</CODE> 
。因此，如果你真的想作为成两个语句段，你必须在它们之间写上一个分号。如果你真的想调用 <CODE>f</CODE>，你必须从 <CODE>(g)</CODE> 
前移去换行。 
<P>这样一种调用形式：<CODE>return</CODE> <EM>functioncall</EM> 将触发一个尾调用。 Lua 
实现了适当的尾部调用（或是适当的尾递归）：在尾调用中，被调用的函数重用调用它的函数的堆栈项。因此，对于程序执行的嵌套尾调用的层数是没有限制的。然而，尾调用将删除调用它的函数的任何调试信息。注意，尾调用只发生在特定的语法下，这时， 
<B>return</B> 只有单一函数调用作为参数；这种语法使得调用函数的结果可以精确返回。因此，下面这些例子都不是尾调用： <PRE>     return (f(x))        -- 返回值被调整为一个
     return 2 * f(x)
     return x, f(x)       -- 最加若干返回值
     f(x); return         -- 无返回值
     return x or f(x)     -- 返回值被调整为一个
</PRE>
<H3>2.5.9 - <A name=2.5.9>函数定义</A></H3>
<P>函数定义的语法如下： <PRE>	function ::= <B>function</B> funcbody
	funcbody ::= `<B>(</B>&acute; [parlist1] `<B>)</B>&acute; block <B>end</B>
</PRE>
<P>另外定义了一些语法糖简化函数定义的写法： <PRE>	stat ::= <B>function</B> funcname funcbody
	stat ::= <B>local</B> <B>function</B> Name funcbody
	funcname ::= Name {`<B>.</B>&acute; Name} [`<B>:</B>&acute; Name]
</PRE>
<P>这样的写法： <PRE>     function f () <EM>body</EM> end
</PRE>
<P>被转换成 <PRE>     f = function () <EM>body</EM> end
</PRE>
<P>这样的写法： <PRE>     function t.a.b.c.f () <EM>body</EM> end
</PRE>
<P>被转换成 <PRE>     t.a.b.c.f = function () <EM>body</EM> end
</PRE>
<P>这样的写法： <PRE>     local function f () <EM>body</EM> end
</PRE>
<P>被转换成 <PRE>     local f; f = function () <EM>body</EM> end
</PRE>
<P>注意，并不是转换成 <PRE>     local f = function () <EM>body</EM> end
</PRE>
<P>（这个差别只在函数体内需要引用 <CODE>f</CODE> 时才有。） 
<P>一个函数定义是一个可执行的表达式，执行结果是一个类型为 <EM>function</EM> 的值。当 Lua 预编译一个 chunk 的时候， chunk 
作为一个函数，整个函数体也就被预编译了。那么，无论何时 Lua 执行了函数定义，这个函数本身就被实例化了（或者说是关闭了）。这个函数的实例（或者说是 
<EM>closure</EM>（闭包））是表达式的最终值。相同函数的不同实例有可能引用不同的外部局部变量，也可能拥有不同的环境表。 
<P>形参（函数定义需要的参数）是一些由实参（实际传入参数）的值初始化的局部变量： <PRE>	parlist1 ::= namelist [`<B>,</B>&acute; `<B>...</B>&acute;] | `<B>...</B>&acute;
</PRE>
<P>当一个函数被调用，如果函数没有被定义为接收不定长参数，即在形参列表的末尾注明三个点 
('<CODE>...</CODE>')，那么实参列表就会被调整到形参列表的长度，变长参数函数不会调整实参列表；取而代之的是，它将把所有额外的参数放在一起通过变长参数表达式传递给函数，其写法依旧是三个点。这个表达式的值是一串实参值的列表，看起来就跟一个可以返回多个结果的函数一样。如果一个变长参数表达式放在另一个表达式中使用，或是放在另一串表达式的中间，那么它的返回值就会被调整为单个值。若这个表达式放在了一系列表达式的最后一个，就不会做调整了（除非用括号给括了起来）。 

<P>我们先做如下定义，然后再来看一个例子： <PRE>     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</PRE>
<P>下面看看实参到形参数以及可变长参数的映射关系： <PRE>     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</PRE>
<P>结果由 <B>return</B> 来返回（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.4.4">§2.4.4</A>）。如果执行到函数末尾依旧没有遇到任何 
<B>return</B> 语句，函数就不会返回任何结果。 
<P>冒号语法可以用来定义方法，就是说，函数可以有一个隐式的形参 <CODE>self</CODE>。因此，如下写法： <PRE>     function t.a.b.c:f (<EM>params</EM>) <EM>body</EM> end
</PRE>
<P>是这样一种写法的语法糖： <PRE>     t.a.b.c.f = function (self, <EM>params</EM>) <EM>body</EM> end
</PRE>
<H2>2.6 - <A name=2.6>可视规则</A></H2>
<P>Lua 是一个有词法作用范围的语言。变量的作用范围开始于声明它们之后的第一个语句段，结束于包含这个声明的最内层语句块的结束点。看下面这些例子： <PRE>     x = 10                -- 全局变量
     do                    -- 新的语句块
       local x = x         -- 新的一个 'x', 它的值现在是 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一个语句块
         local x = x+1     -- 又一个 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  （取到的是全局的那一个）
</PRE>
<P>注意这里，类似 <CODE>local x = x</CODE> 这样的声明，新的 <CODE>x</CODE> 
正在被声明，但是还没有进入它的作用范围，所以第二个 <CODE>x</CODE> 指向的是外面一层的变量。 
<P>因为有这样一个词法作用范围的规则，所以可以在函数内部自由的定义局部变量并使用它们。当一个局部变量被更内层的函数中使用的时候，它被内层函数称作 
<EM>upvalue</EM>（上值），或是 <EM>外部局部变量</EM>。 
<P>注意，每次执行到一个 local 语句都会定义出一个新的局部变量。看看这样一个例子： <PRE>     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</PRE>
<P>这个循环创建了十个 closure（这指十个匿名函数的实例）。这些 closure 中的每一个都使用了不同的 <CODE>y</CODE> 
变量，而它们又共享了同一份 <CODE>x</CODE>。 
<H2>2.7 - <A name=2.7>错误处理</A></H2>
<P>因为 Lua 是一个嵌入式的扩展语言，所有的 Lua 动作都是从宿主程序的 C 代码调用 Lua 库（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A>）中的一个函数开始的。在 
Lua 编译或运行的任何时候发生了错误，控制权都会交还给 C ，而 C 可以来做一些恰当的措施（比如打印出一条错误信息）。 
<P>Lua 代码可以显式的调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-error"><CODE>error</CODE></A> 
函数来产生一条错误。如果你需要在 Lua 中捕获发生的错误，你可以使用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-pcall"><CODE>pcall</CODE></A> 
函数。 
<H2>2.8 - <A name=2.8>Metatable（元表）</A></H2>
<P>Lua 中的每个值都可以用一个 <EM>metatable</EM>。这个 <EM>metatable</EM> 就是一个原始的 Lua table 
，它用来定义原始值在特定操作下的行为。你可以通过在 metatable 中的特定域设一些值来改变拥有这个 metatable 
的值的指定操作之行为。举例来说，当一个非数字的值作加法操作的时候， Lua 会检查它的 metatable 中 <CODE>"__add"</CODE> 
域中的是否有一个函数。如果有这么一个函数的话，Lua 调用这个函数来执行一次加法。 
<P>我们叫 metatable 中的键名为 <EM>事件 (event)</EM> ，把其中的值叫作 <EM>元方法 
(metamethod)</EM>。在上个例子中，事件是 <CODE>"add"</CODE> 而元方法就是那个执行加法操作的函数。 
<P>你可以通过 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-getmetatable"><CODE>getmetatable</CODE></A> 
函数来查询到任何一个值的 metatable。 
<P>你可以通过 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-setmetatable"><CODE>setmetatable</CODE></A> 
函数来替换掉 table 的 metatable 。你不能从 Lua 中改变其它任何类型的值的 metatable （使用 debug 
库例外）；要这样做的话必须使用 C API 。 
<P>每个 table 和 userdata 拥有独立的 metatable （当然多个 table 和 userdata 可以共享一个相同的表作它们的 
metatable）；其它所有类型的值，每种类型都分别共享唯一的一个 metatable。因此，所有的数字一起只有一个 metatable 
，所有的字符串也是，等等。 
<P>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为， metatable 
中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 
需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。 
<P>metatable 可以控制的操作已在下面列出来。每个操作都用相应的名字区分。每个操作的键名都是用操作名字加上两个下划线 
'<CODE>__</CODE>' 前缀的字符串；举例来说，"add" 操作的键名就是字符串 <CODE>"__add"</CODE>。这些操作的语义用一个 
Lua 函数来描述解释器如何执行更为恰当。 
<P>这里展示的用 Lua 写的代码仅作解说用；实际的行为已经硬编码在解释器中，其执行效率要远高于这些模拟代码。这些用于描述的的代码中用到的函数（ <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-rawget"><CODE>rawget</CODE></A> 
， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-tonumber"><CODE>tonumber</CODE></A> 
，等等。）都可以在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#5.1">§5.1</A> 
中找到。特别注意，我们使用这样一个表达式来从给定对象中提取元方法 <PRE>     metatable(obj)[event]
</PRE>
<P>这个应该被解读作 <PRE>     rawget(getmetatable(obj) or {}, event)
</PRE>
<P>这就是说，访问一个元方法不再会触发任何的元方法，而且访问一个没有 metatable 的对象也不会失败（而只是简单返回 <B>nil</B>）。 
<UL>
  <LI><B>"add":</B> <CODE>+</CODE> 操作。 
  <P>下面这个 <CODE>getbinhandler</CODE> 函数定义了 Lua 怎样选择一个处理器来作二元操作。首先，Lua 
  尝试第一个操作数。如果这个东西的类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。 <PRE>     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
</PRE>
  <P>通过这个函数， <CODE>op1 + op2</CODE> 的行为就是 <PRE>     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- 两个操作数都是数字？
         return o1 + o2   -- 这里的 '+' 是原生的 'add'
       else  -- 至少一个操作数不是数字时
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- 以两个操作数来调用处理器
           return h(op1, op2)
         else  -- 没有处理器：缺省行为
           error(・・・)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"sub":</B> <CODE>-</CODE> 操作。 其行为类似于 "add" 操作。 
  <LI><B>"mul":</B> <CODE>*</CODE> 操作。 其行为类似于 "add" 操作。 
  <LI><B>"div":</B> <CODE>/</CODE> 操作。 其行为类似于 "add" 操作。 
  <LI><B>"mod":</B> <CODE>%</CODE> 操作。 其行为类似于 "add" 操作，它的原生操作是这样的 <CODE>o1 - 
  floor(o1/o2)*o2</CODE> 
  <LI><B>"pow":</B> <CODE>^</CODE> （幂）操作。 其行为类似于 "add" 操作，它的原生操作是调用 
  <CODE>pow</CODE> 函数（通过 C math 库）。 
  <LI><B>"unm":</B> 一元 <CODE>-</CODE> 操作。 <PRE>     function unm_event (op)
       local o = tonumber(op)
       if o then  -- 操作数是数字？
         return -o  -- 这里的 '-' 是一个原生的 'unm'
       else  -- 操作数不是数字。
         -- 尝试从操作数中得到处理器
         local h = metatable(op).__unm
         if h then
           -- 以操作数为参数调用处理器
           return h(op)
         else  -- 没有处理器：缺省行为
           error(・・・)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"concat":</B> <CODE>..</CODE> （连接）操作， <PRE>     function concat_event (op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- 原生字符串连接
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return h(op1, op2)
         else
           error(・・・)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"len":</B> <CODE>#</CODE> 操作。 <PRE>     function len_event (op)
       if type(op) == "string" then
         return strlen(op)         -- 原生的取字符串长度
       elseif type(op) == "table" then
         return #op                -- 原生的取 table 长度
       else
         local h = metatable(op).__len
         if h then
           -- 调用操作数的处理器
           return h(op)
         else  -- 没有处理器：缺省行为
           error(・・・)
         end
       end
     end
</PRE>
  <P>关于 table 的长度参见 <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.5">§2.5.5</A> 
  。 </P>
  <LI><B>"eq":</B> <CODE>==</CODE> 操作。 函数 <CODE>getcomphandler</CODE> 定义了 Lua 
  怎样选择一个处理器来作比较操作。元方法仅仅在参于比较的两个对象类型相同且有对应操作相同的元方法时才起效。 <PRE>     function getcomphandler (op1, op2, event)
       if type(op1) ~= type(op2) then return nil end
       local mm1 = metatable(op1)[event]
       local mm2 = metatable(op2)[event]
       if mm1 == mm2 then return mm1 else return nil end
     end
</PRE>
  <P>"eq" 事件按如下方式定义： <PRE>     function eq_event (op1, op2)
       if type(op1) ~= type(op2) then  -- 不同的类型？
         return false   -- 不同的对象
       end
       if op1 == op2 then   -- 原生的相等比较结果？
         return true   -- 对象相等
       end
       -- 尝试使用元方法
       local h = getcomphandler(op1, op2, "__eq")
       if h then
         return h(op1, op2)
       else
         return false
       end
     end
</PRE>
  <P><CODE>a ~= b</CODE> 等价于 <CODE>not (a == b)</CODE> 。 </P>
  <LI><B>"lt":</B> <CODE>&lt;</CODE> 操作。 <PRE>     function lt_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt; op2   -- 数字比较
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt; op2   -- 字符串按逐字符比较
       else
         local h = getcomphandler(op1, op2, "__lt")
         if h then
           return h(op1, op2)
         else
           error(・・・);
         end
       end
     end
</PRE>
  <P><CODE>a &gt; b</CODE> 等价于 <CODE>b &lt; a</CODE>. </P>
  <LI><B>"le":</B> <CODE>&lt;=</CODE> 操作。 <PRE>     function le_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt;= op2   -- 数字比较
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt;= op2   -- 字符串按逐字符比较
       else
         local h = getcomphandler(op1, op2, "__le")
         if h then
           return h(op1, op2)
         else
           h = getcomphandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(・・・);
           end
         end
       end
     end
</PRE>
  <P><CODE>a &gt;= b</CODE> 等价于 <CODE>b &lt;= a</CODE> 。注意，如果元方法 "le" 没有提供，Lua 
  就尝试 "lt" ，它假定 <CODE>a &lt;= b</CODE> 等价于 <CODE>not (b &lt; a)</CODE> 。 </P>
  <LI><B>"index":</B> 取下标操作用于访问 <CODE>table[key]</CODE> 。 <PRE>     function gettable_event (table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error(・・・);
         end
       end
       if type(h) == "function" then
         return h(table, key)      -- 调用处理器
       else return h[key]          -- 或是重复上述操作
       end
     end
</PRE>
  <P></P>
  <LI><B>"newindex":</B> 赋值给指定下标 <CODE>table[key] = value</CODE> 。 <PRE>     function settable_event (table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error(・・・);
         end
       end
       if type(h) == "function" then
         return h(table, key,value)    -- 调用处理器
       else h[key] = value             -- 或是重复上述操作
       end
     end
</PRE>
  <P></P>
  <LI><B>"call":</B> 当 Lua 调用一个值时调用。 <PRE>     function function_event (func, ...)
       if type(func) == "function" then
         return func(...)   -- 原生的调用
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(・・・)
         end
       end
     end
</PRE>
  <P></P></LI></UL>
<H2>2.9 - <A name=2.9>环境</A></H2>
<P>类型为 thread ，function ，以及 userdata 的对象，除了 metatable 
外还可以用另外一个与之关联的被称作它们的环境的一个表，像 metatable 一样，环境也是一个常规的 table ，多个对象可以共享同一个环境。 
<P>userdata 的环境在 Lua 中没有意义。这个东西只是为了在程序员想把一个表关联到一个 userdata 上时提供便利。 
<P>关联在线程上的环境被称作全局环境。全局环境被用作它其中的线程以及线程创建的非嵌套函数（通过 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-loadfile"><CODE>loadfile</CODE></A> 
， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-loadstring"><CODE>loadstring</CODE></A> 
或是 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-load"><CODE>load</CODE></A> 
）的缺省环境。而且它可以被 C 代码直接访问（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.3">§3.3</A>）。 
<P>关联在 C 函数上的环境可以直接被 C 代码访问（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.3">§3.3</A>）。它们会作为这个 
C 函数中创建的其它函数的缺省环境。 
<P>关联在 Lua 函数上的环境用来接管在函数内对全局变量（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.3">§2.3</A>）的所有访问。它们也会作为这个函数内创建的其它函数的缺省环境。 

<P>你可以通过调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-setfenv"><CODE>setfenv</CODE></A> 
来改变一个 Lua 函数或是正在运行中的线程的环境。而想操控其它对象（userdata、C 函数、其它线程）的环境的话，就必须使用 C API 。 
<H2>2.10 - <A name=2.10>垃圾收集</A></H2>
<P>Lua 提供了一个自动的内存管理。这就是说你不需要关心创建新对象的分配内存操作，也不需要在这些对象不再需要时的主动释放内存。 Lua 
通过运行一个垃圾收集器来自动管理内存，以此一遍又一遍的回收死掉的对象（这是指 Lua 中不再访问的到的对象）占用的内存。 Lua 中所有对象都被自动管理，包括： 
table, userdata、 函数、线程、和字符串。 
<P>Lua 实现了一个增量标记清除的收集器。它用两个数字来控制垃圾收集周期： <EM>garbage-collector pause</EM> 和 
<EM>garbage-collector step multiplier</EM> 。 
<P>garbage-collector pause 控制了收集器在开始一个新的收集周期之前要等待多久。随着数字的增大就导致收集器工作工作的不那么主动。小于 1 
的值意味着收集器在新的周期开始时不再等待。当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。 
<P>step multiplier 控制了收集器相对内存分配的速度。更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。小于 1 
的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。 
<P>你可以通过在 C 中调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_gc"><CODE>lua_gc</CODE></A> 
或是在 Lua 中调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-collectgarbage"><CODE>collectgarbage</CODE></A> 
来改变这些数字。两者都接受百分比数值（因此传入参数 100 意味着实际值 1 ）。通过这些函数，你也可以直接控制收集器（例如，停止或是重启）。 
<H3>2.10.1 - <A name=2.10.1>垃圾收集的元方法</A></H3>
<P>使用 C API　，你可以给 userdata （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）设置一个垃圾收集的元方法。这个元方法也被称为结束子。结束子允许你用额外的资源管理器和 
Lua 的内存管理器协同工作（比如关闭文件、网络连接、或是数据库连接，也可以说释放你自己的内存）。 
<P>一个 userdata 可被回收，若它的 metatable 中有 <CODE>__gc</CODE> 
这个域　，垃圾收集器就不立即收回它。取而代之的是，Lua 把它们放到一个列表中。最收集结束后，Lua 针对列表中的每个 userdata 
执行了下面这个函数的等价操作： <PRE>     function gc_event (udata)
       local h = metatable(udata).__gc
       if h then
         h(udata)
       end
     end
</PRE>
<P>在每个垃圾收集周期的结尾，每个在当前周期被收集起来的 userdata 
的结束子会以它们构造时的逆序依次调用。也就是说，收集列表中，最后一个在程序中被创建的 userdata 的结束子会被第一个调用。 
<H3>2.10.2 - <A name=2.10.2>Weak Table（弱表）</A></H3>
<P><EM>weak table</EM> 是一个这样的 
table，它其中的元素都被弱引用。弱引用将被垃圾收集器忽略掉，换句话说，如果对一个对象的引用只有弱引用，垃圾收集器将回收这个对象。 
<P>weak table 的键和值都可以是 weak 的。如果一个 table 只有键是 weak 
的，那么将运行收集器回收它们的键，但是会阻止回收器回收对应的值。而一个 table 的键和值都是 weak 
时，就即允许收集器回收键又允许收回值。任何情况下，如果键和值中任一个被回收了，整个键值对就会从 table 中拿掉。 table 的 weak 
特性可以通过在它的 metatable 中设置 <CODE>__mode</CODE> 域来改变。如果 <CODE>__mode</CODE> 
域中是一个包含有字符 '<CODE>k</CODE>' 的字符串时， table 的键就是 weak 的。如果 <CODE>__mode</CODE> 
域中是一个包含有字符 '<CODE>v</CODE>' 的字符串时， table 的值就是 weak 的。 
<P>在你把一个 table 当作一个 metatable 使用之后，就不能再修改 <CODE>__mode</CODE> 域的值。否则，受这个 
metatable 控制的 table 的 weak 行为就成了未定义的。 
<H2>2.11 - <A name=2.11>Coroutine （协同例程）</A></H2>
<P>Lua 支持 coroutine ，这个东西也被称为协同式多线程 (<EM>collaborative multithreading</EM>)　。 
Lua 为每个 coroutine 提供一个独立的运行线路。然而和多线程系统中的线程不同，coroutine 只在显式的调用了 yield 函数时才会挂起。 
<P>创建一个 coroutine 需要调用一次 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.create"><CODE>coroutine.create</CODE></A> 
。它只接收单个参数，这个参数是 coroutine 的主函数。 <CODE>create</CODE> 函数仅仅创建一个新的 coroutine 
然后返回它的控制器（一个类型为 <EM>thread</EM> 的对象）；它并不会启动 coroutine 的运行。 
<P>当你第一次调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
时，所需传入的第一个参数就是 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.create"><CODE>coroutine.create</CODE></A> 
的返回值。这时，coroutine 从主函数的第一行开始运行。接下来传入 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
的参数将被传进 coroutine 的主函数。在 coroutine 开始运行后，它讲运行到自身终止或是遇到一个 <EM>yields</EM> 。 
<P>coroutine 可以通过两种方式来终止运行：一种是正常退出，指它的主函数返回（最后一条指令被运行后，无论有没有显式的返回指令）; 
另一种是非正常退出，它发生在未保护的错误发生的时候。第一种情况中， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
返回 <B>true</B> ，接下来会跟着 coroutine 主函数的一系列返回值。第二种发生错误的情况下， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
返回 <B>false</B> ，紧接着是一条错误信息。 
<P>coroutine 中切换出去，可以调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.yield"><CODE>coroutine.yield</CODE></A>。当 
coroutine 切出，与之配合的 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
就立即返回，甚至在 yield 发生在内层的函数调用中也可以（就是说，这不限于发生在主函数中，也可以是主函数直接或间接调用的某个函数里）。在 yield 
的情况下，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
也是返回 <B>true</B>，紧跟着那些被传入 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.yield"><CODE>coroutine.yield</CODE></A> 
的参数。等到下次你在继续同样的 coroutine ，将从调用 yield 的断点处运行下去。断点处 yield 的返回值将是 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
传入的参数。 
<P>类似 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.create"><CODE>coroutine.create</CODE></A> 
， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.wrap"><CODE>coroutine.wrap</CODE></A> 
这个函数也将创建一个 coroutine ，但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 
coroutine 运行。所有传入这个函数的参数等同于传入 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
的参数。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.wrap"><CODE>coroutine.wrap</CODE></A> 
会返回所有应该由除第一个（错误代码的那个布尔量）之外的由 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
返回的值。和 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.resume"><CODE>coroutine.resume</CODE></A> 
不同， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-coroutine.wrap"><CODE>coroutine.wrap</CODE></A> 
不捕获任何错误；所有的错误都应该由调用者自己传递。 
<P>看下面这段代码展示的一个例子： <PRE>     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
            
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</PRE>
<P>当你运行它，将得到如下输出结果： <PRE>     co-body 1       10
     foo     2
     
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</PRE>
<H1>3 - <A name=3>程序接口（API）</A></H1>
<P>这个部分描述了 Lua 的 C API ，也就是宿主程序跟 Lua 通讯用的一组 C 函数。所有的 API 函数按相关的类型以及常量都声明在头文件 <A 
name=pdf-lua.h><CODE>lua.h</CODE></A> 中。 
<P>虽然我们说的是“函数”，但一部分简单的 API 是以宏的形式提供的。所有的这些宏都只使用它们的参数一次（除了第一个参数，也就是 lua 
状态机），因此你不需担心这些宏的展开会引起一些副作用。 
<P>在所有的 C 库中，Lua API 函数都不去检查参数的有效性和坚固性。然而，你可以在编译 Lua 时加上打开一个宏开关来开启 
<CODE>luaconf.h</CODE> 文件中的宏 <A 
name=pdf-luai_apicheck><CODE>luai_apicheck</CODE></A> 以改变这个行为。 
<H2>3.1 - <A name=3.1>堆栈</A></H2>
<P>Lua 使用一个虚拟栈来和 C 传递值。栈上的的每个元素都是一个 Lua 值（<B>nil</B>，数字，字符串，等等）。 
<P>无论何时 Lua 调用 C，被调用的函数都得到一个新的栈，这个栈独立于 C 函数本身的堆栈，也独立于以前的栈。（译注：在 C 函数里，用 Lua API 
不能访问到 Lua 状态机中本次调用之外的堆栈中的数据）它里面包含了 Lua 传递给 C 函数的所有参数，而 C 
函数则把要返回的结果也放入堆栈以返回给调用者（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_CFunction"><CODE>lua_CFunction</CODE></A>）。 

<P>方便起见，所有针对栈的 API 
查询操作都不严格遵循栈的操作规则。而是可以用一个索引来指向栈上的任何元素：正的索引指的是栈上的绝对位置（从一开始）；负的索引则指从栈顶开始的偏移量。更详细的说明一下，如果堆栈有 
n 个元素，那么索引 1 表示第一个元素（也就是最先被压入堆栈的元素）而索引 n 则指最后一个元素；索引 -1 也是指最后一个元素（即栈顶的元素），索引 -n 
是指第一个元素。如果索引在 1 到栈顶之间（也就是，<CODE>1 ≤ abs(index) ≤ top</CODE>）我们就说这是个有效的索引。 
<H2>3.2 - <A name=3.2>堆栈尺寸</A></H2>
<P>当你使用 Lua API 时，就有责任保证其坚固性。特别需要注意的是，你有责任控制不要堆栈溢出。你可以使用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_checkstack"><CODE>lua_checkstack</CODE></A> 
这个函数来扩大可用堆栈的尺寸。 
<P>无论何时 Lua 调用 C ，它都只保证 <A name=pdf-LUA_MINSTACK><CODE>LUA_MINSTACK</CODE></A> 
这么多的堆栈空间可以使用。 <CODE>LUA_MINSTACK</CODE> 一般被定义为 20　，因此，只要你不是不断的把数据压栈，通常你不用关心堆栈大小。 

<P>所有的查询函数都可以接收一个索引，只要这个索引是任何栈提供的空间中的值。栈能提供的最大空间是通过 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_checkstack"><CODE>lua_checkstack</CODE></A> 
来设置的。这些索引被称作可接受的索引，通常我们把它定义为： <PRE>     (index &lt; 0 &amp;&amp; abs(index) &lt;= top) ||
     (index &gt; 0 &amp;&amp; index &lt;= stackspace)
</PRE>
<P>注意，0 永远都不是一个可接受的索引。（译注：下文中凡提到的索引，没有特别注明的话，都指可接受的索引。） 
<H2>3.3 - <A name=3.3>伪索引</A></H2>
<P>除了特别声明外，任何一个函数都可以接受另一种有效的索引，它们被称作“伪索引”。这个可以帮助 C 代码访问一些并不在栈上的 Lua 
值。伪索引被用来访问线程的环境，函数的环境，注册表，还有 C 函数的 upvalue （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.4">§3.4</A>）。 
<P>线程的环境（也就是全局变量放的地方）通常在伪索引 <A 
name=pdf-LUA_GLOBALSINDEX><CODE>LUA_GLOBALSINDEX</CODE></A> 处。正在运行的 C 
函数的环境则放在伪索引 <A name=pdf-LUA_ENVIRONINDEX><CODE>LUA_ENVIRONINDEX</CODE></A> 之处。 
<P>你可以用常规的 table 操作来访问和改变全局变量的值，只需要指定环境表的位置。举例而言，要访问全局变量的值，这样做： <PRE>     lua_getfield(L, LUA_GLOBALSINDEX, varname);
</PRE>
<H2>3.4 - <A name=3.4>C Closure</A></H2>
<P>当 C 函数被创建出来，我们有可能会把一些值关联在一起，也就是创建一个 C closure ；这些被关联起来的值被叫做 upvalue 
，它们可以在函数被调用的时候访问的到。（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pushcclosure"><CODE>lua_pushcclosure</CODE></A>）。 

<P>无论何时去调用 C 函数，函数的 upvalue 都被放在指定的伪索引处。我们可以用 <A 
name=lua_upvalueindex><CODE>lua_upvalueindex</CODE></A> 这个宏来生成这些伪索引。第一个关联到函数的值放在 
<CODE>lua_upvalueindex(1)</CODE> 位置处，依次类推。任何情况下都可以用 
<CODE>lua_upvalueindex(<EM>n</EM>)</CODE> 产生一个 upvalue 的索引，即使　n 大于实际的 upvalue 
数量也可以。它都可以产生一个可接受但不一定有效的索引。 
<H2>3.5 - <A name=3.5>注册表</A></H2>
<P>Lua 提供了一个注册表，这是一个预定义出来的表，可以用来保存任何 C 代码想保存的 Lua 值。这个表可以用伪索引 <A 
name=pdf-LUA_REGISTRYINDEX><CODE>LUA_REGISTRYINDEX</CODE></A> 来定位。任何 C 
库都可以在这张表里保存数据，为了防止冲突，你需要特别小心的选择键名。一般的用法是，你可以用一个包含你的库名的字符串做为键名，或者可以取你自己 C 
代码中的一个地址，以 light userdata 的形式做键。 
<P>注册表里的整数健被用于补充库中实现的引用系统的工作，一般说来不要把它们用于别的用途。 
<H2>3.6 - <A name=3.6>C 中的错误处理</A></H2>
<P>在内部实现中，Lua 使用了 C 的 <CODE>longjmp</CODE> 机制来处理错误。（如果你使用 C++ 的话，也可以选择换用异常；参见 
<CODE>luaconf.h</CODE> 文件。）当 Lua 
碰到任何错误（比如内存分配错误、类型错误、语法错误、还有一些运行时错误）它都会产生一个错误出去；也就是调用一个 long jump 。在保护环境下，Lua 使用 
<CODE>setjmp</CODE> 来设置一个恢复点；任何发生的错误都会激活最近的一个恢复点。 
<P>几乎所有的 API 
函数都可能产生错误，例如内存分配错误。但下面的一些函数运行在保护环境中（也就是说它们创建了一个保护环境再在其中运行），因此它们不会产生错误出来： <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A>, 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_close"><CODE>lua_close</CODE></A>, 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>, 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A>, 
and <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_cpcall"><CODE>lua_cpcall</CODE></A>。 

<P>在 C 函数里，你也可以通过调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_error"><CODE>lua_error</CODE></A> 
产生一个错误。 
<H2>3.7 - <A name=3.7>函数和类型</A></H2>
<P>在这里我们按字母次序列出了所有 C API 中的函数和类型。 
<HR>

<H3><A name=lua_Alloc><CODE>lua_Alloc</CODE></A></H3><PRE>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</PRE>
<P>Lua 状态机中使用的内存分配器函数的类型。内存分配函数必须提供一个功能类似于 <CODE>realloc</CODE> 但又不完全相同的函数。它的参数有 
<CODE>ud</CODE> ，一个由 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A> 
传给它的指针； <CODE>ptr</CODE> ，一个指向已分配出来或是将被重新分配或是要释放的内存块指针； <CODE>osize</CODE> 
，内存块原来的尺寸； <CODE>nsize</CODE> ，新内存块的尺寸。如果且只有 <CODE>osize</CODE> 
是零时，<CODE>ptr</CODE> 为 <CODE>NULL</CODE> 。当 <CODE>nsize</CODE> 是零，分配器必须返回 
<CODE>NULL</CODE>；如果 <CODE>osize</CODE> 不是零，分配器应当释放掉 <CODE>ptr</CODE> 指向的内存块。当 
<CODE>nsize</CODE> 不是零，若分配器不能满足请求时，分配器返回 <CODE>NULL</CODE> 。当 <CODE>nsize</CODE> 
不是零而 <CODE>osize</CODE> 是零时，分配器应该和 <CODE>malloc</CODE> 有相同的行为。当 
<CODE>nsize</CODE> 和 <CODE>osize</CODE> 都不是零时，分配器则应和 <CODE>realloc</CODE> 
保持一样的行为。 Lua 假设分配器在 <CODE>osize &gt;= nsize</CODE> 时永远不会失败。 
<P>这里有一个简单的分配器函数的实现。这个实现被放在补充库中，由 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_newstate"><CODE>luaL_newstate</CODE></A> 
提供。 <PRE>     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</PRE>
<P>这段代码假设 <CODE>free(NULL)</CODE> 啥也不影响，而且 <CODE>realloc(NULL, size)</CODE> 等价于 
<CODE>malloc(size)</CODE>。这两点是 ANSI C 保证的行为。 
<HR>

<H3><A name=lua_atpanic><CODE>lua_atpanic</CODE></A></H3><PRE>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</PRE>
<P>设置一个新的 panic （恐慌） 函数，并返回前一个。 
<P>如果在保护环境之外发生了任何错误， Lua 就会调用一个 panic 函数，接着调用 
<CODE>exit(EXIT_FAILURE)</CODE>，这样就开始退出宿主程序。你的 panic 函数可以永远不返回（例如作一次长跳转）来避免程序退出。 

<P>panic 函数可以从栈顶取到出错信息。 
<HR>

<H3><A name=lua_call><CODE>lua_call</CODE></A></H3><PRE>void lua_call (lua_State *L, int nargs, int nresults);</PRE>
<P>调用一个函数。 
<P>要调用一个函数请遵循以下协议：首先，要调用的函数应该被压入堆栈；接着，把需要传递给这个函数的参数按正序压栈；这是指第一个参数首先压栈。最后调用一下 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_call"><CODE>lua_call</CODE></A>； 
<CODE>nargs</CODE> 
是你压入堆栈的参数个数。当函数调用完毕后，所有的参数以及函数本身都会出栈。而函数的返回值这时则被压入堆栈。返回值的个数将被调整为 
<CODE>nresults</CODE> 个，除非 <CODE>nresults</CODE> 被设置成 <A 
name=pdf-LUA_MULTRET><CODE>LUA_MULTRET</CODE></A>。在这种情况下，所有的返回值都被压入堆栈中。 Lua 
会保证返回值都放入栈空间中。函数返回值将按正序压栈（第一个返回值首先压栈），因此在调用结束后，最后一个返回值将被放在栈顶。 
<P>被调用函数内发生的错误将（通过 <CODE>longjmp</CODE>）一直上抛。 
<P>下面的例子中，这行 Lua 代码等价于在宿主程序用 C 代码做一些工作： <PRE>     a = f("how", t.x, 14)
</PRE>
<P>这里是 C 里的代码： <PRE>     lua_getfield(L, LUA_GLOBALSINDEX, "f");          /* 将调用的函数 */
     lua_pushstring(L, "how");                          /* 第一个参数 */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");          /* table 的索引 */
     lua_getfield(L, -1, "x");         /* 压入 t.x 的值（第 2 个参数）*/
     lua_remove(L, -2);                           /* 从堆栈中移去 't' */
     lua_pushinteger(L, 14);                           /* 第 3 个参数 */
     lua_call(L, 3, 1); /* 调用 'f'，传入 3 个参数，并索取 1 个返回值 */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");      /* 设置全局变量 'a' */
</PRE>
<P>注意上面这段代码是“平衡”的：到了最后，堆栈恢复成原由的配置。这是一种良好的编程习惯。 
<HR>

<H3><A name=lua_CFunction><CODE>lua_CFunction</CODE></A></H3><PRE>typedef int (*lua_CFunction) (lua_State *L);</PRE>
<P>C 函数的类型。 
<P>为了正确的和 Lua 通讯，C 函数必须使用下列定义了参数以及返回值传递方法的协议： C 函数通过 Lua 
中的堆栈来接受参数，参数以正序入栈（第一个参数首先入栈）。因此，当函数开始的时候， <CODE>lua_gettop(L)</CODE> 
可以返回函数收到的参数个数。第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 <CODE>lua_gettop(L)</CODE> 处。当需要向 
Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），然后返回这些返回值的个数。在这些返回值之下的，堆栈上的东西都会被 Lua 
丢掉。和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。 
<P>下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和： <PRE>     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数的个数 */
       lua_Number sum = 0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);   /* 第一个返回值 */
       lua_pushnumber(L, sum);     /* 第二个返回值 */
       return 2;                   /* 返回值的个数 */
     }
</PRE>
<HR>

<H3><A name=lua_checkstack><CODE>lua_checkstack</CODE></A></H3><PRE>int lua_checkstack (lua_State *L, int extra);</PRE>
<P>确保堆栈上至少有 <CODE>extra</CODE> 个空位。如果不能把堆栈扩展到相应的尺寸，函数返回 false 
。这个函数永远不会缩小堆栈；如果堆栈已经比需要的大了，那么就放在那里不会产生变化。 
<HR>

<H3><A name=lua_close><CODE>lua_close</CODE></A></H3><PRE>void lua_close (lua_State *L);</PRE>
<P>销毁指定 Lua 
状态机中的所有对象（如果有垃圾收集相关的元方法的话，会调用它们），并且释放状态机中使用的所有动态内存。在一些平台上，你可以不必调用这个函数，因为当宿主程序结束的时候，所有的资源就自然被释放掉了。另一方面，长期运行的程序，比如一个后台程序或是一个 
web 服务器，当不再需要它们的时候就应该释放掉相关状态机。这样可以避免状态机扩张的过大。 
<HR>

<H3><A name=lua_concat><CODE>lua_concat</CODE></A></H3><PRE>void lua_concat (lua_State *L, int n);</PRE>
<P>连接栈顶的 <CODE>n</CODE> 个值，然后将这些值出栈，并把结果放在栈顶。如果 <CODE>n</CODE> 为 1 
，结果就是一个字符串放在栈上（即，函数什么都不做）；如果 <CODE>n</CODE> 为 0 ，结果是一个空串。 连接依照 Lua 中创建语义完成（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.4">§2.5.4</A> 
）。 
<HR>

<H3><A name=lua_cpcall><CODE>lua_cpcall</CODE></A></H3><PRE>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</PRE>
<P>以保护模式调用 C 函数 <CODE>func</CODE> 。 <CODE>func</CODE> 只有能从堆栈上拿到一个参数，就是包含有 
<CODE>ud</CODE> 的 light userdata。当有错误时， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_cpcall"><CODE>lua_cpcall</CODE></A> 
返回和 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
相同的错误代码，并在栈顶留下错误对象；否则它返回零，并不会修改堆栈。所有从 <CODE>func</CODE> 内返回的值都会被扔掉。 
<HR>

<H3><A name=lua_createtable><CODE>lua_createtable</CODE></A></H3><PRE>void lua_createtable (lua_State *L, int narr, int nrec);</PRE>
<P>创建一个新的空 table 压入堆栈。这个新 table 将被预分配 <CODE>narr</CODE> 个元素的数组空间以及 
<CODE>nrec</CODE> 个元素的非数组空间。当你明确知道表中需要多少个元素时，预分配就非常有用。如果你不知道，可以使用函数 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newtable"><CODE>lua_newtable</CODE></A>。 

<HR>

<H3><A name=lua_dump><CODE>lua_dump</CODE></A></H3><PRE>int lua_dump (lua_State *L, lua_Writer writer, void *data);</PRE>
<P>把函数 dump 成二进制 chunk 。函数接收栈顶的 Lua 函数做参数，然后生成它的二进制 chunk 。若被 dump 
出来的东西被再次加载，加载的结果就相当于原来的函数。当它在产生 chunk 的时候，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_dump"><CODE>lua_dump</CODE></A> 
通过调用函数 <CODE>writer</CODE> （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Writer"><CODE>lua_Writer</CODE></A>）来写入数据，后面的 
<CODE>data</CODE> 参数会被传入 <CODE>writer</CODE> 。 
<P>最后一次由写入器 (writer) 返回值将作为这个函数的返回值返回； 0 表示没有错误。 
<P>这个函数不会把 Lua 返回弹出堆栈。 
<HR>

<H3><A name=lua_equal><CODE>lua_equal</CODE></A></H3><PRE>int lua_equal (lua_State *L, int index1, int index2);</PRE>
<P>如果依照 Lua 中 <CODE>==</CODE> 操作符语义，索引 <CODE>index1</CODE> 和 <CODE>index2</CODE> 
中的值相同的话，返回 1 。否则返回 0 。如果任何一个索引无效也会返回 0。 
<HR>

<H3><A name=lua_error><CODE>lua_error</CODE></A></H3><PRE>int lua_error (lua_State *L);</PRE>
<P>产生一个 Lua 错误。错误信息（实际上可以是任何类型的 Lua 值）必须被置入栈顶。这个函数会做一次长跳转，因此它不会再返回。（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_error"><CODE>luaL_error</CODE></A>）。 

<HR>

<H3><A name=lua_gc><CODE>lua_gc</CODE></A></H3><PRE>int lua_gc (lua_State *L, int what, int data);</PRE>
<P>控制垃圾收集器。 
<P>这个函数根据其参数 <CODE>what</CODE> 发起几种不同的任务： 
<UL>
  <LI><B><CODE>LUA_GCSTOP</CODE>:</B> 停止垃圾收集器。 
  <LI><B><CODE>LUA_GCRESTART</CODE>:</B> 重启垃圾收集器。 
  <LI><B><CODE>LUA_GCCOLLECT</CODE>:</B> 发起一次完整的垃圾收集循环。 
  <LI><B><CODE>LUA_GCCOUNT</CODE>:</B> 返回 Lua 使用的内存总量（以 K 字节为单位）。 
  <LI><B><CODE>LUA_GCCOUNTB</CODE>:</B> 返回当前内存使用量除以 1024 的余数。 
  <LI><B><CODE>LUA_GCSTEP</CODE>:</B> 发起一步增量垃圾收集。步数由 <CODE>data</CODE> 
  控制（越大的值意味着越多步），而其具体含义（具体数字表示了多少）并未标准化。如果你想控制这个步数，必须实验性的测试 <CODE>data</CODE> 
  的值。如果这一步结束了一个垃圾收集周期，返回返回 1 。 
  <LI><B><CODE>LUA_GCSETPAUSE</CODE>:</B> 把 <CODE>data</CODE>/100 设置为 
  <EM>garbage-collector pause</EM> 的新值（参见 <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#2.10">§2.10</A>）。函数返回以前的值。 

  <LI><B><CODE>LUA_GCSETSTEPMUL</CODE>:</B> 把 <CODE>arg</CODE>/100 设置成 <EM>step 
  multiplier</EM> （参见 <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#2.10">§2.10</A>）。函数返回以前的值。 
  </LI></UL>
<HR>

<H3><A name=lua_getallocf><CODE>lua_getallocf</CODE></A></H3><PRE>lua_Alloc lua_getallocf (lua_State *L, void **ud);</PRE>
<P>返回给定状态机的内存分配器函数。如果 <CODE>ud</CODE> 不是 <CODE>NULL</CODE> ，Lua 把调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A> 
时传入的那个指针放入 <CODE>*ud</CODE> 。 
<HR>

<H3><A name=lua_getfenv><CODE>lua_getfenv</CODE></A></H3><PRE>void lua_getfenv (lua_State *L, int index);</PRE>
<P>把索引处值的环境表压入堆栈。 
<HR>

<H3><A name=lua_getfield><CODE>lua_getfield</CODE></A></H3><PRE>void lua_getfield (lua_State *L, int index, const char *k);</PRE>
<P>把 <CODE>t[k]</CODE> 值压入堆栈，这里的 <CODE>t</CODE> 是指有效索引 <CODE>index</CODE> 指向的值。在 
Lua 中，这个函数可能触发对应 "index" 事件的元方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<HR>

<H3><A name=lua_getglobal><CODE>lua_getglobal</CODE></A></H3><PRE>void lua_getglobal (lua_State *L, const char *name);</PRE>
<P>把全局变量 <CODE>name</CODE> 里的值压入堆栈。这个是用一个宏定义出来的： <PRE>     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</PRE>
<HR>

<H3><A name=lua_getmetatable><CODE>lua_getmetatable</CODE></A></H3><PRE>int lua_getmetatable (lua_State *L, int index);</PRE>
<P>把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。 
<HR>

<H3><A name=lua_gettable><CODE>lua_gettable</CODE></A></H3><PRE>void lua_gettable (lua_State *L, int index);</PRE>
<P>把 <CODE>t[k]</CODE> 值压入堆栈，这里的 <CODE>t</CODE> 是指有效索引 <CODE>index</CODE> 指向的值，而 
<CODE>k</CODE> 则是栈顶放的值。 
<P>这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。在 Lua 中，这个函数可能触发对应 "index" 事件的元方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<HR>

<H3><A name=lua_gettop><CODE>lua_gettop</CODE></A></H3><PRE>int lua_gettop (lua_State *L);</PRE>
<P>返回栈顶元素的索引。因为索引是从 1 开始编号的，所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。 
<HR>

<H3><A name=lua_insert><CODE>lua_insert</CODE></A></H3><PRE>void lua_insert (lua_State *L, int index);</PRE>
<P>把栈顶元素插入指定的有效索引处，并依次移动这个索引之上的元素。不要用伪索引来调用这个函数，因为伪索引不是真正指向堆栈上的位置。 
<HR>

<H3><A name=lua_Integer><CODE>lua_Integer</CODE></A></H3><PRE>typedef ptrdiff_t lua_Integer;</PRE>
<P>这个类型被用于 Lua API 接收整数值。 
<P>缺省时这个被定义为 <CODE>ptrdiff_t</CODE> ，这个东西通常是机器能处理的最大整数类型。 
<HR>

<H3><A name=lua_isboolean><CODE>lua_isboolean</CODE></A></H3><PRE>int lua_isboolean (lua_State *L, int index);</PRE>
<P>当给定索引的值类型为 boolean 时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_iscfunction><CODE>lua_iscfunction</CODE></A></H3><PRE>int lua_iscfunction (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isfunction><CODE>lua_isfunction</CODE></A></H3><PRE>int lua_isfunction (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_islightuserdata><CODE>lua_islightuserdata</CODE></A></H3><PRE>int lua_islightuserdata (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个 light userdata 时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isnil><CODE>lua_isnil</CODE></A></H3><PRE>int lua_isnil (lua_State *L, int index);</PRE>
<P>当给定索引的值是 <B>nil</B> 时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isnumber><CODE>lua_isnumber</CODE></A></H3><PRE>int lua_isnumber (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isstring><CODE>lua_isstring</CODE></A></H3><PRE>int lua_isstring (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个字符串或是一个数字（数字总能转换成字符串）时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_istable><CODE>lua_istable</CODE></A></H3><PRE>int lua_istable (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个 table 时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isthread><CODE>lua_isthread</CODE></A></H3><PRE>int lua_isthread (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个 thread 时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_isuserdata><CODE>lua_isuserdata</CODE></A></H3><PRE>int lua_isuserdata (lua_State *L, int index);</PRE>
<P>当给定索引的值是一个 userdata （无论是完整的 userdata 还是 light userdata ）时，返回 1 ，否则返回 0 。 
<HR>

<H3><A name=lua_lessthan><CODE>lua_lessthan</CODE></A></H3><PRE>int lua_lessthan (lua_State *L, int index1, int index2);</PRE>
<P>如果索引 <CODE>index1</CODE> 处的值小于索引 <CODE>index2</CODE> 处的值时，返回 1 ；否则返回 0 。其语义遵循 
Lua 中的 <CODE>&lt;</CODE> 操作符（就是说，有可能调用元方法）。如果任何一个索引无效，也会返回 0 。 
<HR>

<H3><A name=lua_load><CODE>lua_load</CODE></A></H3><PRE>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</PRE>
<P>加载一个 Lua chunk 。如果没有错误， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
把一个编译好的 chunk 作为一个 Lua 函数压入堆栈。否则，压入出错信息。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
的返回值可以是： 
<UL>
  <LI><B>0:</B> 没有错误； 
  <LI><B><A name=pdf-LUA_ERRSYNTAX><CODE>LUA_ERRSYNTAX</CODE></A>:</B> 
  在预编译时碰到语法错误； 
  <LI><B><A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-LUA_ERRMEM"><CODE>LUA_ERRMEM</CODE></A>:</B> 
  内存分配错误。 </LI></UL>
<P>这个函数仅仅加栽 chunk ；而不会去运行它。 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
会自动检测 chunk 是文本的还是二进制的，然后做对应的加载操作（参见程序 <CODE>luac</CODE>）。 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
函数使用一个用户提供的 <CODE>reader</CODE> 函数来读取 chunk （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Reader"><CODE>lua_Reader</CODE></A>）。 
<CODE>data</CODE> 参数会被传入读取器函数。 
<P><CODE>chunkname</CODE> 这个参数可以赋予 chunk 一个名字，这个名字被用于出错信息和调试信息（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.8">§3.8</A>）。 
<HR>

<H3><A name=lua_newstate><CODE>lua_newstate</CODE></A></H3><PRE>lua_State *lua_newstate (lua_Alloc f, void *ud);</PRE>
<P>创建的一个新的独立的状态机。如果创建不了（因为内存问题）返回 <CODE>NULL</CODE> 。参数 <CODE>f</CODE> 是一个分配器函数； 
Lua 将通过这个函数做状态机内所有的内存分配操作。第二个参数 <CODE>ud</CODE> ，这个指针将在每次调用分配器时被直接传入。 
<HR>

<H3><A name=lua_newtable><CODE>lua_newtable</CODE></A></H3><PRE>void lua_newtable (lua_State *L);</PRE>
<P>创建一个空 table ，并将之压入堆栈。它等价于 <CODE>lua_createtable(L, 0, 0)</CODE> 。 
<HR>

<H3><A name=lua_newthread><CODE>lua_newthread</CODE></A></H3><PRE>lua_State *lua_newthread (lua_State *L);</PRE>
<P>创建一个新线程，并将其压入堆栈，并返回维护这个线程的 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_State"><CODE>lua_State</CODE></A> 
指针。这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table），但是它有独立的执行堆栈。 
<P>没有显式的函数可以用来关闭或销毁掉一个线程。线程跟其它 Lua 对象一样是垃圾收集的条目之一。 
<HR>

<H3><A name=lua_newuserdata><CODE>lua_newuserdata</CODE></A></H3><PRE>void *lua_newuserdata (lua_State *L, size_t size);</PRE>
<P>这个函数分配分配一块指定大小的内存块，把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址。 
<P>userdata 代表 Lua 中的 C 值。完整的 userdata 代表一块内存。它是一个对象（就像 table 
那样的对象）：你必须创建它，它有着自己的元表，而且它在被回收时，可以被监测到。一个完整的 userdata 只和它自己相等（在等于的原生作用下）。 
<P>当 Lua 通过 <CODE>gc</CODE> 元方法回收一个完整的 userdata 时， Lua 调用这个元方法并把 userdata 
标记为已终止。等到这个 userdata 再次被收集的时候，Lua 会释放掉相关的内存。 
<HR>

<H3><A name=lua_next><CODE>lua_next</CODE></A></H3><PRE>int lua_next (lua_State *L, int index);</PRE>
<P>从栈上弹出一个 key（键），然后把索引指定的表中 key-value（健值）对压入堆栈（指定 key 后面的下一 (next) 
对）。如果表中以无更多元素，那么 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_next"><CODE>lua_next</CODE></A> 
将返回 0 （什么也不压入堆栈）。 
<P>典型的遍历方法是这样的： <PRE>     /* table 放在索引 't' 处 */
     lua_pushnil(L);  /* 第一个 key */
     while (lua_next(L, t) != 0) {
       /* 用一下 'key' （在索引 -2 处） 和 'value' （在索引 -1 处） */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除 'value' ；保留 'key' 做下一次叠代 */
       lua_pop(L, 1);
     }
</PRE>
<P>在遍历一张表的时候，不要直接对 key 调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
，除非你知道这个 key 一定是一个字符串。调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
有可能改变给定索引位置的值；这会对下一次调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_next"><CODE>lua_next</CODE></A> 
造成影响。 
<HR>

<H3><A name=lua_Number><CODE>lua_Number</CODE></A></H3><PRE>typedef double lua_Number;</PRE>
<P>Lua 中数字的类型。确省是 double ，但是你可以在 <CODE>luaconf.h</CODE> 中修改它。 
<P>通过修改配置文件你可以改变 Lua 让它操作其它数字类型（例如：float 或是 long ）。 
<HR>

<H3><A name=lua_objlen><CODE>lua_objlen</CODE></A></H3><PRE>size_t lua_objlen (lua_State *L, int index);</PRE>
<P>返回指定的索引处的值的长度。对于 string ，那就是字符串的长度；对于 table ，是取长度操作符 ('<CODE>#</CODE>') 
的结果；对于 userdata ，就是为其分配的内存块的尺寸；对于其它值，为 0 。 
<HR>

<H3><A name=lua_pcall><CODE>lua_pcall</CODE></A></H3><PRE>lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</PRE>
<P>以保护模式调用一个函数。 
<P><CODE>nargs</CODE> 和 <CODE>nresults</CODE> 的含义与 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_call"><CODE>lua_call</CODE></A> 
中的相同。如果在调用过程中没有发生错误， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
的行为和 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_call"><CODE>lua_call</CODE></A> 
完全一致。但是，如果有错误发生的话， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
会捕获它，然后把单一的值（错误信息）压入堆栈，然后返回错误码。同 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_call"><CODE>lua_call</CODE></A> 
一样， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
总是把函数本身和它的参数从栈上移除。 
<P>如果 <CODE>errfunc</CODE> 是 0 ，返回在栈顶的错误信息就和原始错误信息完全一致。否则，<CODE>errfunc</CODE> 
就被当成是错误处理函数在栈上的索引。（在当前的实现里，这个索引不能是伪索引。）在发生运行时错误时，这个函数会被调用而参数就是错误信息。错误处理函数的返回值将被 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
作为出错信息返回在堆栈上。 
<P>典型的用法中，错误处理函数被用来在出错信息上加上更多的调试信息，比如栈跟踪信息 (stack traceback) 。这些信息在 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
返回后，因为栈已经展开 (unwound) ，所以收集不到了。 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A> 
函数在调用成功时返回 0 ，否则返回以下（定义在 <CODE>lua.h</CODE> 中的）错误代码中的一个： 
<UL>
  <LI><B><A name=pdf-LUA_ERRRUN><CODE>LUA_ERRRUN</CODE></A>:</B> 运行时错误。 
  <LI><B><A name=pdf-LUA_ERRMEM><CODE>LUA_ERRMEM</CODE></A>:</B> 
  内存分配错误。对于这种错，Lua 调用不了错误处理函数。 
  <LI><B><A name=pdf-LUA_ERRERR><CODE>LUA_ERRERR</CODE></A>:</B> 
  在运行错误处理函数时发生的错误。 </LI></UL>
<HR>

<H3><A name=lua_pop><CODE>lua_pop</CODE></A></H3><PRE>void lua_pop (lua_State *L, int n);</PRE>
<P>从堆栈中弹出 <CODE>n</CODE> 个元素。 
<HR>

<H3><A name=lua_pushboolean><CODE>lua_pushboolean</CODE></A></H3><PRE>void lua_pushboolean (lua_State *L, int b);</PRE>
<P>把 <CODE>b</CODE> 作为一个 boolean 值压入堆栈。 
<HR>

<H3><A name=lua_pushcclosure><CODE>lua_pushcclosure</CODE></A></H3><PRE>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</PRE>
<P>把一个新的 C closure 压入堆栈。 
<P>当创建了一个 C 函数后，你可以给它关联一些值，这样就是在创建一个 C closure （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.4">§3.4</A>）；接下来无论函数何时被调用，这些值都可以被这个函数访问到。为了将一些值关联到一个 
C 函数上，首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。接下来调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pushcclosure"><CODE>lua_pushcclosure</CODE></A> 
来创建出 closure 并把这个 C 函数压到堆栈上。参数 <CODE>n</CODE> 告之函数有多少个值需要关联到函数上。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pushcclosure"><CODE>lua_pushcclosure</CODE></A> 
也会把这些值从栈上弹出。 
<HR>

<H3><A name=lua_pushcfunction><CODE>lua_pushcfunction</CODE></A></H3><PRE>void lua_pushcfunction (lua_State *L, lua_CFunction f);</PRE>
<P>将一个 C 函数压入堆栈。这个函数接收一个 C 函数指针，并将一个类型为 <CODE>function</CODE> 的 Lua 
值压入堆栈。当这个栈定的值被调用时，将触发对应的 C 函数。 
<P>注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_CFunction"><CODE>lua_CFunction</CODE></A>）。 

<P><CODE>lua_pushcfunction</CODE> 是作为一个宏定义出现的： <PRE>     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</PRE>
<HR>

<H3><A name=lua_pushfstring><CODE>lua_pushfstring</CODE></A></H3><PRE>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</PRE>
<P>把一个格式化过的字符串压入堆栈，然后返回这个字符串的指针。它和 C 函数 <CODE>sprintf</CODE> 比较像，不过有一些重要的区别： 
<UL>
  <LI>摸你需要为结果分配空间：其结果是一个 Lua 字符串，由 Lua 来关心其内存分配（同时通过垃圾收集来释放内存）。 
  <LI>这个转换非常的受限。不支持 flag ，宽度，或是指定精度。它只支持下面这些： '<CODE>%%</CODE>' （插入一个 
  '<CODE>%</CODE>'）， '<CODE>%s</CODE>' （插入一个带零终止符的字符串，没有长度限制）， '<CODE>%f</CODE>' 
  （插入一个 <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Number"><CODE>lua_Number</CODE></A>）， 
  '<CODE>%p</CODE>' （插入一个指针或是一个十六进制数）， '<CODE>%d</CODE>' （插入一个 
  <CODE>int</CODE>)， '<CODE>%c</CODE>' （把一个 <CODE>int</CODE> 作为一个字符插入）。 </LI></UL>
<HR>

<H3><A name=lua_pushinteger><CODE>lua_pushinteger</CODE></A></H3><PRE>void lua_pushinteger (lua_State *L, lua_Integer n);</PRE>
<P>把 <CODE>n</CODE> 作为一个数字压栈。 
<HR>

<H3><A name=lua_pushlightuserdata><CODE>lua_pushlightuserdata</CODE></A></H3><PRE>void lua_pushlightuserdata (lua_State *L, void *p);</PRE>
<P>把一个 light userdata 压栈。 
<P>userdata 在 Lua 中表示一个 C 值。 light userdata 表示一个指针。它是一个像数字一样的值：你不需要专门创建它，它也没有独立的 
metatable ，而且也不会被收集（因为从来不需要创建）。只要表示的 C 地址相同，两个 light userdata 就相等。 
<HR>

<H3><A name=lua_pushlstring><CODE>lua_pushlstring</CODE></A></H3><PRE>void lua_pushlstring (lua_State *L, const char *s, size_t len);</PRE>
<P>把指针 <CODE>s</CODE> 指向的长度为 <CODE>len</CODE> 的字符串压栈。 Lua 
对这个字符串做一次内存拷贝（或是复用一个拷贝），因此 <CODE>s</CODE> 
处的内存在函数返回后，可以释放掉或是重用于其它用途。字符串内可以保存有零字符。 
<HR>

<H3><A name=lua_pushnil><CODE>lua_pushnil</CODE></A></H3><PRE>void lua_pushnil (lua_State *L);</PRE>
<P>把一个 nil 压栈。 
<HR>

<H3><A name=lua_pushnumber><CODE>lua_pushnumber</CODE></A></H3><PRE>void lua_pushnumber (lua_State *L, lua_Number n);</PRE>
<P>把一个数字 <CODE>n</CODE> 压栈。 
<HR>

<H3><A name=lua_pushstring><CODE>lua_pushstring</CODE></A></H3><PRE>void lua_pushstring (lua_State *L, const char *s);</PRE>
<P>把指针 <CODE>s</CODE> 指向的以零结尾的字符串压栈。 Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝），因此 
<CODE>s</CODE> 处的内存在函数返回后，可以释放掉或是重用于其它用途。字符串中不能包含有零字符；第一个碰到的零字符会认为是字符串的结束。 
<HR>

<H3><A name=lua_pushthread><CODE>lua_pushthread</CODE></A></H3><PRE>int lua_pushthread (lua_State *L);</PRE>
<P>把 <CODE>L</CODE> 中提供的线程压栈。如果这个线程是当前状态机的主线程的话，返回 1 。 
<HR>

<H3><A name=lua_pushvalue><CODE>lua_pushvalue</CODE></A></H3><PRE>void lua_pushvalue (lua_State *L, int index);</PRE>
<P>把堆栈上给定有效处索引处的元素作一个拷贝压栈。 
<HR>

<H3><A name=lua_pushvfstring><CODE>lua_pushvfstring</CODE></A></H3><PRE>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</PRE>
<P>等价于 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pushfstring"><CODE>lua_pushfstring</CODE></A>，不过是用 
<CODE>va_list</CODE> 接收参数，而不是用可变数量的实际参数。 
<HR>

<H3><A name=lua_rawequal><CODE>lua_rawequal</CODE></A></H3><PRE>int lua_rawequal (lua_State *L, int index1, int index2);</PRE>
<P>如果两个索引 <CODE>index1</CODE> 和 <CODE>index2</CODE> 处的值简单地相等（不调用元方法）则返回 1 。否则返回 
0 。如果任何一个索引无效也返回 0 。 
<HR>

<H3><A name=lua_rawget><CODE>lua_rawget</CODE></A></H3><PRE>void lua_rawget (lua_State *L, int index);</PRE>
<P>类似于 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_gettable"><CODE>lua_gettable</CODE></A>，但是作一次直接访问（不触发元方法）。 

<HR>

<H3><A name=lua_rawgeti><CODE>lua_rawgeti</CODE></A></H3><PRE>void lua_rawgeti (lua_State *L, int index, int n);</PRE>
<P>把 <CODE>t[n]</CODE> 的值压栈，这里的 <CODE>t</CODE> 是指给定索引 <CODE>index</CODE> 
处的一个值。这是一个直接访问；就是说，它不会触发元方法。 
<HR>

<H3><A name=lua_rawset><CODE>lua_rawset</CODE></A></H3><PRE>void lua_rawset (lua_State *L, int index);</PRE>
<P>类似于 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_settable"><CODE>lua_settable</CODE></A>，但是是作一个直接赋值（不触发元方法）。 

<HR>

<H3><A name=lua_rawseti><CODE>lua_rawseti</CODE></A></H3><PRE>void lua_rawseti (lua_State *L, int index, int n);</PRE>
<P>等价于 <CODE>t[n] = v</CODE>，这里的 <CODE>t</CODE> 是指给定索引 <CODE>index</CODE> 
处的一个值，而 <CODE>v</CODE> 是栈定的值。 
<P>函数将把这个值弹出栈。赋值操作是直接的；就是说，不会触发元方法。 
<HR>

<H3><A name=lua_Reader><CODE>lua_Reader</CODE></A></H3><PRE>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</PRE>
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
用到的读取器函数，每次它需要一块新的 chunk 的时候， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
就调用读取器，每次都会传入一个参数 <CODE>data</CODE> 。读取器需要返回含有新的 chunk 的一块内存的指针，并把 
<CODE>size</CODE> 设为这块内存的大小。内存块必须在下一次函数被调用之前一直存在。读取器可以通过返回一个 <CODE>NULL</CODE> 
来指示 chunk 结束。读取器可能返回多个块，每个块可以有任意的大于零的尺寸。 
<HR>

<H3><A name=lua_register><CODE>lua_register</CODE></A></H3><PRE>void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);</PRE>
<P>把 C 函数 <CODE>f</CODE> 设到全局变量 <CODE>name</CODE> 中。它通过一个宏定义： <PRE>     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</PRE>
<HR>

<H3><A name=lua_remove><CODE>lua_remove</CODE></A></H3><PRE>void lua_remove (lua_State *L, int index);</PRE>
<P>从给定有效索引处移除一个元素，把这个索引之上的所有元素移下来填补上这个空隙。不能用伪索引来调用这个函数，因为伪索引并不指向真实的栈上的位置。 
<HR>

<H3><A name=lua_replace><CODE>lua_replace</CODE></A></H3><PRE>void lua_replace (lua_State *L, int index);</PRE>
<P>把栈定元素移动到给定位置（并且把这个栈定元素弹出），不移动任何元素（因此在那个位置处的值被覆盖掉）。 
<HR>

<H3><A name=lua_resume><CODE>lua_resume</CODE></A></H3><PRE>int lua_resume (lua_State *L, int narg);</PRE>
<P>在给定线程中启动或继续一个 coroutine 。 
<P>要启动一个 coroutine 的话，首先你要创建一个新线程（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newthread"><CODE>lua_newthread</CODE></A> 
）；然后把主函数和若干参数压到新线程的堆栈上；最后调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_resume"><CODE>lua_resume</CODE></A> 
，把 <CODE>narg</CODE> 设为参数的个数。这次调用会在 coroutine 挂起时或是结束运行后返回。当函数返回时，堆栈中会有传给 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_yield"><CODE>lua_yield</CODE></A> 
的所有值，或是主函数的所有返回值。如果 coroutine 切换时，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_resume"><CODE>lua_resume</CODE></A> 
返回 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-LUA_YIELD"><CODE>LUA_YIELD</CODE></A> 
，而当 coroutine 结束运行且没有任何错误时，返回 0 。如果有错则返回错误代码（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pcall"><CODE>lua_pcall</CODE></A>）。在发生错误的情况下，堆栈没有展开，因此你可以使用 
debug API 来处理它。出错信息放在栈顶。要继续运行一个 coroutine 的话，你把需要传给 <CODE>yield</CODE> 
作结果的返回值压入堆栈，然后调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_resume"><CODE>lua_resume</CODE></A> 
。 
<HR>

<H3><A name=lua_setallocf><CODE>lua_setallocf</CODE></A></H3><PRE>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</PRE>
<P>把指定状态机的分配器函数换成带上指针 <CODE>ud</CODE> 的 <CODE>f</CODE> 。 
<HR>

<H3><A name=lua_setfenv><CODE>lua_setfenv</CODE></A></H3><PRE>int lua_setfenv (lua_State *L, int index);</PRE>
<P>从堆栈上弹出一个 table 并把它设为指定索引处值的新环境。如果指定索引处的值即不是函数又不是线程或是 userdata ， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_setfenv"><CODE>lua_setfenv</CODE></A> 
会返回 0 ，否则返回 1 。 
<HR>

<H3><A name=lua_setfield><CODE>lua_setfield</CODE></A></H3><PRE>void lua_setfield (lua_State *L, int index, const char *k);</PRE>
<P>做一个等价于 <CODE>t[k] = v</CODE> 的操作，这里 <CODE>t</CODE> 是给出的有效索引 
<CODE>index</CODE> 处的值，而 <CODE>v</CODE> 是栈顶的那个值。 
<P>这个函数将把这个值弹出堆栈。跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<HR>

<H3><A name=lua_setglobal><CODE>lua_setglobal</CODE></A></H3><PRE>void lua_setglobal (lua_State *L, const char *name);</PRE>
<P>从堆栈上弹出一个值，并将其设到全局变量 <CODE>name</CODE> 中。它由一个宏定义出来： <PRE>     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</PRE>
<HR>

<H3><A name=lua_setmetatable><CODE>lua_setmetatable</CODE></A></H3><PRE>int lua_setmetatable (lua_State *L, int index);</PRE>
<P>把一个 table 弹出堆栈，并将其设为给定索引处的值的 metatable 。 
<HR>

<H3><A name=lua_settable><CODE>lua_settable</CODE></A></H3><PRE>void lua_settable (lua_State *L, int index);</PRE>
<P>作一个等价于 <CODE>t[k] = v</CODE> 的操作，这里 <CODE>t</CODE> 是一个给定有效索引 
<CODE>index</CODE> 处的值， <CODE>v</CODE> 指栈顶的值，而 <CODE>k</CODE> 是栈顶之下的那个值。 
<P>这个函数会把键和值都从堆栈中弹出。和在 Lua 中一样，这个函数可能触发 "newindex" 事件的元方法（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.8">§2.8</A>）。 
<HR>

<H3><A name=lua_settop><CODE>lua_settop</CODE></A></H3><PRE>void lua_settop (lua_State *L, int index);</PRE>
<P>参数允许传入任何可接受的索引以及 0 。它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为 <B>nil</B> 。如果 
<CODE>index</CODE> 为 0 ，把栈上所有元素移除。 
<HR>

<H3><A name=lua_State><CODE>lua_State</CODE></A></H3><PRE>typedef struct lua_State lua_State;</PRE>
<P>一个不透明的结构，它保存了整个 Lua 解释器的状态。 Lua 库是完全可重入的：它没有任何全局变量。（译注：从 C 语法上来说，也不尽然。例如，在 
table 的实现中用了一个静态全局变量 dummynode_ ，但这在正确使用时并不影响可重入性。只是万一你错误链接了 lua 
库，不小心在同一进程空间中存在两份 lua 库实现的代码的话，多份 dummynode_ 不同的地址会导致一些问题。）所有的信息都保存在这个结构中。 
<P>这个状态机的指针必须作为第一个参数传递给每一个库函数。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A> 
是一个例外，这个函数会从头创建一个 Lua 状态机。 
<HR>

<H3><A name=lua_status><CODE>lua_status</CODE></A></H3><PRE>int lua_status (lua_State *L);</PRE>
<P>返回线程 <CODE>L</CODE> 的状态。 
<P>正常的线程状态是 0 。当线程执行完毕或发生一个错误时，状态值是错误码。如果线程被挂起，状态为 <A 
name=pdf-LUA_YIELD><CODE>LUA_YIELD</CODE></A> 。 
<HR>

<H3><A name=lua_toboolean><CODE>lua_toboolean</CODE></A></H3><PRE>int lua_toboolean (lua_State *L, int index);</PRE>
<P>把指定的索引处的的 Lua 值转换为一个 C 中的 boolean 值（ 0 或是 1 ）。和 Lua 中做的所有测试一样， <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_toboolean"><CODE>lua_toboolean</CODE></A> 
会把任何不同于 <B>false</B> 和 <B>nil</B> 的值当作 1 返回；否则就返回 0 。如果用一个无效索引去调用也会返回 0 
。（如果你想只接收真正的 boolean 值，就需要使用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_isboolean"><CODE>lua_isboolean</CODE></A> 
来测试值的类型。） 
<HR>

<H3><A name=lua_tocfunction><CODE>lua_tocfunction</CODE></A></H3><PRE>lua_CFunction lua_tocfunction (lua_State *L, int index);</PRE>
<P>把给定索引处的 Lua 值转换为一个 C 函数。这个值必须是一个 C 函数；如果不是就返回 <CODE>NULL</CODE> 。 
<HR>

<H3><A name=lua_tointeger><CODE>lua_tointeger</CODE></A></H3><PRE>lua_Integer lua_tointeger (lua_State *L, int idx);</PRE>
<P>把给定索引处的 Lua 值转换为 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Integer"><CODE>lua_Integer</CODE></A> 
这样一个有符号整数类型。这个 Lua 值必须是一个数字或是一个可以转换为数字的字符串（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.2.1">§2.2.1</A>）；否则，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tointeger"><CODE>lua_tointeger</CODE></A> 
返回 0 。 
<P>如果数字不是一个整数，截断小数部分的方式没有被明确定义。 
<HR>

<H3><A name=lua_tolstring><CODE>lua_tolstring</CODE></A></H3><PRE>const char *lua_tolstring (lua_State *L, int index, size_t *len);</PRE>
<P>把给定索引处的 Lua 值转换为一个 C 字符串。如果 <CODE>len</CODE> 不为 <CODE>NULL</CODE> ，它还把字符串长度设到 
<CODE>*len</CODE> 中。这个 Lua 值必须是一个字符串或是一个数字；否则返回返回 <CODE>NULL</CODE> 。如果值是一个数字，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
还会把堆栈中的那个值的实际类型转换为一个字符串。（当遍历一个表的时候，把 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
作用在键上，这个转换有可能导致 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_next"><CODE>lua_next</CODE></A> 
弄错。） 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
返回 Lua 状态机中字符串的以对齐指针。这个字符串总能保证 （ C 要求的）最后一个字符为零 ('<CODE>\0</CODE>') 
，而且它允许在字符串内包含多个这样的零。因为 Lua 中可能发生垃圾收集，所以不保证 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
返回的指针，在对应的值从堆栈中移除后依然有效。 
<HR>

<H3><A name=lua_tonumber><CODE>lua_tonumber</CODE></A></H3><PRE>lua_Number lua_tonumber (lua_State *L, int index);</PRE>
<P>把给定索引处的 Lua 值转换为 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Number"><CODE>lua_Number</CODE></A> 
这样一个 C 类型（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Number"><CODE>lua_Number</CODE></A> 
）。这个 Lua 值必须是一个数字或是一个可转换为数字的字符串（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.2.1">§2.2.1</A> 
）；否则，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tonumber"><CODE>lua_tonumber</CODE></A> 
返回 0 。 
<HR>

<H3><A name=lua_topointer><CODE>lua_topointer</CODE></A></H3><PRE>const void *lua_topointer (lua_State *L, int index);</PRE>
<P>把给定索引处的值转换为一般的 C 指针 (<CODE>void*</CODE>) 。这个值可以是一个 userdata ，table ，thread 
或是一个 function ；否则，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_topointer"><CODE>lua_topointer</CODE></A> 
返回 <CODE>NULL</CODE> 。不同的对象有不同的指针。不存在把指针再转回原有类型的方法。 
<P>这个函数通常只为产生 debug 信息用。 
<HR>

<H3><A name=lua_tostring><CODE>lua_tostring</CODE></A></H3><PRE>const char *lua_tostring (lua_State *L, int index);</PRE>
<P>等价于 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_tolstring"><CODE>lua_tolstring</CODE></A> 
，而参数 <CODE>len</CODE> 设为 <CODE>NULL</CODE> 。 
<HR>

<H3><A name=lua_tothread><CODE>lua_tothread</CODE></A></H3><PRE>lua_State *lua_tothread (lua_State *L, int index);</PRE>
<P>把给定索引处的值转换为一个 Lua 线程（由 <CODE>lua_State*</CODE> 代表）。这个值必须是一个线程；否则函数返回 
<CODE>NULL</CODE> 。 
<HR>

<H3><A name=lua_touserdata><CODE>lua_touserdata</CODE></A></H3><PRE>void *lua_touserdata (lua_State *L, int index);</PRE>
<P>如果给定索引处的值是一个完整的 userdata ，函数返回内存块的地址。如果值是一个 light userdata ，那么就返回它表示的指针。否则，返回 
<CODE>NULL</CODE> 。 
<HR>

<H3><A name=lua_type><CODE>lua_type</CODE></A></H3><PRE>int lua_type (lua_State *L, int index);</PRE>
<P>返回给定索引处的值的类型，当索引无效时则返回 <CODE>LUA_TNONE</CODE> （那是指一个指向堆栈上的空位置的索引）。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_type"><CODE>lua_type</CODE></A> 
返回的类型是一些个在 <CODE>lua.h</CODE> 中定义的常量： <CODE>LUA_TNIL</CODE> ， 
<CODE>LUA_TNUMBER</CODE> ， <CODE>LUA_TBOOLEAN</CODE> ， <CODE>LUA_TSTRING</CODE> 
， <CODE>LUA_TTABLE</CODE> ， <CODE>LUA_TFUNCTION</CODE> ， 
<CODE>LUA_TUSERDATA</CODE> ， <CODE>LUA_TTHREAD</CODE> ， 
<CODE>LUA_TLIGHTUSERDATA</CODE> 。 
<HR>

<H3><A name=lua_typename><CODE>lua_typename</CODE></A></H3><PRE>const char *lua_typename  (lua_State *L, int tp);</PRE>
<P>返回 <CODE>tp</CODE> 表示的类型名，这个 <CODE>tp</CODE> 必须是 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_type"><CODE>lua_type</CODE></A> 
可能返回的值中之一。 
<HR>

<H3><A name=lua_Writer><CODE>lua_Writer</CODE></A></H3><PRE>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</PRE>
<P>由 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_dump"><CODE>lua_dump</CODE></A> 
用到的写入器函数。每次 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_dump"><CODE>lua_dump</CODE></A> 
产生了一块新的 chunk ，它都会调用写入器。传入要写入的缓存 (<CODE>p</CODE>) 和它的尺寸 (<CODE>sz</CODE>) ，还有 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_dump"><CODE>lua_dump</CODE></A> 
的参数 <CODE>data</CODE> 。 
<P>写入器会返回一个错误码： 0 表示没有错误；别的值均表示一个错误，并且会让 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_dump"><CODE>lua_dump</CODE></A> 
停止再次调用写入器。 
<HR>

<H3><A name=lua_xmove><CODE>lua_xmove</CODE></A></H3><PRE>void lua_xmove (lua_State *from, lua_State *to, int n);</PRE>
<P>传递 <EM>同一个</EM> 全局状态机下不同线程中的值。 
<P>这个函数会从 <CODE>from</CODE> 的堆栈中弹出 <CODE>n</CODE> 个值，然后把它们压入 <CODE>to</CODE> 
的堆栈中。 
<HR>

<H3><A name=lua_yield><CODE>lua_yield</CODE></A></H3><PRE>int lua_yield  (lua_State *L, int nresults);</PRE>
<P>切出一个 coroutine 。 
<P>这个函数只能在一个 C 函数的返回表达式中调用。如下： <PRE>     return lua_yield (L, nresults);
</PRE>
<P>当一个 C 函数这样调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_yield"><CODE>lua_yield</CODE></A> 
，正在运行中的 coroutine 将从运行中挂起，然后启动这个 coroutine 用的那次对 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_resume"><CODE>lua_resume</CODE></A> 
的调用就返回了。参数 <CODE>nresults</CODE> 指的是堆栈中需要返回的结果个数，这些返回值将被传递给 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_resume"><CODE>lua_resume</CODE></A> 
。 
<H2>3.8 - <A name=3.8>调试接口</A></H2>
<P>Lua 
没有内建的调试设施。取而代之的是提供了一些函数接口和钩子。利用这些接口，可以做出一些不同类型的调试器，性能分析器，或是其它一些需要从解释器中取到“内部信息”的工具。 

<HR>

<H3><A name=lua_Debug><CODE>lua_Debug</CODE></A></H3><PRE>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) upvalue 个数 */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 私有部分 */
  <EM>其它域</EM>
} lua_Debug;</PRE>
<P>一个用来携带活动中函数的各种信息的结构。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getstack"><CODE>lua_getstack</CODE></A> 
仅填写这个结构中的私有部分，这些部分以后会用到。调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getinfo"><CODE>lua_getinfo</CODE></A> 
则可以填上 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Debug"><CODE>lua_Debug</CODE></A> 
中有用信息的那些域。 
<P><A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Debug"><CODE>lua_Debug</CODE></A> 
中的各个域有下列含义： 
<UL>
  <LI><B><CODE>source</CODE>:</B> 如果函数是定义在一个字符串中，<CODE>source</CODE> 
  就是这个字符串。如果函数定义在一个文件中， <CODE>source</CODE> 是一个以 '<CODE>@</CODE>' 开头的文件名。 
  <LI><B><CODE>short_src</CODE>:</B> 一个“可打印版本”的 <CODE>source</CODE>，用于出错信息。 
  <LI><B><CODE>linedefined</CODE>:</B> 函数定义开始处的行号。 
  <LI><B><CODE>lastlinedefined</CODE>:</B> 函数定义结束处的行号。 
  <LI><B><CODE>what</CODE>:</B> 如果函数是一个 Lua 函数，则为一个字符串 <CODE>"Lua"</CODE> ；如果是一个 
  C 函数，则为 <CODE>"C"</CODE>；如果它是一个 chunk 的主体部分，则为 
  <CODE>"main"</CODE>；如果是一个作了尾调用的函数，则为 <CODE>"tail"</CODE> 。别的情况下，Lua 
  没有关于函数的别的信息。 
  <LI><B><CODE>currentline</CODE>:</B> 
  给定函数正在执行的那一行。当提供不了行号信息的时候，<CODE>currentline</CODE> 被设为 -1 。 
  <LI><B><CODE>name</CODE>:</B> 给定函数的一个合理的名字。因为 Lua 
  中的函数也是一个值，所以它们没有固定的名字：一些函数可能是全局复合变量的值，另一些可能仅仅只是被保存在一个 table 中。 
  <CODE>lua_getinfo</CODE> 
  函数会检查函数是这样被调用的，以此来找到一个适合的名字。如果它找不到名字，<CODE>name</CODE> 就被设置为 <CODE>NULL</CODE> 
  。 
  <LI><B><CODE>namewhat</CODE>:</B> 结实 <CODE>name</CODE> 域。 
  <CODE>namewhat</CODE> 的值可以是 <CODE>"global"</CODE>, <CODE>"local"</CODE>, 
  <CODE>"method"</CODE>, <CODE>"field"</CODE>, <CODE>"upvalue"</CODE>, 或是 
  <CODE>""</CODE> （空串）。这取决于函数怎样被调用。（Lua 用空串表示其它选项都不符合） 
  <LI><B><CODE>nups</CODE>:</B> 函数的 upvalue 的个数。 </LI></UL>
<HR>

<H3><A name=lua_gethook><CODE>lua_gethook</CODE></A></H3><PRE>lua_Hook lua_gethook (lua_State *L);</PRE>
<P>返回当前的钩子函数。 
<HR>

<H3><A name=lua_gethookcount><CODE>lua_gethookcount</CODE></A></H3><PRE>int lua_gethookcount (lua_State *L);</PRE>
<P>返回当前钩子记数。 
<HR>

<H3><A name=lua_gethookmask><CODE>lua_gethookmask</CODE></A></H3><PRE>int lua_gethookmask (lua_State *L);</PRE>
<P>返回当前的钩子掩码 (mask) 。 
<HR>

<H3><A name=lua_getinfo><CODE>lua_getinfo</CODE></A></H3><PRE>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</PRE>
<P>返回一个指定的函数或函数调用的信息。 
<P>当用于取得一次函数调用的信息时，参数 <CODE>ar</CODE> 必须是一个有效的活动的记录。这条记录可以是前一次调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getstack"><CODE>lua_getstack</CODE></A> 
得到的，或是一个钩子 （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Hook"><CODE>lua_Hook</CODE></A>）得到的参数。 

<P>用于获取一个函数的信息时，可以把这个函数压入堆栈，然后把 <CODE>what</CODE> 字符串以字符 '<CODE>&gt;</CODE>' 
起头。（这个情况下，<CODE>lua_getinfo</CODE> 从栈顶上弹出函数。） 例如，想知道函数 <CODE>f</CODE> 
在哪一行定义的，你可以下下列代码： <PRE>     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* 取到全局变量 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</PRE>
<P><CODE>what</CODE> 字符串中的每个字符都筛选出结构 <CODE>ar</CODE> 结构中一些域用于填充，或是把一个值压入堆栈： 
<UL>
  <LI><B>'<CODE>n</CODE>':</B> 填充 <CODE>name</CODE> 及 <CODE>namewhat</CODE> 域； 
  <LI><B>'<CODE>S</CODE>':</B> 填充 <CODE>source</CODE>， <CODE>short_src</CODE>， 
  <CODE>linedefined</CODE>， <CODE>lastlinedefined</CODE>，以及 <CODE>what</CODE> 域； 

  <LI><B>'<CODE>l</CODE>':</B> 填充 <CODE>currentline</CODE> 域； 
  <LI><B>'<CODE>u</CODE>':</B> 填充 <CODE>nups</CODE> 域； 
  <LI><B>'<CODE>f</CODE>':</B> 把正在运行中指定级别处函数压入堆栈；（译注：一般用于获取函数调用中的信息，级别是由 ar 
  中的私有部分来提供。如果用于获取静态函数，那么就直接把指定函数重新压回堆栈，但这样做通常无甚意义。） 
  <LI><B>'<CODE>L</CODE>':</B> 压一个 table 入栈，这个 table 
  中的整数索引用于描述函数中哪些行是有效行。（有效行指有实际代码的行，即你可以置入断点的行。无效行包括空行和只有注释的行。） </LI></UL>
<P>这个函数出错会返回 0 （例如，<CODE>what</CODE> 中有一个无效选项）。 
<HR>

<H3><A name=lua_getlocal><CODE>lua_getlocal</CODE></A></H3><PRE>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</PRE>
<P>从给定活动记录中获取一个局部变量的信息。参数 <CODE>ar</CODE> 必须是一个有效的活动的记录。这条记录可以是前一次调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getstack"><CODE>lua_getstack</CODE></A> 
得到的，或是一个钩子 （参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Hook"><CODE>lua_Hook</CODE></A>）得到的参数。索引 
<CODE>n</CODE> 用于选择要检阅哪个局部变量（ 1 表示第一个参数或是激活的第一个局部变量，以此类推，直到最后一个局部变量）。 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getlocal"><CODE>lua_getlocal</CODE></A> 
把变量的值压入堆栈并返回它的名字。 
<P>以 '(' （正小括号）开始的变量指内部变量（循环控制变量，临时变量，C 函数局部变量）。 
<P>当索引大于局部变量的个数时，返回 <CODE>NULL</CODE> （什么也不压入）。 
<HR>

<H3><A name=lua_getstack><CODE>lua_getstack</CODE></A></H3><PRE>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</PRE>
<P>获取解释器的运行时栈的信息。 
<P>这个函数用正在运行中的给定级别处的函数的活动记录来填写 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Debug"><CODE>lua_Debug</CODE></A> 
结构的一部分。 0 级表示当前运行的函数，而 n+1 级处的函数就是调用第 n 级函数的那一个。如果没有错误，<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getstack"><CODE>lua_getstack</CODE></A> 
返回 1 ；当调用传入的级别大于堆栈深度的时候，返回 0 。 
<HR>

<H3><A name=lua_getupvalue><CODE>lua_getupvalue</CODE></A></H3><PRE>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</PRE>
<P>获取一个 closure 的 upvalue 信息。（对于 Lua 函数，upvalue 是函数需要使用的外部局部变量，因此这些变量被包含在 
closure 中。） <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getupvalue"><CODE>lua_getupvalue</CODE></A> 
获取第 <CODE>n</CODE> 个 upvalue ，把这个 upvalue 的值压入堆栈，并且返回它的名字。 
<CODE>funcindex</CODE> 指向堆栈上 closure 的位置。（ 因为 upvalue 
在整个函数中都有效，所以它们没有特别的次序。因此，它们以字母次序来编号。） 
<P>当索引号比 upvalue 数量大的时候，返回 <CODE>NULL</CODE> （而且不会压入任何东西）对于 C 函数，这个函数用空串 
<CODE>""</CODE> 表示所有 upvalue 的名字。 
<HR>

<H3><A name=lua_Hook><CODE>lua_Hook</CODE></A></H3><PRE>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</PRE>
<P>用于调试的钩子函数类型。 
<P>无论何时钩子被调用，它的参数 <CODE>ar</CODE> 中的 <CODE>event</CODE> 域都被设为触发钩子的事件。 Lua 
把这些事件定义为以下常量： <A name=pdf-LUA_HOOKCALL><CODE>LUA_HOOKCALL</CODE></A>， <A 
name=pdf-LUA_HOOKRET><CODE>LUA_HOOKRET</CODE></A>, <A 
name=pdf-LUA_HOOKTAILRET><CODE>LUA_HOOKTAILRET</CODE></A>， <A 
name=pdf-LUA_HOOKLINE><CODE>LUA_HOOKLINE</CODE></A>， and <A 
name=pdf-LUA_HOOKCOUNT><CODE>LUA_HOOKCOUNT</CODE></A>。除此之外，对于 line 
事件，<CODE>currentline</CODE> 域也被设置。要想获得 <CODE>ar</CODE> 中的其他域，钩子必须调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getinfo"><CODE>lua_getinfo</CODE></A>。对于返回事件，<CODE>event</CODE> 
的正常值可能是 <CODE>LUA_HOOKRET</CODE>，或者是 <CODE>LUA_HOOKTAILRET</CODE> 。对于后一种情况，Lua 
会对一个函数做的尾调用也模拟出一个返回事件出来；对于这个模拟的返回事件，调用 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getinfo"><CODE>lua_getinfo</CODE></A> 
没有什么作用。 
<P>当 Lua 运行在一个钩子内部时，它将屏蔽掉其它对钩子的调用。也就是说，如果一个钩子函数内再调回 Lua 来执行一个函数或是一个 chunk 
，这个执行操作不会触发任何的钩子。 
<HR>

<H3><A name=lua_sethook><CODE>lua_sethook</CODE></A></H3><PRE>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</PRE>
<P>设置一个调试用钩子函数。 
<P>参数 <CODE>f</CODE> 是钩子函数。 <CODE>mask</CODE> 指定在哪些事件时会调用：它由下列一组位常量构成 <A 
name=pdf-LUA_MASKCALL><CODE>LUA_MASKCALL</CODE></A>， <A 
name=pdf-LUA_MASKRET><CODE>LUA_MASKRET</CODE></A>， <A 
name=pdf-LUA_MASKLINE><CODE>LUA_MASKLINE</CODE></A>，以及 <A 
name=pdf-LUA_MASKCOUNT><CODE>LUA_MASKCOUNT</CODE></A>。参数 <CODE>count</CODE> 只在 
mask 中包含有 <CODE>LUA_MASKCOUNT</CODE> 才有意义。对于每个事件，钩子被调用的情况解释如下： 
<UL>
  <LI><B>call hook:</B> 在解释器调用一个函数时被调用。钩子将于 Lua 进入一个新函数后，函数获取参数前被调用。 
  <LI><B>return hook:</B> 在解释器从一个函数中返回时调用。钩子将于 Lua 
  离开函数之前的那一刻被调用。你无权访问被函数返回出去的那些值。 <SMALL>（译注：原文 (You have no access to the 
  values to be returned by the function) 如此。但“无权访问”一词值得商榷。某些情况下你可以访问到一些被命名为 
  (*temporary) 的局部变量，那些索引被排在最后的 (*temporary) 变量指的就是返回值。但是由于 Lua 
  对特殊情况做了一些优化，比如直接返回一个被命名的局部变量，那么就找不到对应的 (*temporary) 
  变量了。本质上，返回值一定存在于此刻的局部变量中，并且可以访问它，只是无法确定是哪些罢了。至于这个时候函数体内的其它局部变量，是不保证有效的。进入 
  return hook 的那一刻起，实际已经退出函数内部的运行环节，返回值占用的局部变量空间以后的部分，都有可能因 hook 本身复用它们而改变。） 
  </SMALL>
  <LI><B>line hook:</B> 在解释器准备开始执行新的一行代码时，或是跳转到这行代码中时（即使在同一行内跳转）被调用。（这个事件仅仅在 Lua 
  执行一个 Lua 函数时发生。） 
  <LI><B>count hook:</B> 在解释器每执行 <CODE>count</CODE> 条指令后被调用。（这个事件仅仅在 Lua 执行一个 
  Lua 函数时发生。） </LI></UL>
<P>钩子可以通过设置 <CODE>mask</CODE> 为零屏蔽。 
<HR>

<H3><A name=lua_setlocal><CODE>lua_setlocal</CODE></A></H3><PRE>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</PRE>
<P>设置给定活动记录中的局部变量的值。参数 <CODE>ar</CODE> 与 <CODE>n</CODE> 和 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getlocal"><CODE>lua_getlocal</CODE></A> 
中的一样（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getlocal"><CODE>lua_getlocal</CODE></A>）。 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_setlocal"><CODE>lua_setlocal</CODE></A> 
把栈顶的值赋给变量然后返回变量的名字。它会将值从栈顶弹出。 
<P>当索引大于局部变量的个数时，返回 <CODE>NULL</CODE> （什么也不弹出）。 
<HR>

<H3><A name=lua_setupvalue><CODE>lua_setupvalue</CODE></A></H3><PRE>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</PRE>
<P>设置 closure 的 upvalue 的值。它把栈顶的值弹出并赋于 upvalue 并返回 upvalue 的名字。参数 
<CODE>funcindex</CODE> 与 <CODE>n</CODE> 和 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getupvalue"><CODE>lua_getupvalue</CODE></A> 
中的一样（参见 <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getupvalue"><CODE>lua_getupvalue</CODE></A>）。 

<P>当索引大于 upvalue 的个数时，返回 <CODE>NULL</CODE> （什么也不弹出）。 
<H1>4 - <A name=4>The Auxiliary Library</A></H1>
<P>The <EM>auxiliary library</EM> provides several convenient functions to 
interface C with Lua. While the basic API provides the primitive functions for 
all interactions between C and Lua, the auxiliary library provides higher-level 
functions for some common tasks. 
<P>All functions from the auxiliary library are defined in header file 
<CODE>lauxlib.h</CODE> and have a prefix <CODE>luaL_</CODE>. 
<P>All functions in the auxiliary library are built on top of the basic API, and 
so they provide nothing that cannot be done with this API. 
<P>Several functions in the auxiliary library are used to check C&nbsp;function 
arguments. Their names are always <CODE>luaL_check*</CODE> or 
<CODE>luaL_opt*</CODE>. All of these functions raise an error if the check is 
not satisfied. Because the error message is formatted for arguments (e.g., 
"<CODE>bad argument #1</CODE>"), you should not use these functions for other 
stack values. 
<H2>4.1 - <A name=4.1>Functions and Types</A></H2>
<P>Here we list all functions and types from the auxiliary library in 
alphabetical order. 
<HR>

<H3><A name=luaL_addchar><CODE>luaL_addchar</CODE></A></H3><PRE>void luaL_addchar (luaL_Buffer *B, char c);</PRE>
<P>Adds the character <CODE>c</CODE> to the buffer <CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 

<HR>

<H3><A name=luaL_addlstring><CODE>luaL_addlstring</CODE></A></H3><PRE>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</PRE>
<P>Adds the string pointed to by <CODE>s</CODE> with length <CODE>l</CODE> to 
the buffer <CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 
The string may contain embedded zeros. 
<HR>

<H3><A name=luaL_addsize><CODE>luaL_addsize</CODE></A></H3><PRE>void luaL_addsize (luaL_Buffer *B, size_t n);</PRE>
<P>Adds to the buffer <CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>) 
a string of length <CODE>n</CODE> previously copied to the buffer area (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_prepbuffer"><CODE>luaL_prepbuffer</CODE></A>). 

<HR>

<H3><A name=luaL_addstring><CODE>luaL_addstring</CODE></A></H3><PRE>void luaL_addstring (luaL_Buffer *B, const char *s);</PRE>
<P>Adds the zero-terminated string pointed to by <CODE>s</CODE> to the buffer 
<CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 
The string may not contain embedded zeros. 
<HR>

<H3><A name=luaL_addvalue><CODE>luaL_addvalue</CODE></A></H3><PRE>void luaL_addvalue (luaL_Buffer *B);</PRE>
<P>Adds the value at the top of the stack to the buffer <CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 
Pops the value. 
<P>This is the only function on string buffers that can (and must) be called 
with an extra element on the stack, which is the value to be added to the 
buffer. 
<HR>

<H3><A name=luaL_argcheck><CODE>luaL_argcheck</CODE></A></H3><PRE>void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</PRE>
<P>Checks whether <CODE>cond</CODE> is true. If not, raises an error with the 
following message, where <CODE>func</CODE> is retrieved from the call stack: <PRE>     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</PRE>
<HR>

<H3><A name=luaL_argerror><CODE>luaL_argerror</CODE></A></H3><PRE>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</PRE>
<P>Raises an error with the following message, where <CODE>func</CODE> is 
retrieved from the call stack: <PRE>     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</PRE>
<P>This function never returns, but it is an idiom to use it in C&nbsp;functions 
as <CODE>return luaL_argerror(<EM>args</EM>)</CODE>. 
<HR>

<H3><A name=luaL_Buffer><CODE>luaL_Buffer</CODE></A></H3><PRE>typedef struct luaL_Buffer luaL_Buffer;</PRE>
<P>Type for a <EM>string buffer</EM>. 
<P>A string buffer allows C&nbsp;code to build Lua strings piecemeal. Its 
pattern of use is as follows: 
<UL>
  <LI>First you declare a variable <CODE>b</CODE> of type <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>. 

  <LI>Then you initialize it with a call <CODE>luaL_buffinit(L, &amp;b)</CODE>. 
  <LI>Then you add string pieces to the buffer calling any of the 
  <CODE>luaL_add*</CODE> functions. 
  <LI>You finish by calling <CODE>luaL_pushresult(&amp;b)</CODE>. This call 
  leaves the final string on the top of the stack. </LI></UL>
<P>During its normal operation, a string buffer uses a variable number of stack 
slots. So, while using a buffer, you cannot assume that you know where the top 
of the stack is. You can use the stack between successive calls to buffer 
operations as long as that use is balanced; that is, when you call a buffer 
operation, the stack is at the same level it was immediately after the previous 
buffer operation. (The only exception to this rule is <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_addvalue"><CODE>luaL_addvalue</CODE></A>.) 
After calling <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_pushresult"><CODE>luaL_pushresult</CODE></A> 
the stack is back to its level when the buffer was initialized, plus the final 
string on its top. 
<HR>

<H3><A name=luaL_buffinit><CODE>luaL_buffinit</CODE></A></H3><PRE>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</PRE>
<P>Initializes a buffer <CODE>B</CODE>. This function does not allocate any 
space; the buffer must be declared as a variable (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 

<HR>

<H3><A name=luaL_callmeta><CODE>luaL_callmeta</CODE></A></H3><PRE>int luaL_callmeta (lua_State *L, int obj, const char *e);</PRE>
<P>Calls a metamethod. 
<P>If the object at index <CODE>obj</CODE> has a metatable and this metatable 
has a field <CODE>e</CODE>, this function calls this field and passes the object 
as its only argument. In this case this function returns 1 and pushes onto the 
stack the value returned by the call. If there is no metatable or no metamethod, 
this function returns 0 (without pushing any value on the stack). 
<HR>

<H3><A name=luaL_checkany><CODE>luaL_checkany</CODE></A></H3><PRE>void luaL_checkany (lua_State *L, int narg);</PRE>
<P>Checks whether the function has an argument of any type (including 
<B>nil</B>) at position <CODE>narg</CODE>. 
<HR>

<H3><A name=luaL_checkint><CODE>luaL_checkint</CODE></A></H3><PRE>int luaL_checkint (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number and 
returns this number cast to an <CODE>int</CODE>. 
<HR>

<H3><A name=luaL_checkinteger><CODE>luaL_checkinteger</CODE></A></H3><PRE>lua_Integer luaL_checkinteger (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number and 
returns this number cast to a <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Integer"><CODE>lua_Integer</CODE></A>. 

<HR>

<H3><A name=luaL_checklong><CODE>luaL_checklong</CODE></A></H3><PRE>long luaL_checklong (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number and 
returns this number cast to a <CODE>long</CODE>. 
<HR>

<H3><A name=luaL_checklstring><CODE>luaL_checklstring</CODE></A></H3><PRE>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string and 
returns this string; if <CODE>l</CODE> is not <CODE>NULL</CODE> fills 
<CODE>*l</CODE> with the string's length. 
<HR>

<H3><A name=luaL_checknumber><CODE>luaL_checknumber</CODE></A></H3><PRE>lua_Number luaL_checknumber (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number and 
returns this number. 
<HR>

<H3><A name=luaL_checkoption><CODE>luaL_checkoption</CODE></A></H3><PRE>int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string and 
searches for this string in the array <CODE>lst</CODE> (which must be 
NULL-terminated). Returns the index in the array where the string was found. 
Raises an error if the argument is not a string or if the string cannot be 
found. 
<P>If <CODE>def</CODE> is not <CODE>NULL</CODE>, the function uses 
<CODE>def</CODE> as a default value when there is no argument <CODE>narg</CODE> 
or if this argument is <B>nil</B>. 
<P>This is a useful function for mapping strings to C&nbsp;enums. (The usual 
convention in Lua libraries is to use strings instead of numbers to select 
options.) 
<HR>

<H3><A name=luaL_checkstack><CODE>luaL_checkstack</CODE></A></H3><PRE>void luaL_checkstack (lua_State *L, int sz, const char *msg);</PRE>
<P>Grows the stack size to <CODE>top + sz</CODE> elements, raising an error if 
the stack cannot grow to that size. <CODE>msg</CODE> is an additional text to go 
into the error message. 
<HR>

<H3><A name=luaL_checkstring><CODE>luaL_checkstring</CODE></A></H3><PRE>const char *luaL_checkstring (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string and 
returns this string. 
<HR>

<H3><A name=luaL_checktype><CODE>luaL_checktype</CODE></A></H3><PRE>void luaL_checktype (lua_State *L, int narg, int t);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> has type 
<CODE>t</CODE>. 
<HR>

<H3><A name=luaL_checkudata><CODE>luaL_checkudata</CODE></A></H3><PRE>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a userdata of the 
type <CODE>tname</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_newmetatable"><CODE>luaL_newmetatable</CODE></A>). 

<HR>

<H3><A name=luaL_dofile><CODE>luaL_dofile</CODE></A></H3><PRE>int luaL_dofile (lua_State *L, const char *filename);</PRE>
<P>Loads and runs the given file. It is defined as the following macro: <PRE>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</PRE>
<P>It returns 0 if there are no errors or 1 in case of errors. 
<HR>

<H3><A name=luaL_dostring><CODE>luaL_dostring</CODE></A></H3><PRE>int luaL_dostring (lua_State *L, const char *str);</PRE>
<P>Loads and runs the given string. It is defined as the following macro: <PRE>     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</PRE>
<P>It returns 0 if there are no errors or 1 in case of errors. 
<HR>

<H3><A name=luaL_error><CODE>luaL_error</CODE></A></H3><PRE>int luaL_error (lua_State *L, const char *fmt, ...);</PRE>
<P>Raises an error. The error message format is given by <CODE>fmt</CODE> plus 
any extra arguments, following the same rules of <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_pushfstring"><CODE>lua_pushfstring</CODE></A>. 
It also adds at the beginning of the message the file name and the line number 
where the error occurred, if this information is available. 
<P>This function never returns, but it is an idiom to use it in C&nbsp;functions 
as <CODE>return luaL_error(<EM>args</EM>)</CODE>. 
<HR>

<H3><A name=luaL_getmetafield><CODE>luaL_getmetafield</CODE></A></H3><PRE>int luaL_getmetafield (lua_State *L, int obj, const char *e);</PRE>
<P>Pushes onto the stack the field <CODE>e</CODE> from the metatable of the 
object at index <CODE>obj</CODE>. If the object does not have a metatable, or if 
the metatable does not have this field, returns 0 and pushes nothing. 
<HR>

<H3><A name=luaL_getmetatable><CODE>luaL_getmetatable</CODE></A></H3><PRE>void luaL_getmetatable (lua_State *L, const char *tname);</PRE>
<P>Pushes onto the stack the metatable associated with name <CODE>tname</CODE> 
in the registry (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_newmetatable"><CODE>luaL_newmetatable</CODE></A>). 

<HR>

<H3><A name=luaL_gsub><CODE>luaL_gsub</CODE></A></H3><PRE>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</PRE>
<P>Creates a copy of string <CODE>s</CODE> by replacing any occurrence of the 
string <CODE>p</CODE> with the string <CODE>r</CODE>. Pushes the resulting 
string on the stack and returns it. 
<HR>

<H3><A name=luaL_loadbuffer><CODE>luaL_loadbuffer</CODE></A></H3><PRE>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</PRE>
<P>Loads a buffer as a Lua chunk. This function uses <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
to load the chunk in the buffer pointed to by <CODE>buff</CODE> with size 
<CODE>sz</CODE>. 
<P>This function returns the same results as <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>. 
<CODE>name</CODE> is the chunk name, used for debug information and error 
messages. 
<HR>

<H3><A name=luaL_loadfile><CODE>luaL_loadfile</CODE></A></H3><PRE>int luaL_loadfile (lua_State *L, const char *filename);</PRE>
<P>Loads a file as a Lua chunk. This function uses <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
to load the chunk in the file named <CODE>filename</CODE>. If 
<CODE>filename</CODE> is <CODE>NULL</CODE>, then it loads from the standard 
input. The first line in the file is ignored if it starts with a <CODE>#</CODE>. 

<P>This function returns the same results as <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>, 
but it has an extra error code <A 
name=pdf-LUA_ERRFILE><CODE>LUA_ERRFILE</CODE></A> if it cannot open/read the 
file. 
<P>As <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>, 
this function only loads the chunk; it does not run it. 
<HR>

<H3><A name=luaL_loadstring><CODE>luaL_loadstring</CODE></A></H3><PRE>int luaL_loadstring (lua_State *L, const char *s);</PRE>
<P>Loads a string as a Lua chunk. This function uses <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A> 
to load the chunk in the zero-terminated string <CODE>s</CODE>. 
<P>This function returns the same results as <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>. 

<P>Also as <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_load"><CODE>lua_load</CODE></A>, 
this function only loads the chunk; it does not run it. 
<HR>

<H3><A name=luaL_newmetatable><CODE>luaL_newmetatable</CODE></A></H3><PRE>int luaL_newmetatable (lua_State *L, const char *tname);</PRE>
<P>If the registry already has the key <CODE>tname</CODE>, returns 0. Otherwise, 
creates a new table to be used as a metatable for userdata, adds it to the 
registry with key <CODE>tname</CODE>, and returns 1. 
<P>In both cases pushes onto the stack the final value associated with 
<CODE>tname</CODE> in the registry. 
<HR>

<H3><A name=luaL_newstate><CODE>luaL_newstate</CODE></A></H3><PRE>lua_State *luaL_newstate (void);</PRE>
<P>Creates a new Lua state. It calls <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A> 
with an allocator based on the standard&nbsp;C <CODE>realloc</CODE> function and 
then sets a panic function (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_atpanic"><CODE>lua_atpanic</CODE></A>) 
that prints an error message to the standard error output in case of fatal 
errors. 
<P>Returns the new state, or <CODE>NULL</CODE> if there is a memory allocation 
error. 
<HR>

<H3><A name=luaL_openlibs><CODE>luaL_openlibs</CODE></A></H3><PRE>void luaL_openlibs (lua_State *L);</PRE>
<P>Opens all standard Lua libraries into the given state. 
<HR>

<H3><A name=luaL_optint><CODE>luaL_optint</CODE></A></H3><PRE>int luaL_optint (lua_State *L, int narg, int d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this number 
cast to an <CODE>int</CODE>. If this argument is absent or is <B>nil</B>, 
returns <CODE>d</CODE>. Otherwise, raises an error. 
<HR>

<H3><A name=luaL_optinteger><CODE>luaL_optinteger</CODE></A></H3><PRE>lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this number 
cast to a <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_Integer"><CODE>lua_Integer</CODE></A>. 
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. Otherwise, 
raises an error. 
<HR>

<H3><A name=luaL_optlong><CODE>luaL_optlong</CODE></A></H3><PRE>long luaL_optlong (lua_State *L, int narg, long d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this number 
cast to a <CODE>long</CODE>. If this argument is absent or is <B>nil</B>, 
returns <CODE>d</CODE>. Otherwise, raises an error. 
<HR>

<H3><A name=luaL_optlstring><CODE>luaL_optlstring</CODE></A></H3><PRE>const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</PRE>
<P>If the function argument <CODE>narg</CODE> is a string, returns this string. 
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. Otherwise, 
raises an error. 
<P>If <CODE>l</CODE> is not <CODE>NULL</CODE>, fills the position 
<CODE>*l</CODE> with the results's length. 
<HR>

<H3><A name=luaL_optnumber><CODE>luaL_optnumber</CODE></A></H3><PRE>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this number. 
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. Otherwise, 
raises an error. 
<HR>

<H3><A name=luaL_optstring><CODE>luaL_optstring</CODE></A></H3><PRE>const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a string, returns this string. 
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. Otherwise, 
raises an error. 
<HR>

<H3><A name=luaL_prepbuffer><CODE>luaL_prepbuffer</CODE></A></H3><PRE>char *luaL_prepbuffer (luaL_Buffer *B);</PRE>
<P>Returns an address to a space of size <A 
name=pdf-LUAL_BUFFERSIZE><CODE>LUAL_BUFFERSIZE</CODE></A> where you can copy a 
string to be added to buffer <CODE>B</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Buffer"><CODE>luaL_Buffer</CODE></A>). 
After copying the string into this space you must call <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_addsize"><CODE>luaL_addsize</CODE></A> 
with the size of the string to actually add it to the buffer. 
<HR>

<H3><A name=luaL_pushresult><CODE>luaL_pushresult</CODE></A></H3><PRE>void luaL_pushresult (luaL_Buffer *B);</PRE>
<P>Finishes the use of buffer <CODE>B</CODE> leaving the final string on the top 
of the stack. 
<HR>

<H3><A name=luaL_ref><CODE>luaL_ref</CODE></A></H3><PRE>int luaL_ref (lua_State *L, int t);</PRE>
<P>Creates and returns a <EM>reference</EM>, in the table at index 
<CODE>t</CODE>, for the object at the top of the stack (and pops the object). 
<P>A reference is a unique integer key. As long as you do not manually add 
integer keys into table <CODE>t</CODE>, <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_ref"><CODE>luaL_ref</CODE></A> 
ensures the uniqueness of the key it returns. You can retrieve an object 
referred by reference <CODE>r</CODE> by calling <CODE>lua_rawgeti(L, t, 
r)</CODE>. Function <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_unref"><CODE>luaL_unref</CODE></A> 
frees a reference and its associated object. 
<P>If the object at the top of the stack is <B>nil</B>, <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_ref"><CODE>luaL_ref</CODE></A> 
returns the constant <A name=pdf-LUA_REFNIL><CODE>LUA_REFNIL</CODE></A>. The 
constant <A name=pdf-LUA_NOREF><CODE>LUA_NOREF</CODE></A> is guaranteed to be 
different from any reference returned by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_ref"><CODE>luaL_ref</CODE></A>. 

<HR>

<H3><A name=luaL_Reg><CODE>luaL_Reg</CODE></A></H3><PRE>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</PRE>
<P>Type for arrays of functions to be registered by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_register"><CODE>luaL_register</CODE></A>. 
<CODE>name</CODE> is the function name and <CODE>func</CODE> is a pointer to the 
function. Any array of <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Reg"><CODE>luaL_Reg</CODE></A> 
must end with an sentinel entry in which both <CODE>name</CODE> and 
<CODE>func</CODE> are <CODE>NULL</CODE>. 
<HR>

<H3><A name=luaL_register><CODE>luaL_register</CODE></A></H3><PRE>void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</PRE>
<P>Opens a library. 
<P>When called with <CODE>libname</CODE> equal to <CODE>NULL</CODE>, it simply 
registers all functions in the list <CODE>l</CODE> (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_Reg"><CODE>luaL_Reg</CODE></A>) 
into the table on the top of the stack. 
<P>When called with a non-null <CODE>libname</CODE>, <CODE>luaL_register</CODE> 
creates a new table <CODE>t</CODE>, sets it as the value of the global variable 
<CODE>libname</CODE>, sets it as the value of 
<CODE>package.loaded[libname]</CODE>, and registers on it all functions in the 
list <CODE>l</CODE>. If there is a table in <CODE>package.loaded[libname]</CODE> 
or in variable <CODE>libname</CODE>, reuses this table instead of creating a new 
one. 
<P>In any case the function leaves the table on the top of the stack. 
<HR>

<H3><A name=luaL_typename><CODE>luaL_typename</CODE></A></H3><PRE>const char *luaL_typename (lua_State *L, int idx);</PRE>
<P>Returns the name of the type of the value at index <CODE>idx</CODE>. 
<HR>

<H3><A name=luaL_typerror><CODE>luaL_typerror</CODE></A></H3><PRE>int luaL_typerror (lua_State *L, int narg, const char *tname);</PRE>
<P>Generates an error with a message like the following: <PRE>     <EM>location</EM>: bad argument <EM>narg</EM> to '<EM>func</EM>' (<EM>tname</EM> expected, got <EM>rt</EM>)
</PRE>
<P>where <CODE><EM>location</EM></CODE> is produced by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_where"><CODE>luaL_where</CODE></A>, 
<CODE><EM>func</EM></CODE> is the name of the current function, and 
<CODE><EM>rt</EM></CODE> is the type name of the actual argument. 
<HR>

<H3><A name=luaL_unref><CODE>luaL_unref</CODE></A></H3><PRE>void luaL_unref (lua_State *L, int t, int ref);</PRE>
<P>Releases reference <CODE>ref</CODE> from the table at index <CODE>t</CODE> 
(see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_ref"><CODE>luaL_ref</CODE></A>). 
The entry is removed from the table, so that the referred object can be 
collected. The reference <CODE>ref</CODE> is also freed to be used again. 
<P>If <CODE>ref</CODE> is <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-LUA_NOREF"><CODE>LUA_NOREF</CODE></A> 
or <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-LUA_REFNIL"><CODE>LUA_REFNIL</CODE></A>, 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_unref"><CODE>luaL_unref</CODE></A> 
does nothing. 
<HR>

<H3><A name=luaL_where><CODE>luaL_where</CODE></A></H3><PRE>void luaL_where (lua_State *L, int lvl);</PRE>
<P>Pushes onto the stack a string identifying the current position of the 
control at level <CODE>lvl</CODE> in the call stack. Typically this string has 
the following format: <PRE>     <EM>chunkname</EM>:<EM>currentline</EM>:
</PRE>
<P>Level&nbsp;0 is the running function, level&nbsp;1 is the function that 
called the running function, etc. 
<P>This function is used to build a prefix for error messages. 
<H1>5 - <A name=5>Standard Libraries</A></H1>
<P>The standard Lua libraries provide useful functions that are implemented 
directly through the C&nbsp;API. Some of these functions provide essential 
services to the language (e.g., <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-type"><CODE>type</CODE></A> 
and <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-getmetatable"><CODE>getmetatable</CODE></A>); 
others provide access to "outside" services (e.g., I/O); and others could be 
implemented in Lua itself, but are quite useful or have critical performance 
requirements that deserve an implementation in C (e.g., <CODE>sort</CODE>). 
<P>All libraries are implemented through the official C&nbsp;API and are 
provided as separate C&nbsp;modules. Currently, Lua has the following standard 
libraries: 
<UL>
  <LI>basic library; 
  <LI>package library; 
  <LI>string manipulation; 
  <LI>table manipulation; 
  <LI>mathematical functions (sin, log, etc.); 
  <LI>input and output; 
  <LI>operating system facilities; 
  <LI>debug facilities. </LI></UL>
<P>Except for the basic and package libraries, each library provides all its 
functions as fields of a global table or as methods of its objects. 
<P>To have access to these libraries, the C&nbsp;host program should call the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_openlibs"><CODE>luaL_openlibs</CODE></A> 
function, which opens all standard libraries. Alternatively, it can open them 
individually by calling <A name=pdf-luaopen_base><CODE>luaopen_base</CODE></A> 
(for the basic library), <A 
name=pdf-luaopen_package><CODE>luaopen_package</CODE></A> (for the package 
library), <A name=pdf-luaopen_string><CODE>luaopen_string</CODE></A> (for the 
string library), <A name=pdf-luaopen_table><CODE>luaopen_table</CODE></A> (for 
the table library), <A name=pdf-luaopen_math><CODE>luaopen_math</CODE></A> (for 
the mathematical library), <A name=pdf-luaopen_io><CODE>luaopen_io</CODE></A> 
(for the I/O and the Operating System libraries), and <A 
name=pdf-luaopen_debug><CODE>luaopen_debug</CODE></A> (for the debug library). 
These functions are declared in <A name=pdf-lualib.h><CODE>lualib.h</CODE></A> 
and should not be called directly: you must call them like any other Lua 
C&nbsp;function, e.g., by using <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_call"><CODE>lua_call</CODE></A>. 

<H2>5.1 - <A name=5.1>Basic Functions</A></H2>
<P>The basic library provides some core functions to Lua. If you do not include 
this library in your application, you should check carefully whether you need to 
provide implementations for some of its facilities. 
<P>
<HR>

<H3><A name=pdf-assert><CODE>assert (v [, message])</CODE></A></H3>Issues an 
error when the value of its argument <CODE>v</CODE> is false (i.e., <B>nil</B> 
or <B>false</B>); otherwise, returns all its arguments. <CODE>message</CODE> is 
an error message; when absent, it defaults to "assertion failed!" 
<P>
<HR>

<H3><A name=pdf-collectgarbage><CODE>collectgarbage (opt [, 
arg])</CODE></A></H3>
<P>This function is a generic interface to the garbage collector. It performs 
different functions according to its first argument, <CODE>opt</CODE>: 
<UL>
  <LI><B>"stop":</B> stops the garbage collector. 
  <LI><B>"restart":</B> restarts the garbage collector. 
  <LI><B>"collect":</B> performs a full garbage-collection cycle. 
  <LI><B>"count":</B> returns the total memory in use by Lua (in Kbytes). 
  <LI><B>"step":</B> performs a garbage-collection step. The step "size" is 
  controlled by <CODE>arg</CODE> (larger values mean more steps) in a 
  non-specified way. If you want to control the step size you must 
  experimentally tune the value of <CODE>arg</CODE>. Returns <B>true</B> if the 
  step finished a collection cycle. 
  <LI><B>"setpause":</B> sets <CODE>arg</CODE>/100 as the new value for the 
  <EM>pause</EM> of the collector (see <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#2.10">§2.10</A>). 

  <LI><B>"setstepmul":</B> sets <CODE>arg</CODE>/100 as the new value for the 
  <EM>step multiplier</EM> of the collector (see <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#2.10">§2.10</A>). 
  </LI></UL>
<P>
<HR>

<H3><A name=pdf-dofile><CODE>dofile (filename)</CODE></A></H3>Opens the named 
file and executes its contents as a Lua chunk. When called without arguments, 
<CODE>dofile</CODE> executes the contents of the standard input 
(<CODE>stdin</CODE>). Returns all values returned by the chunk. In case of 
errors, <CODE>dofile</CODE> propagates the error to its caller (that is, 
<CODE>dofile</CODE> does not run in protected mode). 
<P>
<HR>

<H3><A name=pdf-error><CODE>error (message [, level])</CODE></A></H3>Terminates 
the last protected function called and returns <CODE>message</CODE> as the error 
message. Function <CODE>error</CODE> never returns. 
<P>Usually, <CODE>error</CODE> adds some information about the error position at 
the beginning of the message. The <CODE>level</CODE> argument specifies how to 
get the error position. With level&nbsp;1 (the default), the error position is 
where the <CODE>error</CODE> function was called. Level&nbsp;2 points the error 
to where the function that called <CODE>error</CODE> was called; and so on. 
Passing a level&nbsp;0 avoids the addition of error position information to the 
message. 
<P>
<HR>

<H3><A name=pdf-_G><CODE>_G</CODE></A></H3>A global variable (not a function) 
that holds the global environment (that is, <CODE>_G._G = _G</CODE>). Lua itself 
does not use this variable; changing its value does not affect any environment, 
nor vice-versa. (Use <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-setfenv"><CODE>setfenv</CODE></A> 
to change environments.) 
<P>
<HR>

<H3><A name=pdf-getfenv><CODE>getfenv (f)</CODE></A></H3>Returns the current 
environment in use by the function. <CODE>f</CODE> can be a Lua function or a 
number that specifies the function at that stack level: Level&nbsp;1 is the 
function calling <CODE>getfenv</CODE>. If the given function is not a Lua 
function, or if <CODE>f</CODE> is 0, <CODE>getfenv</CODE> returns the global 
environment. The default for <CODE>f</CODE> is 1. 
<P>
<HR>

<H3><A name=pdf-getmetatable><CODE>getmetatable (object)</CODE></A></H3>
<P>If <CODE>object</CODE> does not have a metatable, returns <B>nil</B>. 
Otherwise, if the object's metatable has a <CODE>"__metatable"</CODE> field, 
returns the associated value. Otherwise, returns the metatable of the given 
object. 
<P>
<HR>

<H3><A name=pdf-ipairs><CODE>ipairs (t)</CODE></A></H3>
<P>Returns three values: an iterator function, the table <CODE>t</CODE>, and 0, 
so that the construction <PRE>     for i,v in ipairs(t) do <EM>body</EM> end
</PRE>
<P>will iterate over the pairs (<CODE>1,t[1]</CODE>), (<CODE>2,t[2]</CODE>), 
・・・, up to the first integer key absent from the table. 
<P>
<HR>

<H3><A name=pdf-load><CODE>load (func [, chunkname])</CODE></A></H3>
<P>Loads a chunk using function <CODE>func</CODE> to get its pieces. Each call 
to <CODE>func</CODE> must return a string that concatenates with previous 
results. A return of <B>nil</B> (or no value) signals the end of the chunk. 
<P>If there are no errors, returns the compiled chunk as a function; otherwise, 
returns <B>nil</B> plus the error message. The environment of the returned 
function is the global environment. 
<P><CODE>chunkname</CODE> is used as the chunk name for error messages and debug 
information. 
<P>
<HR>

<H3><A name=pdf-loadfile><CODE>loadfile ([filename])</CODE></A></H3>
<P>Similar to <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-load"><CODE>load</CODE></A>, 
but gets the chunk from file <CODE>filename</CODE> or from the standard input, 
if no file name is given. 
<P>
<HR>

<H3><A name=pdf-loadstring><CODE>loadstring (string [, 
chunkname])</CODE></A></H3>
<P>Similar to <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-load"><CODE>load</CODE></A>, 
but gets the chunk from the given string. 
<P>To load and run a given string, use the idiom <PRE>     assert(loadstring(s))()
</PRE>
<P>
<HR>

<H3><A name=pdf-next><CODE>next (table [, index])</CODE></A></H3>
<P>Allows a program to traverse all fields of a table. Its first argument is a 
table and its second argument is an index in this table. <CODE>next</CODE> 
returns the next index of the table and its associated value. When called with 
<B>nil</B> as its second argument, <CODE>next</CODE> returns an initial index 
and its associated value. When called with the last index, or with <B>nil</B> in 
an empty table, <CODE>next</CODE> returns <B>nil</B>. If the second argument is 
absent, then it is interpreted as <B>nil</B>. In particular, you can use 
<CODE>next(t)</CODE> to check whether a table is empty. 
<P>The order in which the indices are enumerated is not specified, <EM>even for 
numeric indices</EM>. (To traverse a table in numeric order, use a numerical 
<B>for</B> or the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-ipairs"><CODE>ipairs</CODE></A> 
function.) 
<P>The behavior of <CODE>next</CODE> is <EM>undefined</EM> if, during the 
traversal, you assign any value to a non-existent field in the table. You may 
however modify existing fields. In particular, you may clear existing fields. 
<P>
<HR>

<H3><A name=pdf-pairs><CODE>pairs (t)</CODE></A></H3>
<P>Returns three values: the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-next"><CODE>next</CODE></A> 
function, the table <CODE>t</CODE>, and <B>nil</B>, so that the construction <PRE>     for k,v in pairs(t) do <EM>body</EM> end
</PRE>
<P>will iterate over all keyCvalue pairs of table <CODE>t</CODE>. 
<P>See function <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-next"><CODE>next</CODE></A> 
for the caveats of modifying the table during its traversal. 
<P>
<HR>

<H3><A name=pdf-pcall><CODE>pcall (f, arg1, ・・・)</CODE></A></H3>
<P>Calls function <CODE>f</CODE> with the given arguments in <EM>protected 
mode</EM>. This means that any error inside&nbsp;<CODE>f</CODE> is not 
propagated; instead, <CODE>pcall</CODE> catches the error and returns a status 
code. Its first result is the status code (a boolean), which is true if the call 
succeeds without errors. In such case, <CODE>pcall</CODE> also returns all 
results from the call, after this first result. In case of any error, 
<CODE>pcall</CODE> returns <B>false</B> plus the error message. 
<P>
<HR>

<H3><A name=pdf-print><CODE>print (・・・)</CODE></A></H3>Receives any number of 
arguments, and prints their values to <CODE>stdout</CODE>, using the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-tostring"><CODE>tostring</CODE></A> 
function to convert them to strings. <CODE>print</CODE> is not intended for 
formatted output, but only as a quick way to show a value, typically for 
debugging. For formatted output, use <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.format"><CODE>string.format</CODE></A>. 

<P>
<HR>

<H3><A name=pdf-rawequal><CODE>rawequal (v1, v2)</CODE></A></H3>Checks whether 
<CODE>v1</CODE> is equal to <CODE>v2</CODE>, without invoking any metamethod. 
Returns a boolean. 
<P>
<HR>

<H3><A name=pdf-rawget><CODE>rawget (table, index)</CODE></A></H3>Gets the real 
value of <CODE>table[index]</CODE>, without invoking any metamethod. 
<CODE>table</CODE> must be a table; <CODE>index</CODE> may be any value. 
<P>
<HR>

<H3><A name=pdf-rawset><CODE>rawset (table, index, value)</CODE></A></H3>Sets 
the real value of <CODE>table[index]</CODE> to <CODE>value</CODE>, without 
invoking any metamethod. <CODE>table</CODE> must be a table, <CODE>index</CODE> 
any value different from <B>nil</B>, and <CODE>value</CODE> any Lua value. 
<P>This function returns <CODE>table</CODE>. 
<P>
<HR>

<H3><A name=pdf-select><CODE>select (index, ・・・)</CODE></A></H3>
<P>If <CODE>index</CODE> is a number, returns all arguments after argument 
number <CODE>index</CODE>. Otherwise, <CODE>index</CODE> must be the string 
<CODE>"#"</CODE>, and <CODE>select</CODE> returns the total number of extra 
arguments it received. 
<P>
<HR>

<H3><A name=pdf-setfenv><CODE>setfenv (f, table)</CODE></A></H3>
<P>Sets the environment to be used by the given function. <CODE>f</CODE> can be 
a Lua function or a number that specifies the function at that stack level: 
Level&nbsp;1 is the function calling <CODE>setfenv</CODE>. <CODE>setfenv</CODE> 
returns the given function. 
<P>As a special case, when <CODE>f</CODE> is 0 <CODE>setfenv</CODE> changes the 
environment of the running thread. In this case, <CODE>setfenv</CODE> returns no 
values. 
<P>
<HR>

<H3><A name=pdf-setmetatable><CODE>setmetatable (table, 
metatable)</CODE></A></H3>
<P>Sets the metatable for the given table. (You cannot change the metatable of 
other types from Lua, only from&nbsp;C.) If <CODE>metatable</CODE> is 
<B>nil</B>, removes the metatable of the given table. If the original metatable 
has a <CODE>"__metatable"</CODE> field, raises an error. 
<P>This function returns <CODE>table</CODE>. 
<P>
<HR>

<H3><A name=pdf-tonumber><CODE>tonumber (e [, base])</CODE></A></H3>Tries to 
convert its argument to a number. If the argument is already a number or a 
string convertible to a number, then <CODE>tonumber</CODE> returns this number; 
otherwise, it returns <B>nil</B>. 
<P>An optional argument specifies the base to interpret the numeral. The base 
may be any integer between 2 and 36, inclusive. In bases above&nbsp;10, the 
letter '<CODE>A</CODE>' (in either upper or lower case) represents&nbsp;10, 
'<CODE>B</CODE>' represents&nbsp;11, and so forth, with '<CODE>Z</CODE>' 
representing 35. In base 10 (the default), the number may have a decimal part, 
as well as an optional exponent part (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.1">§2.1</A>). In 
other bases, only unsigned integers are accepted. 
<P>
<HR>

<H3><A name=pdf-tostring><CODE>tostring (e)</CODE></A></H3>Receives an argument 
of any type and converts it to a string in a reasonable format. For complete 
control of how numbers are converted, use <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.format"><CODE>string.format</CODE></A>. 

<P>If the metatable of <CODE>e</CODE> has a <CODE>"__tostring"</CODE> field, 
then <CODE>tostring</CODE> calls the corresponding value with <CODE>e</CODE> as 
argument, and uses the result of the call as its result. 
<P>
<HR>

<H3><A name=pdf-type><CODE>type (v)</CODE></A></H3>Returns the type of its only 
argument, coded as a string. The possible results of this function are 
"<CODE>nil</CODE>" (a string, not the value <B>nil</B>), "<CODE>number</CODE>", 
"<CODE>string</CODE>", "<CODE>boolean</CODE>", "<CODE>table</CODE>", 
"<CODE>function</CODE>", "<CODE>thread</CODE>", and "<CODE>userdata</CODE>". 
<P>
<HR>

<H3><A name=pdf-unpack><CODE>unpack (list [, i [, j]])</CODE></A></H3>Returns 
the elements from the given table. This function is equivalent to <PRE>     return list[i], list[i+1], ・・・, list[j]
</PRE>
<P>except that the above code can be written only for a fixed number of 
elements. By default, <CODE>i</CODE> is&nbsp;1 and <CODE>j</CODE> is the length 
of the list, as defined by the length operator (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.5">§2.5.5</A>). 

<P>
<HR>

<H3><A name=pdf-_VERSION><CODE>_VERSION</CODE></A></H3>A global variable (not a 
function) that holds a string containing the current interpreter version. The 
current contents of this variable is "<CODE>Lua 5.1</CODE>". 
<P>
<HR>

<H3><A name=pdf-xpcall><CODE>xpcall (f, err)</CODE></A></H3>
<P>This function is similar to <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-pcall"><CODE>pcall</CODE></A>, 
except that you can set a new error handler. 
<P><CODE>xpcall</CODE> calls function <CODE>f</CODE> in protected mode, using 
<CODE>err</CODE> as the error handler. Any error inside <CODE>f</CODE> is not 
propagated; instead, <CODE>xpcall</CODE> catches the error, calls the 
<CODE>err</CODE> function with the original error object, and returns a status 
code. Its first result is the status code (a boolean), which is true if the call 
succeeds without errors. In this case, <CODE>xpcall</CODE> also returns all 
results from the call, after this first result. In case of any error, 
<CODE>xpcall</CODE> returns <B>false</B> plus the result from <CODE>err</CODE>. 
<H2>5.2 - <A name=5.2>Coroutine Manipulation</A></H2>
<P>The operations related to coroutines comprise a sub-library of the basic 
library and come inside the table <A 
name=pdf-coroutine><CODE>coroutine</CODE></A>. See <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.11">§2.11</A> for 
a general description of coroutines. 
<P>
<HR>

<H3><A name=pdf-coroutine.create><CODE>coroutine.create (f)</CODE></A></H3>
<P>Creates a new coroutine, with body <CODE>f</CODE>. <CODE>f</CODE> must be a 
Lua function. Returns this new coroutine, an object with type 
<CODE>"thread"</CODE>. 
<P>
<HR>

<H3><A name=pdf-coroutine.resume><CODE>coroutine.resume (co [, val1, 
・・・])</CODE></A></H3>
<P>Starts or continues the execution of coroutine <CODE>co</CODE>. The first 
time you resume a coroutine, it starts running its body. The values 
<CODE>val1</CODE>, ・・・ are passed as the arguments to the body function. If the 
coroutine has yielded, <CODE>resume</CODE> restarts it; the values 
<CODE>val1</CODE>, ・・・ are passed as the results from the yield. 
<P>If the coroutine runs without any errors, <CODE>resume</CODE> returns 
<B>true</B> plus any values passed to <CODE>yield</CODE> (if the coroutine 
yields) or any values returned by the body function (if the coroutine 
terminates). If there is any error, <CODE>resume</CODE> returns <B>false</B> 
plus the error message. 
<P>
<HR>

<H3><A name=pdf-coroutine.running><CODE>coroutine.running ()</CODE></A></H3>
<P>Returns the running coroutine, or <B>nil</B> when called by the main thread. 
<P>
<HR>

<H3><A name=pdf-coroutine.status><CODE>coroutine.status (co)</CODE></A></H3>
<P>Returns the status of coroutine <CODE>co</CODE>, as a string: 
<CODE>"running"</CODE>, if the coroutine is running (that is, it called 
<CODE>status</CODE>); <CODE>"suspended"</CODE>, if the coroutine is suspended in 
a call to <CODE>yield</CODE>, or if it has not started running yet; 
<CODE>"normal"</CODE> if the coroutine is active but not running (that is, it 
has resumed another coroutine); and <CODE>"dead"</CODE> if the coroutine has 
finished its body function, or if it has stopped with an error. 
<P>
<HR>

<H3><A name=pdf-coroutine.wrap><CODE>coroutine.wrap (f)</CODE></A></H3>
<P>Creates a new coroutine, with body <CODE>f</CODE>. <CODE>f</CODE> must be a 
Lua function. Returns a function that resumes the coroutine each time it is 
called. Any arguments passed to the function behave as the extra arguments to 
<CODE>resume</CODE>. Returns the same values returned by <CODE>resume</CODE>, 
except the first boolean. In case of error, propagates the error. 
<P>
<HR>

<H3><A name=pdf-coroutine.yield><CODE>coroutine.yield (・・・)</CODE></A></H3>
<P>Suspends the execution of the calling coroutine. The coroutine cannot be 
running a C&nbsp;function, a metamethod, or an iterator. Any arguments to 
<CODE>yield</CODE> are passed as extra results to <CODE>resume</CODE>. 
<H2>5.3 - <A name=5.3>Modules</A></H2>
<P>The package library provides basic facilities for loading and building 
modules in Lua. It exports two of its functions directly in the global 
environment: <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
and <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-module"><CODE>module</CODE></A>. 
Everything else is exported in a table <A 
name=pdf-package><CODE>package</CODE></A>. 
<P>
<HR>

<H3><A name=pdf-module><CODE>module (name [, ・・・])</CODE></A></H3>
<P>Creates a module. If there is a table in <CODE>package.loaded[name]</CODE>, 
this table is the module. Otherwise, if there is a global table <CODE>t</CODE> 
with the given name, this table is the module. Otherwise creates a new table 
<CODE>t</CODE> and sets it as the value of the global <CODE>name</CODE> and the 
value of <CODE>package.loaded[name]</CODE>. This function also initializes 
<CODE>t._NAME</CODE> with the given name, <CODE>t._M</CODE> with the module 
(<CODE>t</CODE> itself), and <CODE>t._PACKAGE</CODE> with the package name (the 
full module name minus last component; see below). Finally, <CODE>module</CODE> 
sets <CODE>t</CODE> as the new environment of the current function and the new 
value of <CODE>package.loaded[name]</CODE>, so that <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
returns <CODE>t</CODE>. 
<P>If <CODE>name</CODE> is a compound name (that is, one with components 
separated by dots), <CODE>module</CODE> creates (or reuses, if they already 
exist) tables for each component. For instance, if <CODE>name</CODE> is 
<CODE>a.b.c</CODE>, then <CODE>module</CODE> stores the module table in field 
<CODE>c</CODE> of field <CODE>b</CODE> of global <CODE>a</CODE>. 
<P>This function may receive optional <EM>options</EM> after the module name, 
where each option is a function to be applied over the module. 
<P>
<HR>

<H3><A name=pdf-require><CODE>require (modname)</CODE></A></H3>
<P>Loads the given module. The function starts by looking into the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.loaded"><CODE>package.loaded</CODE></A> 
table to determine whether <CODE>modname</CODE> is already loaded. If it is, 
then <CODE>require</CODE> returns the value stored at 
<CODE>package.loaded[modname]</CODE>. Otherwise, it tries to find a 
<EM>loader</EM> for the module. 
<P>To find a loader, first <CODE>require</CODE> queries 
<CODE>package.preload[modname]</CODE>. If it has a value, this value (which 
should be a function) is the loader. Otherwise <CODE>require</CODE> searches for 
a Lua loader using the path stored in <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.path"><CODE>package.path</CODE></A>. 
If that also fails, it searches for a C&nbsp;loader using the path stored in <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.cpath"><CODE>package.cpath</CODE></A>. 
If that also fails, it tries an <EM>all-in-one</EM> loader (see below). 
<P>When loading a C&nbsp;library, <CODE>require</CODE> first uses a dynamic link 
facility to link the application with the library. Then it tries to find a 
C&nbsp;function inside this library to be used as the loader. The name of this 
C&nbsp;function is the string "<CODE>luaopen_</CODE>" concatenated with a copy 
of the module name where each dot is replaced by an underscore. Moreover, if the 
module name has a hyphen, its prefix up to (and including) the first hyphen is 
removed. For instance, if the module name is <CODE>a.v1-b.c</CODE>, the function 
name will be <CODE>luaopen_b_c</CODE>. 
<P>If <CODE>require</CODE> finds neither a Lua library nor a C&nbsp;library for 
a module, it calls the <EM>all-in-one loader</EM>. This loader searches the 
C&nbsp;path for a library for the root name of the given module. For instance, 
when requiring <CODE>a.b.c</CODE>, it will search for a C&nbsp;library for 
<CODE>a</CODE>. If found, it looks into it for an open function for the 
submodule; in our example, that would be <CODE>luaopen_a_b_c</CODE>. With this 
facility, a package can pack several C&nbsp;submodules into one single library, 
with each submodule keeping its original open function. 
<P>Once a loader is found, <CODE>require</CODE> calls the loader with a single 
argument, <CODE>modname</CODE>. If the loader returns any value, 
<CODE>require</CODE> assigns the returned value to 
<CODE>package.loaded[modname]</CODE>. If the loader returns no value and has not 
assigned any value to <CODE>package.loaded[modname]</CODE>, then 
<CODE>require</CODE> assigns <B>true</B> to this entry. In any case, 
<CODE>require</CODE> returns the final value of 
<CODE>package.loaded[modname]</CODE>. 
<P>If there is any error loading or running the module, or if it cannot find any 
loader for the module, then <CODE>require</CODE> signals an error. 
<P>
<HR>

<H3><A name=pdf-package.cpath><CODE>package.cpath</CODE></A></H3>
<P>The path used by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
to search for a C&nbsp;loader. 
<P>Lua initializes the C&nbsp;path <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.cpath"><CODE>package.cpath</CODE></A> 
in the same way it initializes the Lua path <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.path"><CODE>package.path</CODE></A>, 
using the environment variable <A name=pdf-LUA_CPATH><CODE>LUA_CPATH</CODE></A> 
(plus another default path defined in <CODE>luaconf.h</CODE>). 
<P>
<HR>

<H3><A name=pdf-package.loaded><CODE>package.loaded</CODE></A></H3>
<P>A table used by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
to control which modules are already loaded. When you require a module 
<CODE>modname</CODE> and <CODE>package.loaded[modname]</CODE> is not false, <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
simply returns the value stored there. 
<P>
<HR>

<H3><A name=pdf-package.loadlib><CODE>package.loadlib (libname, 
funcname)</CODE></A></H3>
<P>Dynamically links the host program with the C&nbsp;library 
<CODE>libname</CODE>. Inside this library, looks for a function 
<CODE>funcname</CODE> and returns this function as a C&nbsp;function. (So, 
<CODE>funcname</CODE> must follow the protocol (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_CFunction"><CODE>lua_CFunction</CODE></A>)). 

<P>This is a low-level function. It completely bypasses the package and module 
system. Unlike <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A>, 
it does not perform any path searching and does not automatically adds 
extensions. <CODE>libname</CODE> must be the complete file name of the 
C&nbsp;library, including if necessary a path and extension. 
<CODE>funcname</CODE> must be the exact name exported by the C&nbsp;library 
(which may depend on the C&nbsp;compiler and linker used). 
<P>This function is not supported by ANSI C. As such, it is only available on 
some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems 
that support the <CODE>dlfcn</CODE> standard). 
<P>
<HR>

<H3><A name=pdf-package.path><CODE>package.path</CODE></A></H3>
<P>The path used by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
to search for a Lua loader. 
<P>At start-up, Lua initializes this variable with the value of the environment 
variable <A name=pdf-LUA_PATH><CODE>LUA_PATH</CODE></A> or with a default path 
defined in <CODE>luaconf.h</CODE>, if the environment variable is not defined. 
Any "<CODE>;;</CODE>" in the value of the environment variable is replaced by 
the default path. 
<P>A path is a sequence of <EM>templates</EM> separated by semicolons. For each 
template, <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
will change each interrogation mark in the template by <CODE>filename</CODE>, 
which is <CODE>modname</CODE> with each dot replaced by a "directory separator" 
(such as "<CODE>/</CODE>" in Unix); then it will try to load the resulting file 
name. So, for instance, if the Lua path is <PRE>     "./?.lua;./?.lc;/usr/local/?/init.lua"
</PRE>
<P>the search for a Lua loader for module <CODE>foo</CODE> will try to load the 
files <CODE>./foo.lua</CODE>, <CODE>./foo.lc</CODE>, and 
<CODE>/usr/local/foo/init.lua</CODE>, in that order. 
<P>
<HR>

<H3><A name=pdf-package.preload><CODE>package.preload</CODE></A></H3>
<P>A table to store loaders for specific modules (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A>). 

<P>
<HR>

<H3><A name=pdf-package.seeall><CODE>package.seeall (module)</CODE></A></H3>
<P>Sets a metatable for <CODE>module</CODE> with its <CODE>__index</CODE> field 
referring to the global environment, so that this module inherits values from 
the global environment. To be used as an option to function <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-module"><CODE>module</CODE></A>. 

<H2>5.4 - <A name=5.4>String Manipulation</A></H2>
<P>This library provides generic functions for string manipulation, such as 
finding and extracting substrings, and pattern matching. When indexing a string 
in Lua, the first character is at position&nbsp;1 (not at&nbsp;0, as in C). 
Indices are allowed to be negative and are interpreted as indexing backwards, 
from the end of the string. Thus, the last character is at position -1, and so 
on. 
<P>The string library provides all its functions inside the table <A 
name=pdf-string><CODE>string</CODE></A>. It also sets a metatable for strings 
where the <CODE>__index</CODE> field points to the <CODE>string</CODE> table. 
Therefore, you can use the string functions in object-oriented style. For 
instance, <CODE>string.byte(s, i)</CODE> can be written as 
<CODE>s:byte(i)</CODE>. 
<P>
<HR>

<H3><A name=pdf-string.byte><CODE>string.byte (s [, i [, 
j]])</CODE></A></H3>Returns the internal numerical codes of the characters 
<CODE>s[i]</CODE>, <CODE>s[i+1]</CODE>, ・・・, <CODE>s[j]</CODE>. The default 
value for <CODE>i</CODE> is&nbsp;1; the default value for <CODE>j</CODE> 
is&nbsp;<CODE>i</CODE>. 
<P>Note that numerical codes are not necessarily portable across platforms. 
<P>
<HR>

<H3><A name=pdf-string.char><CODE>string.char (・・・)</CODE></A></H3>Receives zero 
or more integers. Returns a string with length equal to the number of arguments, 
in which each character has the internal numerical code equal to its 
corresponding argument. 
<P>Note that numerical codes are not necessarily portable across platforms. 
<P>
<HR>

<H3><A name=pdf-string.dump><CODE>string.dump (function)</CODE></A></H3>
<P>Returns a string containing a binary representation of the given function, so 
that a later <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-loadstring"><CODE>loadstring</CODE></A> 
on this string returns a copy of the function. <CODE>function</CODE> must be a 
Lua function without upvalues. 
<P>
<HR>

<H3><A name=pdf-string.find><CODE>string.find (s, pattern [, init [, 
plain]])</CODE></A></H3>Looks for the first match of <CODE>pattern</CODE> in the 
string <CODE>s</CODE>. If it finds a match, then <CODE>find</CODE> returns the 
indices of&nbsp;<CODE>s</CODE> where this occurrence starts and ends; otherwise, 
it returns <B>nil</B>. A third, optional numerical argument <CODE>init</CODE> 
specifies where to start the search; its default value is&nbsp;1 and may be 
negative. A value of <B>true</B> as a fourth, optional argument 
<CODE>plain</CODE> turns off the pattern matching facilities, so the function 
does a plain "find substring" operation, with no characters in 
<CODE>pattern</CODE> being considered "magic". Note that if <CODE>plain</CODE> 
is given, then <CODE>init</CODE> must be given as well. 
<P>If the pattern has captures, then in a successful match the captured values 
are also returned, after the two indices. 
<P>
<HR>

<H3><A name=pdf-string.format><CODE>string.format (formatstring, 
・・・)</CODE></A></H3>Returns a formatted version of its variable number of 
arguments following the description given in its first argument (which must be a 
string). The format string follows the same rules as the <CODE>printf</CODE> 
family of standard C&nbsp;functions. The only differences are that the 
options/modifiers <CODE>*</CODE>, <CODE>l</CODE>, <CODE>L</CODE>, 
<CODE>n</CODE>, <CODE>p</CODE>, and <CODE>h</CODE> are not supported and that 
there is an extra option, <CODE>q</CODE>. The <CODE>q</CODE> option formats a 
string in a form suitable to be safely read back by the Lua interpreter: the 
string is written between double quotes, and all double quotes, newlines, 
embedded zeros, and backslashes in the string are correctly escaped when 
written. For instance, the call <PRE>     string.format('%q', 'a string with "quotes" and \n new line')
</PRE>
<P>will produce the string: <PRE>     "a string with \"quotes\" and \
      new line"
</PRE>
<P>The options <CODE>c</CODE>, <CODE>d</CODE>, <CODE>E</CODE>, <CODE>e</CODE>, 
<CODE>f</CODE>, <CODE>g</CODE>, <CODE>G</CODE>, <CODE>i</CODE>, <CODE>o</CODE>, 
<CODE>u</CODE>, <CODE>X</CODE>, and <CODE>x</CODE> all expect a number as 
argument, whereas <CODE>q</CODE> and <CODE>s</CODE> expect a string. 
<P>This function does not accept string values containing embedded zeros. 
<P>
<HR>

<H3><A name=pdf-string.gmatch><CODE>string.gmatch (s, 
pattern)</CODE></A></H3>Returns an iterator function that, each time it is 
called, returns the next captures from <CODE>pattern</CODE> over string 
<CODE>s</CODE>. 
<P>If <CODE>pattern</CODE> specifies no captures, then the whole match is 
produced in each call. 
<P>As an example, the following loop <PRE>     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</PRE>
<P>will iterate over all the words from string <CODE>s</CODE>, printing one per 
line. The next example collects all pairs <CODE>key=value</CODE> from the given 
string into a table: <PRE>     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</PRE>
<P>
<HR>

<H3><A name=pdf-string.gsub><CODE>string.gsub (s, pattern, repl [, 
n])</CODE></A></H3>Returns a copy of <CODE>s</CODE> in which all occurrences of 
the <CODE>pattern</CODE> have been replaced by a replacement string specified by 
<CODE>repl</CODE>, which may be a string, a table, or a function. 
<CODE>gsub</CODE> also returns, as its second value, the total number of 
substitutions made. 
<P>If <CODE>repl</CODE> is a string, then its value is used for replacement. The 
character&nbsp;<CODE>%</CODE> works as an escape character: any sequence in 
<CODE>repl</CODE> of the form <CODE>%<EM>n</EM></CODE>, with <EM>n</EM> between 
1 and 9, stands for the value of the <EM>n</EM>-th captured substring (see 
below). The sequence <CODE>%0</CODE> stands for the whole match. The sequence 
<CODE>%%</CODE> stands for a single&nbsp;<CODE>%</CODE>. 
<P>If <CODE>repl</CODE> is a table, then the table is queried for every match, 
using the first capture as the key; if the pattern specifies no captures, then 
the whole match is used as the key. 
<P>If <CODE>repl</CODE> is a function, then this function is called every time a 
match occurs, with all captured substrings passed as arguments, in order; if the 
pattern specifies no captures, then the whole match is passed as a sole 
argument. 
<P>If the value returned by the table query or by the function call is a string 
or a number, then it is used as the replacement string; otherwise, if it is 
<B>false</B> or <B>nil</B>, then there is no replacement (that is, the original 
match is kept in the string). 
<P>The optional last parameter <CODE>n</CODE> limits the maximum number of 
substitutions to occur. For instance, when <CODE>n</CODE> is 1 only the first 
occurrence of <CODE>pattern</CODE> is replaced. 
<P>Here are some examples: <PRE>     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.1"}
     x = string.gsub("$name%-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.1.tar.gz"
</PRE>
<P>
<HR>

<H3><A name=pdf-string.len><CODE>string.len (s)</CODE></A></H3>Receives a string 
and returns its length. The empty string <CODE>""</CODE> has length 0. Embedded 
zeros are counted, so <CODE>"a\000bc\000"</CODE> has length 5. 
<P>
<HR>

<H3><A name=pdf-string.lower><CODE>string.lower (s)</CODE></A></H3>Receives a 
string and returns a copy of this string with all uppercase letters changed to 
lowercase. All other characters are left unchanged. The definition of what an 
uppercase letter is depends on the current locale. 
<P>
<HR>

<H3><A name=pdf-string.match><CODE>string.match (s, pattern [, 
init])</CODE></A></H3>Looks for the first <EM>match</EM> of <CODE>pattern</CODE> 
in the string <CODE>s</CODE>. If it finds one, then <CODE>match</CODE> returns 
the captures from the pattern; otherwise it returns <B>nil</B>. If 
<CODE>pattern</CODE> specifies no captures, then the whole match is returned. A 
third, optional numerical argument <CODE>init</CODE> specifies where to start 
the search; its default value is&nbsp;1 and may be negative. 
<P>
<HR>

<H3><A name=pdf-string.rep><CODE>string.rep (s, n)</CODE></A></H3>Returns a 
string that is the concatenation of <CODE>n</CODE> copies of the string 
<CODE>s</CODE>. 
<P>
<HR>

<H3><A name=pdf-string.reverse><CODE>string.reverse (s)</CODE></A></H3>Returns a 
string that is the string <CODE>s</CODE> reversed. 
<P>
<HR>

<H3><A name=pdf-string.sub><CODE>string.sub (s, i [, j])</CODE></A></H3>Returns 
the substring of <CODE>s</CODE> that starts at <CODE>i</CODE> and continues 
until <CODE>j</CODE>; <CODE>i</CODE> and <CODE>j</CODE> may be negative. If 
<CODE>j</CODE> is absent, then it is assumed to be equal to -1 (which is the 
same as the string length). In particular, the call 
<CODE>string.sub(s,1,j)</CODE> returns a prefix of <CODE>s</CODE> with length 
<CODE>j</CODE>, and <CODE>string.sub(s, -i)</CODE> returns a suffix of 
<CODE>s</CODE> with length <CODE>i</CODE>. 
<P>
<HR>

<H3><A name=pdf-string.upper><CODE>string.upper (s)</CODE></A></H3>Receives a 
string and returns a copy of this string with all lowercase letters changed to 
uppercase. All other characters are left unchanged. The definition of what a 
lowercase letter is depends on the current locale. 
<H3>5.4.1 - <A name=5.4.1>Patterns</A></H3>
<H4>Character Class:</H4>
<P>A <EM>character class</EM> is used to represent a set of characters. The 
following combinations are allowed in describing a character class: 
<UL>
  <LI><B><EM>x</EM>:</B> (where <EM>x</EM> is not one of the <EM>magic 
  characters</EM> <CODE>^$()%.[]*+-?</CODE>) represents the character <EM>x</EM> 
  itself. 
  <LI><B><CODE>.</CODE>:</B> (a dot) represents all characters. 
  <LI><B><CODE>%a</CODE>:</B> represents all letters. 
  <LI><B><CODE>%c</CODE>:</B> represents all control characters. 
  <LI><B><CODE>%d</CODE>:</B> represents all digits. 
  <LI><B><CODE>%l</CODE>:</B> represents all lowercase letters. 
  <LI><B><CODE>%p</CODE>:</B> represents all punctuation characters. 
  <LI><B><CODE>%s</CODE>:</B> represents all space characters. 
  <LI><B><CODE>%u</CODE>:</B> represents all uppercase letters. 
  <LI><B><CODE>%w</CODE>:</B> represents all alphanumeric characters. 
  <LI><B><CODE>%x</CODE>:</B> represents all hexadecimal digits. 
  <LI><B><CODE>%z</CODE>:</B> represents the character with representation 0. 
  <LI><B><CODE>%<EM>x</EM></CODE>:</B> (where <EM>x</EM> is any non-alphanumeric 
  character) represents the character <EM>x</EM>. This is the standard way to 
  escape the magic characters. Any punctuation character (even the non magic) 
  can be preceded by a '<CODE>%</CODE>' when used to represent itself in a 
  pattern. 
  <LI><B><CODE>[<EM>set</EM>]</CODE>:</B> represents the class which is the 
  union of all characters in <EM>set</EM>. A range of characters may be 
  specified by separating the end characters of the range with a 
  '<CODE>-</CODE>'. All classes <CODE>%</CODE><EM>x</EM> described above may 
  also be used as components in <EM>set</EM>. All other characters in 
  <EM>set</EM> represent themselves. For example, <CODE>[%w_]</CODE> (or 
  <CODE>[_%w]</CODE>) represents all alphanumeric characters plus the 
  underscore, <CODE>[0-7]</CODE> represents the octal digits, and 
  <CODE>[0-7%l%-]</CODE> represents the octal digits plus the lowercase letters 
  plus the '<CODE>-</CODE>' character. 
  <P>The interaction between ranges and classes is not defined. Therefore, 
  patterns like <CODE>[%a-z]</CODE> or <CODE>[a-%%]</CODE> have no meaning. </P>
  <LI><B><CODE>[^<EM>set</EM>]</CODE>:</B> represents the complement of 
  <EM>set</EM>, where <EM>set</EM> is interpreted as above. </LI></UL>
<P>For all classes represented by single letters (<CODE>%a</CODE>, 
<CODE>%c</CODE>, etc.), the corresponding uppercase letter represents the 
complement of the class. For instance, <CODE>%S</CODE> represents all non-space 
characters. 
<P>The definitions of letter, space, and other character groups depend on the 
current locale. In particular, the class <CODE>[a-z]</CODE> may not be 
equivalent to <CODE>%l</CODE>. 
<H4>Pattern Item:</H4>
<P>A <EM>pattern item</EM> may be 
<UL>
  <LI>a single character class, which matches any single character in the class; 

  <LI>a single character class followed by '<CODE>*</CODE>', which matches 0 or 
  more repetitions of characters in the class. These repetition items will 
  always match the longest possible sequence; 
  <LI>a single character class followed by '<CODE>+</CODE>', which matches 1 or 
  more repetitions of characters in the class. These repetition items will 
  always match the longest possible sequence; 
  <LI>a single character class followed by '<CODE>-</CODE>', which also matches 
  0 or more repetitions of characters in the class. Unlike '<CODE>*</CODE>', 
  these repetition items will always match the <EM>shortest</EM> possible 
  sequence; 
  <LI>a single character class followed by '<CODE>?</CODE>', which matches 0 or 
  1 occurrence of a character in the class; 
  <LI><CODE>%<EM>n</EM></CODE>, for <EM>n</EM> between 1 and 9; such item 
  matches a substring equal to the <EM>n</EM>-th captured string (see below); 
  <LI><CODE>%b<EM>xy</EM></CODE>, where <EM>x</EM> and <EM>y</EM> are two 
  distinct characters; such item matches strings that start 
  with&nbsp;<EM>x</EM>, end with&nbsp;<EM>y</EM>, and where the <EM>x</EM> and 
  <EM>y</EM> are <EM>balanced</EM>. This means that, if one reads the string 
  from left to right, counting <EM>+1</EM> for an <EM>x</EM> and <EM>-1</EM> for 
  a <EM>y</EM>, the ending <EM>y</EM> is the first <EM>y</EM> where the count 
  reaches 0. For instance, the item <CODE>%b()</CODE> matches expressions with 
  balanced parentheses. </LI></UL>
<H4>Pattern:</H4>
<P>A <EM>pattern</EM> is a sequence of pattern items. A '<CODE>^</CODE>' at the 
beginning of a pattern anchors the match at the beginning of the subject string. 
A '<CODE>$</CODE>' at the end of a pattern anchors the match at the end of the 
subject string. At other positions, '<CODE>^</CODE>' and '<CODE>$</CODE>' have 
no special meaning and represent themselves. 
<H4>Captures:</H4>
<P>A pattern may contain sub-patterns enclosed in parentheses; they describe 
<EM>captures</EM>. When a match succeeds, the substrings of the subject string 
that match captures are stored (<EM>captured</EM>) for future use. Captures are 
numbered according to their left parentheses. For instance, in the pattern 
<CODE>"(a*(.)%w(%s*))"</CODE>, the part of the string matching 
<CODE>"a*(.)%w(%s*)"</CODE> is stored as the first capture (and therefore has 
number&nbsp;1); the character matching "<CODE>.</CODE>" is captured with 
number&nbsp;2, and the part matching "<CODE>%s*</CODE>" has number&nbsp;3. 
<P>As a special case, the empty capture <CODE>()</CODE> captures the current 
string position (a number). For instance, if we apply the pattern 
<CODE>"()aa()"</CODE> on the string <CODE>"flaaap"</CODE>, there will be two 
captures: 3&nbsp;and&nbsp;5. 
<P>A pattern cannot contain embedded zeros. Use <CODE>%z</CODE> instead. 
<H2>5.5 - <A name=5.5>Table Manipulation</A></H2>
<P>This library provides generic functions for table manipulation. It provides 
all its functions inside the table <A name=pdf-table><CODE>table</CODE></A>. 
<P>Most functions in the table library assume that the table represents an array 
or a list. For these functions, when we talk about the "length" of a table we 
mean the result of the length operator. 
<P>
<HR>

<H3><A name=pdf-table.concat><CODE>table.concat (table [, sep [, i [, 
j]]])</CODE></A></H3>Given an array where all elements are strings or numbers, 
returns <CODE>table[i]..sep..table[i+1] ・・・ sep..table[j]</CODE>. The default 
value for <CODE>sep</CODE> is the empty string, the default for <CODE>i</CODE> 
is 1, and the default for <CODE>j</CODE> is the length of the table. If 
<CODE>i</CODE> is greater than <CODE>j</CODE>, returns the empty string. 
<P>
<HR>

<H3><A name=pdf-table.insert><CODE>table.insert (table, [pos,] 
value)</CODE></A></H3>
<P>Inserts element <CODE>value</CODE> at position <CODE>pos</CODE> in 
<CODE>table</CODE>, shifting up other elements to open space, if necessary. The 
default value for <CODE>pos</CODE> is <CODE>n+1</CODE>, where <CODE>n</CODE> is 
the length of the table (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#2.5.5">§2.5.5</A>), 
so that a call <CODE>table.insert(t,x)</CODE> inserts <CODE>x</CODE> at the end 
of table <CODE>t</CODE>. 
<P>
<HR>

<H3><A name=pdf-table.maxn><CODE>table.maxn (table)</CODE></A></H3>
<P>Returns the largest positive numerical index of the given table, or zero if 
the table has no positive numerical indices. (To do its job this function does a 
linear traversal of the whole table.) 
<P>
<HR>

<H3><A name=pdf-table.remove><CODE>table.remove (table [, pos])</CODE></A></H3>
<P>Removes from <CODE>table</CODE> the element at position <CODE>pos</CODE>, 
shifting down other elements to close the space, if necessary. Returns the value 
of the removed element. The default value for <CODE>pos</CODE> is 
<CODE>n</CODE>, where <CODE>n</CODE> is the length of the table, so that a call 
<CODE>table.remove(t)</CODE> removes the last element of table <CODE>t</CODE>. 
<P>
<HR>

<H3><A name=pdf-table.sort><CODE>table.sort (table [, 
comp])</CODE></A></H3>Sorts table elements in a given order, <EM>in-place</EM>, 
from <CODE>table[1]</CODE> to <CODE>table[n]</CODE>, where <CODE>n</CODE> is the 
length of the table. If <CODE>comp</CODE> is given, then it must be a function 
that receives two table elements, and returns true when the first is less than 
the second (so that <CODE>not comp(a[i+1],a[i])</CODE> will be true after the 
sort). If <CODE>comp</CODE> is not given, then the standard Lua operator 
<CODE>&lt;</CODE> is used instead. 
<P>The sort algorithm is not stable; that is, elements considered equal by the 
given order may have their relative positions changed by the sort. 
<H2>5.6 - <A name=5.6>Mathematical Functions</A></H2>
<P>This library is an interface to the standard C&nbsp;math library. It provides 
all its functions inside the table <A name=pdf-math><CODE>math</CODE></A>. 
<P>
<HR>

<H3><A name=pdf-math.abs><CODE>math.abs (x)</CODE></A></H3>
<P>Returns the absolute value of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.acos><CODE>math.acos (x)</CODE></A></H3>
<P>Returns the arc cosine of <CODE>x</CODE> (in radians). 
<P>
<HR>

<H3><A name=pdf-math.asin><CODE>math.asin (x)</CODE></A></H3>
<P>Returns the arc sine of <CODE>x</CODE> (in radians). 
<P>
<HR>

<H3><A name=pdf-math.atan><CODE>math.atan (x)</CODE></A></H3>
<P>Returns the arc tangent of <CODE>x</CODE> (in radians). 
<P>
<HR>

<H3><A name=pdf-math.atan2><CODE>math.atan2 (x, y)</CODE></A></H3>
<P>Returns the arc tangent of <CODE>x/y</CODE> (in radians), but uses the signs 
of both parameters to find the quadrant of the result. (It also handles 
correctly the case of <CODE>y</CODE> being zero.) 
<P>
<HR>

<H3><A name=pdf-math.ceil><CODE>math.ceil (x)</CODE></A></H3>
<P>Returns the smallest integer larger than or equal to <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.cos><CODE>math.cos (x)</CODE></A></H3>
<P>Returns the cosine of <CODE>x</CODE> (assumed to be in radians). 
<P>
<HR>

<H3><A name=pdf-math.cosh><CODE>math.cosh (x)</CODE></A></H3>
<P>Returns the hyperbolic cosine of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.deg><CODE>math.deg (x)</CODE></A></H3>
<P>Returns the angle <CODE>x</CODE> (given in radians) in degrees. 
<P>
<HR>

<H3><A name=pdf-math.exp><CODE>math.exp (x)</CODE></A></H3>
<P>Returns the the value <EM>e<SUP>x</SUP></EM>. 
<P>
<HR>

<H3><A name=pdf-math.floor><CODE>math.floor (x)</CODE></A></H3>
<P>Returns the largest integer smaller than or equal to <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.fmod><CODE>math.fmod (x, y)</CODE></A></H3>
<P>Returns the remainder of the division of <CODE>x</CODE> by <CODE>y</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.frexp><CODE>math.frexp (x)</CODE></A></H3>
<P>Returns <CODE>m</CODE> and <CODE>e</CODE> such that <EM>x = 
m2<SUP>e</SUP></EM>, <CODE>e</CODE> is an integer and the absolute value of 
<CODE>m</CODE> is in the range <EM>[0.5, 1)</EM> (or zero when <CODE>x</CODE> is 
zero). 
<P>
<HR>

<H3><A name=pdf-math.huge><CODE>math.huge</CODE></A></H3>
<P>The value <CODE>HUGE_VAL</CODE>, a value larger than or equal to any other 
numerical value. 
<P>
<HR>

<H3><A name=pdf-math.ldexp><CODE>math.ldexp (m, e)</CODE></A></H3>
<P>Returns <EM>m2<SUP>e</SUP></EM> (<CODE>e</CODE> should be an integer). 
<P>
<HR>

<H3><A name=pdf-math.log><CODE>math.log (x)</CODE></A></H3>
<P>Returns the natural logarithm of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.log10><CODE>math.log10 (x)</CODE></A></H3>
<P>Returns the base-10 logarithm of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.max><CODE>math.max (x, ・・・)</CODE></A></H3>
<P>Returns the maximum value among its arguments. 
<P>
<HR>

<H3><A name=pdf-math.min><CODE>math.min (x, ・・・)</CODE></A></H3>
<P>Returns the minimum value among its arguments. 
<P>
<HR>

<H3><A name=pdf-math.modf><CODE>math.modf (x)</CODE></A></H3>
<P>Returns two numbers, the integral part of <CODE>x</CODE> and the fractional 
part of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.pi><CODE>math.pi</CODE></A></H3>
<P>The value of <EM>pi</EM>. 
<P>
<HR>

<H3><A name=pdf-math.pow><CODE>math.pow (x, y)</CODE></A></H3>
<P>Returns <EM>x<SUP>y</SUP></EM>. (You can also use the expression 
<CODE>x^y</CODE> to compute this value.) 
<P>
<HR>

<H3><A name=pdf-math.rad><CODE>math.rad (x)</CODE></A></H3>
<P>Returns the angle <CODE>x</CODE> (given in degrees) in radians. 
<P>
<HR>

<H3><A name=pdf-math.random><CODE>math.random ([m [, n]])</CODE></A></H3>
<P>This function is an interface to the simple pseudo-random generator function 
<CODE>rand</CODE> provided by ANSI&nbsp;C. (No guarantees can be given for its 
statistical properties.) 
<P>When called without arguments, returns a pseudo-random real number in the 
range <EM>[0,1)</EM>. When called with a number <CODE>m</CODE>, 
<CODE>math.random</CODE> returns a pseudo-random integer in the range <EM>[1, 
m]</EM>. When called with two numbers <CODE>m</CODE> and <CODE>n</CODE>, 
<CODE>math.random</CODE> returns a pseudo-random integer in the range <EM>[m, 
n]</EM>. 
<P>
<HR>

<H3><A name=pdf-math.randomseed><CODE>math.randomseed (x)</CODE></A></H3>
<P>Sets <CODE>x</CODE> as the "seed" for the pseudo-random generator: equal 
seeds produce equal sequences of numbers. 
<P>
<HR>

<H3><A name=pdf-math.sin><CODE>math.sin (x)</CODE></A></H3>
<P>Returns the sine of <CODE>x</CODE> (assumed to be in radians). 
<P>
<HR>

<H3><A name=pdf-math.sinh><CODE>math.sinh (x)</CODE></A></H3>
<P>Returns the hyperbolic sine of <CODE>x</CODE>. 
<P>
<HR>

<H3><A name=pdf-math.sqrt><CODE>math.sqrt (x)</CODE></A></H3>
<P>Returns the square root of <CODE>x</CODE>. (You can also use the expression 
<CODE>x^0.5</CODE> to compute this value.) 
<P>
<HR>

<H3><A name=pdf-math.tan><CODE>math.tan (x)</CODE></A></H3>
<P>Returns the tangent of <CODE>x</CODE> (assumed to be in radians). 
<P>
<HR>

<H3><A name=pdf-math.tanh><CODE>math.tanh (x)</CODE></A></H3>
<P>Returns the hyperbolic tangent of <CODE>x</CODE>. 
<H2>5.7 - <A name=5.7>Input and Output Facilities</A></H2>
<P>The I/O library provides two different styles for file manipulation. The 
first one uses implicit file descriptors; that is, there are operations to set a 
default input file and a default output file, and all input/output operations 
are over these default files. The second style uses explicit file descriptors. 
<P>When using implicit file descriptors, all operations are supplied by table <A 
name=pdf-io><CODE>io</CODE></A>. When using explicit file descriptors, the 
operation <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-io.open"><CODE>io.open</CODE></A> 
returns a file descriptor and then all operations are supplied as methods of the 
file descriptor. 
<P>The table <CODE>io</CODE> also provides three predefined file descriptors 
with their usual meanings from C: <A 
name=pdf-io.stdin><CODE>io.stdin</CODE></A>, <A 
name=pdf-io.stdout><CODE>io.stdout</CODE></A>, and <A 
name=pdf-io.stderr><CODE>io.stderr</CODE></A>. 
<P>Unless otherwise stated, all I/O functions return <B>nil</B> on failure (plus 
an error message as a second result) and some value different from <B>nil</B> on 
success. 
<P>
<HR>

<H3><A name=pdf-io.close><CODE>io.close ([file])</CODE></A></H3>
<P>Equivalent to <CODE>file:close()</CODE>. Without a <CODE>file</CODE>, closes 
the default output file. 
<P>
<HR>

<H3><A name=pdf-io.flush><CODE>io.flush ()</CODE></A></H3>
<P>Equivalent to <CODE>file:flush</CODE> over the default output file. 
<P>
<HR>

<H3><A name=pdf-io.input><CODE>io.input ([file])</CODE></A></H3>
<P>When called with a file name, it opens the named file (in text mode), and 
sets its handle as the default input file. When called with a file handle, it 
simply sets this file handle as the default input file. When called without 
parameters, it returns the current default input file. 
<P>In case of errors this function raises the error, instead of returning an 
error code. 
<P>
<HR>

<H3><A name=pdf-io.lines><CODE>io.lines ([filename])</CODE></A></H3>
<P>Opens the given file name in read mode and returns an iterator function that, 
each time it is called, returns a new line from the file. Therefore, the 
construction <PRE>     for line in io.lines(filename) do <EM>body</EM> end
</PRE>
<P>will iterate over all lines of the file. When the iterator function detects 
the end of file, it returns <B>nil</B> (to finish the loop) and automatically 
closes the file. 
<P>The call <CODE>io.lines()</CODE> (with no file name) is equivalent to 
<CODE>io.input():lines()</CODE>; that is, it iterates over the lines of the 
default input file. In this case it does not close the file when the loop ends. 
<P>
<HR>

<H3><A name=pdf-io.open><CODE>io.open (filename [, mode])</CODE></A></H3>
<P>This function opens a file, in the mode specified in the string 
<CODE>mode</CODE>. It returns a new file handle, or, in case of errors, 
<B>nil</B> plus an error message. 
<P>The <CODE>mode</CODE> string can be any of the following: 
<UL>
  <LI><B>"r":</B> read mode (the default); 
  <LI><B>"w":</B> write mode; 
  <LI><B>"a":</B> append mode; 
  <LI><B>"r+":</B> update mode, all previous data is preserved; 
  <LI><B>"w+":</B> update mode, all previous data is erased; 
  <LI><B>"a+":</B> append update mode, previous data is preserved, writing is 
  only allowed at the end of file. </LI></UL>
<P>The <CODE>mode</CODE> string may also have a '<CODE>b</CODE>' at the end, 
which is needed in some systems to open the file in binary mode. This string is 
exactly what is used in the standard&nbsp;C function <CODE>fopen</CODE>. 
<P>
<HR>

<H3><A name=pdf-io.output><CODE>io.output ([file])</CODE></A></H3>
<P>Similar to <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-io.input"><CODE>io.input</CODE></A>, 
but operates over the default output file. 
<P>
<HR>

<H3><A name=pdf-io.popen><CODE>io.popen (prog [, mode])</CODE></A></H3>
<P>Starts program <CODE>prog</CODE> in a separated process and returns a file 
handle that you can use to read data from this program (if <CODE>mode</CODE> is 
<CODE>"r"</CODE>, the default) or to write data to this program (if 
<CODE>mode</CODE> is <CODE>"w"</CODE>). 
<P>This function is system dependent and is not available on all platforms. 
<P>
<HR>

<H3><A name=pdf-io.read><CODE>io.read (・・・)</CODE></A></H3>
<P>Equivalent to <CODE>io.input():read</CODE>. 
<P>
<HR>

<H3><A name=pdf-io.tmpfile><CODE>io.tmpfile ()</CODE></A></H3>
<P>Returns a handle for a temporary file. This file is opened in update mode and 
it is automatically removed when the program ends. 
<P>
<HR>

<H3><A name=pdf-io.type><CODE>io.type (obj)</CODE></A></H3>
<P>Checks whether <CODE>obj</CODE> is a valid file handle. Returns the string 
<CODE>"file"</CODE> if <CODE>obj</CODE> is an open file handle, <CODE>"closed 
file"</CODE> if <CODE>obj</CODE> is a closed file handle, or <B>nil</B> if 
<CODE>obj</CODE> is not a file handle. 
<P>
<HR>

<H3><A name=pdf-io.write><CODE>io.write (・・・)</CODE></A></H3>
<P>Equivalent to <CODE>io.output():write</CODE>. 
<P>
<HR>

<H3><A name=pdf-file:close><CODE>file:close ()</CODE></A></H3>
<P>Closes <CODE>file</CODE>. Note that files are automatically closed when their 
handles are garbage collected, but that takes an unpredictable amount of time to 
happen. 
<P>
<HR>

<H3><A name=pdf-file:flush><CODE>file:flush ()</CODE></A></H3>
<P>Saves any written data to <CODE>file</CODE>. 
<P>
<HR>

<H3><A name=pdf-file:lines><CODE>file:lines ()</CODE></A></H3>
<P>Returns an iterator function that, each time it is called, returns a new line 
from the file. Therefore, the construction <PRE>     for line in file:lines() do <EM>body</EM> end
</PRE>
<P>will iterate over all lines of the file. (Unlike <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-io.lines"><CODE>io.lines</CODE></A>, 
this function does not close the file when the loop ends.) 
<P>
<HR>

<H3><A name=pdf-file:read><CODE>file:read (・・・)</CODE></A></H3>
<P>Reads the file <CODE>file</CODE>, according to the given formats, which 
specify what to read. For each format, the function returns a string (or a 
number) with the characters read, or <B>nil</B> if it cannot read data with the 
specified format. When called without formats, it uses a default format that 
reads the entire next line (see below). 
<P>The available formats are 
<UL>
  <LI><B>"*n":</B> reads a number; this is the only format that returns a number 
  instead of a string. 
  <LI><B>"*a":</B> reads the whole file, starting at the current position. On 
  end of file, it returns the empty string. 
  <LI><B>"*l":</B> reads the next line (skipping the end of line), returning 
  <B>nil</B> on end of file. This is the default format. 
  <LI><B><EM>number</EM>:</B> reads a string with up to this number of 
  characters, returning <B>nil</B> on end of file. If number is zero, it reads 
  nothing and returns an empty string, or <B>nil</B> on end of file. </LI></UL>
<P>
<HR>

<H3><A name=pdf-file:seek><CODE>file:seek ([whence] [, offset])</CODE></A></H3>
<P>Sets and gets the file position, measured from the beginning of the file, to 
the position given by <CODE>offset</CODE> plus a base specified by the string 
<CODE>whence</CODE>, as follows: 
<UL>
  <LI><B>"set":</B> base is position 0 (beginning of the file); 
  <LI><B>"cur":</B> base is current position; 
  <LI><B>"end":</B> base is end of file; </LI></UL>
<P>In case of success, function <CODE>seek</CODE> returns the final file 
position, measured in bytes from the beginning of the file. If this function 
fails, it returns <B>nil</B>, plus a string describing the error. 
<P>The default value for <CODE>whence</CODE> is <CODE>"cur"</CODE>, and for 
<CODE>offset</CODE> is 0. Therefore, the call <CODE>file:seek()</CODE> returns 
the current file position, without changing it; the call 
<CODE>file:seek("set")</CODE> sets the position to the beginning of the file 
(and returns 0); and the call <CODE>file:seek("end")</CODE> sets the position to 
the end of the file, and returns its size. 
<P>
<HR>

<H3><A name=pdf-file:setvbuf><CODE>file:setvbuf (mode [, size])</CODE></A></H3>
<P>Sets the buffering mode for an output file. There are three available modes: 
<UL>
  <LI><B>"no":</B> no buffering; the result of any output operation appears 
  immediately. 
  <LI><B>"full":</B> full buffering; output operation is performed only when the 
  buffer is full (or when you explicitly <CODE>flush</CODE> the file (see <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-io.flush"><CODE>io.flush</CODE></A>)). 

  <LI><B>"line":</B> line buffering; output is buffered until a newline is 
  output or there is any input from some special files (such as a terminal 
  device). </LI></UL>
<P>For the last two cases, <CODE>sizes</CODE> specifies the size of the buffer, 
in bytes. The default is an appropriate size. 
<P>
<HR>

<H3><A name=pdf-file:write><CODE>file:write (・・・)</CODE></A></H3>
<P>Writes the value of each of its arguments to the <CODE>file</CODE>. The 
arguments must be strings or numbers. To write other values, use <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-tostring"><CODE>tostring</CODE></A> 
or <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.format"><CODE>string.format</CODE></A> 
before <CODE>write</CODE>. 
<H2>5.8 - <A name=5.8>Operating System Facilities</A></H2>
<P>This library is implemented through table <A name=pdf-os><CODE>os</CODE></A>. 

<P>
<HR>

<H3><A name=pdf-os.clock><CODE>os.clock ()</CODE></A></H3>
<P>Returns an approximation of the amount in seconds of CPU time used by the 
program. 
<P>
<HR>

<H3><A name=pdf-os.date><CODE>os.date ([format [, time]])</CODE></A></H3>
<P>Returns a string or a table containing date and time, formatted according to 
the given string <CODE>format</CODE>. 
<P>If the <CODE>time</CODE> argument is present, this is the time to be 
formatted (see the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-os.time"><CODE>os.time</CODE></A> 
function for a description of this value). Otherwise, <CODE>date</CODE> formats 
the current time. 
<P>If <CODE>format</CODE> starts with '<CODE>!</CODE>', then the date is 
formatted in Coordinated Universal Time. After this optional character, if 
<CODE>format</CODE> is the string "<CODE>*t</CODE>", then <CODE>date</CODE> 
returns a table with the following fields: <CODE>year</CODE> (four digits), 
<CODE>month</CODE> (1--12), <CODE>day</CODE> (1--31), <CODE>hour</CODE> (0--23), 
<CODE>min</CODE> (0--59), <CODE>sec</CODE> (0--61), <CODE>wday</CODE> (weekday, 
Sunday is&nbsp;1), <CODE>yday</CODE> (day of the year), and <CODE>isdst</CODE> 
(daylight saving flag, a boolean). 
<P>If <CODE>format</CODE> is not "<CODE>*t</CODE>", then <CODE>date</CODE> 
returns the date as a string, formatted according to the same rules as the 
C&nbsp;function <CODE>strftime</CODE>. 
<P>When called without arguments, <CODE>date</CODE> returns a reasonable date 
and time representation that depends on the host system and on the current 
locale (that is, <CODE>os.date()</CODE> is equivalent to 
<CODE>os.date("%c")</CODE>). 
<P>
<HR>

<H3><A name=pdf-os.difftime><CODE>os.difftime (t2, t1)</CODE></A></H3>
<P>Returns the number of seconds from time <CODE>t1</CODE> to time 
<CODE>t2</CODE>. In POSIX, Windows, and some other systems, this value is 
exactly <CODE>t2</CODE><EM>-</EM><CODE>t1</CODE>. 
<P>
<HR>

<H3><A name=pdf-os.execute><CODE>os.execute ([command])</CODE></A></H3>
<P>This function is equivalent to the C&nbsp;function <CODE>system</CODE>. It 
passes <CODE>command</CODE> to be executed by an operating system shell. It 
returns a status code, which is system-dependent. If <CODE>command</CODE> is 
absent, then it returns nonzero if a shell is available and zero otherwise. 
<P>
<HR>

<H3><A name=pdf-os.exit><CODE>os.exit ([code])</CODE></A></H3>
<P>Calls the C&nbsp;function <CODE>exit</CODE>, with an optional 
<CODE>code</CODE>, to terminate the host program. The default value for 
<CODE>code</CODE> is the success code. 
<P>
<HR>

<H3><A name=pdf-os.getenv><CODE>os.getenv (varname)</CODE></A></H3>
<P>Returns the value of the process environment variable <CODE>varname</CODE>, 
or <B>nil</B> if the variable is not defined. 
<P>
<HR>

<H3><A name=pdf-os.remove><CODE>os.remove (filename)</CODE></A></H3>
<P>Deletes the file or directory with the given name. Directories must be empty 
to be removed. If this function fails, it returns <B>nil</B>, plus a string 
describing the error. 
<P>
<HR>

<H3><A name=pdf-os.rename><CODE>os.rename (oldname, newname)</CODE></A></H3>
<P>Renames file or directory named <CODE>oldname</CODE> to <CODE>newname</CODE>. 
If this function fails, it returns <B>nil</B>, plus a string describing the 
error. 
<P>
<HR>

<H3><A name=pdf-os.setlocale><CODE>os.setlocale (locale [, 
category])</CODE></A></H3>
<P>Sets the current locale of the program. <CODE>locale</CODE> is a string 
specifying a locale; <CODE>category</CODE> is an optional string describing 
which category to change: <CODE>"all"</CODE>, <CODE>"collate"</CODE>, 
<CODE>"ctype"</CODE>, <CODE>"monetary"</CODE>, <CODE>"numeric"</CODE>, or 
<CODE>"time"</CODE>; the default category is <CODE>"all"</CODE>. The function 
returns the name of the new locale, or <B>nil</B> if the request cannot be 
honored. 
<P>When called with <B>nil</B> as the first argument, this function only returns 
the name of the current locale for the given category. 
<P>
<HR>

<H3><A name=pdf-os.time><CODE>os.time ([table])</CODE></A></H3>
<P>Returns the current time when called without arguments, or a time 
representing the date and time specified by the given table. This table must 
have fields <CODE>year</CODE>, <CODE>month</CODE>, and <CODE>day</CODE>, and may 
have fields <CODE>hour</CODE>, <CODE>min</CODE>, <CODE>sec</CODE>, and 
<CODE>isdst</CODE> (for a description of these fields, see the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-os.date"><CODE>os.date</CODE></A> 
function). 
<P>The returned value is a number, whose meaning depends on your system. In 
POSIX, Windows, and some other systems, this number counts the number of seconds 
since some given start time (the "epoch"). In other systems, the meaning is not 
specified, and the number returned by <CODE>time</CODE> can be used only as an 
argument to <CODE>date</CODE> and <CODE>difftime</CODE>. 
<P>
<HR>

<H3><A name=pdf-os.tmpname><CODE>os.tmpname ()</CODE></A></H3>
<P>Returns a string with a file name that can be used for a temporary file. The 
file must be explicitly opened before its use and explicitly removed when no 
longer needed. 
<H2>5.9 - <A name=5.9>The Debug Library</A></H2>
<P>This library provides the functionality of the debug interface to Lua 
programs. You should exert care when using this library. The functions provided 
here should be used exclusively for debugging and similar tasks, such as 
profiling. Please resist the temptation to use them as a usual programming tool: 
they can be very slow. Moreover, several of its functions violate some 
assumptions about Lua code (e.g., that variables local to a function cannot be 
accessed from outside or that userdata metatables cannot be changed by Lua code) 
and therefore can compromise otherwise secure code. 
<P>All functions in this library are provided inside the <A 
name=pdf-debug><CODE>debug</CODE></A> table. All functions that operate over a 
thread have an optional first argument which is the thread to operate over. The 
default is always the current thread. 
<P>
<HR>

<H3><A name=pdf-debug.debug><CODE>debug.debug ()</CODE></A></H3>
<P>Enters an interactive mode with the user, running each string that the user 
enters. Using simple commands and other debug facilities, the user can inspect 
global and local variables, change their values, evaluate expressions, and so 
on. A line containing only the word <CODE>cont</CODE> finishes this function, so 
that the caller continues its execution. 
<P>Note that commands for <CODE>debug.debug</CODE> are not lexically nested 
within any function, and so have no direct access to local variables. 
<P>
<HR>

<H3><A name=pdf-debug.getfenv><CODE>debug.getfenv (o)</CODE></A></H3>Returns the 
environment of object <CODE>o</CODE>. 
<P>
<HR>

<H3><A name=pdf-debug.gethook><CODE>debug.gethook ([thread])</CODE></A></H3>
<P>Returns the current hook settings of the thread, as three values: the current 
hook function, the current hook mask, and the current hook count (as set by the 
<A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-debug.sethook"><CODE>debug.sethook</CODE></A> 
function). 
<P>
<HR>

<H3><A name=pdf-debug.getinfo><CODE>debug.getinfo ([thread,] function [, 
what])</CODE></A></H3>
<P>Returns a table with information about a function. You can give the function 
directly, or you can give a number as the value of <CODE>function</CODE>, which 
means the function running at level <CODE>function</CODE> of the call stack of 
the given thread: level&nbsp;0 is the current function (<CODE>getinfo</CODE> 
itself); level&nbsp;1 is the function that called <CODE>getinfo</CODE>; and so 
on. If <CODE>function</CODE> is a number larger than the number of active 
functions, then <CODE>getinfo</CODE> returns <B>nil</B>. 
<P>The returned table may contain all the fields returned by <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#lua_getinfo"><CODE>lua_getinfo</CODE></A>, 
with the string <CODE>what</CODE> describing which fields to fill in. The 
default for <CODE>what</CODE> is to get all information available, except the 
table of valid lines. If present, the option '<CODE>f</CODE>' adds a field named 
<CODE>func</CODE> with the function itself. If present, the option 
'<CODE>L</CODE>' adds a field named <CODE>activelines</CODE> with the table of 
valid lines. 
<P>For instance, the expression <CODE>debug.getinfo(1,"n").name</CODE> returns a 
name of the current function, if a reasonable name can be found, and the 
expression <CODE>debug.getinfo(print)</CODE> returns a table with all available 
information about the <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-print"><CODE>print</CODE></A> 
function. 
<P>
<HR>

<H3><A name=pdf-debug.getlocal><CODE>debug.getlocal ([thread,] level, 
local)</CODE></A></H3>
<P>This function returns the name and the value of the local variable with index 
<CODE>local</CODE> of the function at level <CODE>level</CODE> of the stack. 
(The first parameter or local variable has index&nbsp;1, and so on, until the 
last active local variable.) The function returns <B>nil</B> if there is no 
local variable with the given index, and raises an error when called with a 
<CODE>level</CODE> out of range. (You can call <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-debug.getinfo"><CODE>debug.getinfo</CODE></A> 
to check whether the level is valid.) 
<P>Variable names starting with '<CODE>(</CODE>' (open parentheses) represent 
internal variables (loop control variables, temporaries, and C&nbsp;function 
locals). 
<P>
<HR>

<H3><A name=pdf-debug.getmetatable><CODE>debug.getmetatable 
(object)</CODE></A></H3>
<P>Returns the metatable of the given <CODE>object</CODE> or <B>nil</B> if it 
does not have a metatable. 
<P>
<HR>

<H3><A name=pdf-debug.getregistry><CODE>debug.getregistry ()</CODE></A></H3>
<P>Returns the registry table (see <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#3.5">§3.5</A>). 
<P>
<HR>

<H3><A name=pdf-debug.getupvalue><CODE>debug.getupvalue (func, 
up)</CODE></A></H3>
<P>This function returns the name and the value of the upvalue with index 
<CODE>up</CODE> of the function <CODE>func</CODE>. The function returns 
<B>nil</B> if there is no upvalue with the given index. 
<P>
<HR>

<H3><A name=pdf-debug.setfenv><CODE>debug.setfenv (object, 
table)</CODE></A></H3>
<P>Sets the environment of the given <CODE>object</CODE> to the given 
<CODE>table</CODE>. Returns <CODE>object</CODE>. 
<P>
<HR>

<H3><A name=pdf-debug.sethook><CODE>debug.sethook ([thread,] hook, mask [, 
count])</CODE></A></H3>
<P>Sets the given function as a hook. The string <CODE>mask</CODE> and the 
number <CODE>count</CODE> describe when the hook will be called. The string mask 
may have the following characters, with the given meaning: 
<UL>
  <LI><B><CODE>"c"</CODE>:</B> The hook is called every time Lua calls a 
  function; 
  <LI><B><CODE>"r"</CODE>:</B> The hook is called every time Lua returns from a 
  function; 
  <LI><B><CODE>"l"</CODE>:</B> The hook is called every time Lua enters a new 
  line of code. </LI></UL>
<P>With a <CODE>count</CODE> different from zero, the hook is called after every 
<CODE>count</CODE> instructions. 
<P>When called without arguments, <A 
href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-debug.sethook"><CODE>debug.sethook</CODE></A> 
turns off the hook. 
<P>When the hook is called, its first parameter is a string describing the event 
that has triggered its call: <CODE>"call"</CODE>, <CODE>"return"</CODE> (or 
<CODE>"tail return"</CODE>), <CODE>"line"</CODE>, and <CODE>"count"</CODE>. For 
line events, the hook also gets the new line number as its second parameter. 
Inside a hook, you can call <CODE>getinfo</CODE> with level&nbsp;2 to get more 
information about the running function (level&nbsp;0 is the <CODE>getinfo</CODE> 
function, and level&nbsp;1 is the hook function), unless the event is 
<CODE>"tail return"</CODE>. In this case, Lua is only simulating the return, and 
a call to <CODE>getinfo</CODE> will return invalid data. 
<P>
<HR>

<H3><A name=pdf-debug.setlocal><CODE>debug.setlocal ([thread,] level, local, 
value)</CODE></A></H3>
<P>This function assigns the value <CODE>value</CODE> to the local variable with 
index <CODE>local</CODE> of the function at level <CODE>level</CODE> of the 
stack. The function returns <B>nil</B> if there is no local variable with the 
given index, and raises an error when called with a <CODE>level</CODE> out of 
range. (You can call <CODE>getinfo</CODE> to check whether the level is valid.) 
Otherwise, it returns the name of the local variable. 
<P>
<HR>

<H3><A name=pdf-debug.setmetatable><CODE>debug.setmetatable (object, 
table)</CODE></A></H3>
<P>Sets the metatable for the given <CODE>object</CODE> to the given 
<CODE>table</CODE> (which can be <B>nil</B>). 
<P>
<HR>

<H3><A name=pdf-debug.setupvalue><CODE>debug.setupvalue (func, up, 
value)</CODE></A></H3>
<P>This function assigns the value <CODE>value</CODE> to the upvalue with index 
<CODE>up</CODE> of the function <CODE>func</CODE>. The function returns 
<B>nil</B> if there is no upvalue with the given index. Otherwise, it returns 
the name of the upvalue. 
<P>
<HR>

<H3><A name=pdf-debug.traceback><CODE>debug.traceback ([thread,] [message] [, 
level])</CODE></A></H3>
<P>Returns a string with a traceback of the call stack. An optional 
<CODE>message</CODE> string is appended at the beginning of the traceback. An 
optional <CODE>level</CODE> number tells at which level to start the traceback 
(default is 1, the function calling <CODE>traceback</CODE>). 
<H1>6 - <A name=6>Lua Stand-alone</A></H1>
<P>Although Lua has been designed as an extension language, to be embedded in a 
host C&nbsp;program, it is also frequently used as a stand-alone language. An 
interpreter for Lua as a stand-alone language, called simply <CODE>lua</CODE>, 
is provided with the standard distribution. The stand-alone interpreter includes 
all standard libraries, including the debug library. Its usage is: <PRE>     lua [options] [script [args]]
</PRE>
<P>The options are: 
<UL>
  <LI><B><CODE>-e <EM>stat</EM></CODE>:</B> executes string <EM>stat</EM>; 
  <LI><B><CODE>-l <EM>mod</EM></CODE>:</B> "requires" <EM>mod</EM>; 
  <LI><B><CODE>-i</CODE>:</B> enters interactive mode after running 
  <EM>script</EM>; 
  <LI><B><CODE>-v</CODE>:</B> prints version information; 
  <LI><B><CODE>--</CODE>:</B> stops handling options; 
  <LI><B><CODE>-</CODE>:</B> executes <CODE>stdin</CODE> as a file and stops 
  handling options. </LI></UL>
<P>After handling its options, <CODE>lua</CODE> runs the given <EM>script</EM>, 
passing to it the given <EM>args</EM> as string arguments. When called without 
arguments, <CODE>lua</CODE> behaves as <CODE>lua -v -i</CODE> when the standard 
input (<CODE>stdin</CODE>) is a terminal, and as <CODE>lua -</CODE> otherwise. 
<P>Before running any argument, the interpreter checks for an environment 
variable <A name=pdf-LUA_INIT><CODE>LUA_INIT</CODE></A>. If its format is 
<CODE>@<EM>filename</EM></CODE>, then <CODE>lua</CODE> executes the file. 
Otherwise, <CODE>lua</CODE> executes the string itself. 
<P>All options are handled in order, except <CODE>-i</CODE>. For instance, an 
invocation like <PRE>     $ lua -e'a=1' -e 'print(a)' script.lua
</PRE>
<P>will first set <CODE>a</CODE> to 1, then print the value of <CODE>a</CODE> 
(which is '<CODE>1</CODE>'), and finally run the file <CODE>script.lua</CODE> 
with no arguments. (Here <CODE>$</CODE> is the shell prompt. Your prompt may be 
different.) 
<P>Before starting to run the script, <CODE>lua</CODE> collects all arguments in 
the command line in a global table called <CODE>arg</CODE>. The script name is 
stored at index 0, the first argument after the script name goes to index 1, and 
so on. Any arguments before the script name (that is, the interpreter name plus 
the options) go to negative indices. For instance, in the call <PRE>     $ lua -la b.lua t1 t2
</PRE>
<P>the interpreter first runs the file <CODE>a.lua</CODE>, then creates a table <PRE>     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</PRE>
<P>and finally runs the file <CODE>b.lua</CODE>. The script is called with 
<CODE>arg[1]</CODE>, <CODE>arg[2]</CODE>, ・・・ as arguments; it can also access 
these arguments with the vararg expression '<CODE>...</CODE>'. 
<P>In interactive mode, if you write an incomplete statement, the interpreter 
waits for its completion by issuing a different prompt. 
<P>If the global variable <A name=pdf-_PROMPT><CODE>_PROMPT</CODE></A> contains 
a string, then its value is used as the prompt. Similarly, if the global 
variable <A name=pdf-_PROMPT2><CODE>_PROMPT2</CODE></A> contains a string, its 
value is used as the secondary prompt (issued during incomplete statements). 
Therefore, both prompts can be changed directly on the command line. For 
instance, <PRE>     $ lua -e"_PROMPT='myprompt&gt; '" -i
</PRE>
<P>(the outer pair of quotes is for the shell, the inner pair is for Lua), or in 
any Lua programs by assigning to <CODE>_PROMPT</CODE>. Note the use of 
<CODE>-i</CODE> to enter interactive mode; otherwise, the program would just end 
silently right after the assignment to <CODE>_PROMPT</CODE>. 
<P>To allow the use of Lua as a script interpreter in Unix systems, the 
stand-alone interpreter skips the first line of a chunk if it starts with 
<CODE>#</CODE>. Therefore, Lua scripts can be made into executable programs by 
using <CODE>chmod +x</CODE> and the&nbsp;<CODE>#!</CODE> form, as in <PRE>     #!/usr/local/bin/lua
</PRE>
<P>(Of course, the location of the Lua interpreter may be different in your 
machine. If <CODE>lua</CODE> is in your <CODE>PATH</CODE>, then <PRE>     #!/usr/bin/env lua
</PRE>
<P>is a more portable solution.) 
<H1>7 - <A name=7>Incompatibilities with the Previous Version</A></H1>
<P>Here we list the incompatibilities that you may found when moving a program 
from Lua&nbsp;5.0 to Lua&nbsp;5.1. You can avoid most of the incompatibilities 
compiling Lua with appropriate options (see file <CODE>luaconf.h</CODE>). 
However, all these compatibility options will be removed in the next version of 
Lua. 
<H2>7.1 - <A name=7.1>Changes in the Language</A></H2>
<UL>
  <LI>The vararg system changed from the pseudo-argument <CODE>arg</CODE> with a 
  table with the extra arguments to the vararg expression. (See compile-time 
  option <CODE>LUA_COMPAT_VARARG</CODE> in <CODE>luaconf.h</CODE>.) 
  <LI>There was a subtle change in the scope of the implicit variables of the 
  <B>for</B> statement and for the <B>repeat</B> statement. 
  <LI>The long string/long comment syntax (<CODE>[[<EM>string</EM>]]</CODE>) 
  does not allow nesting. You can use the new syntax 
  (<CODE>[=[<EM>string</EM>]=]</CODE>) in these cases. (See compile-time option 
  <CODE>LUA_COMPAT_LSTR</CODE> in <CODE>luaconf.h</CODE>.) </LI></UL>
<H2>7.2 - <A name=7.2>Changes in the Libraries</A></H2>
<UL>
  <LI>Function <CODE>string.gfind</CODE> was renamed <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.gmatch"><CODE>string.gmatch</CODE></A>. 
  (See compile-time option <CODE>LUA_COMPAT_GFIND</CODE> in 
  <CODE>luaconf.h</CODE>.) 
  <LI>When <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-string.gsub"><CODE>string.gsub</CODE></A> 
  is called with a function as its third argument, whenever this function 
  returns <B>nil</B> or <B>false</B> the replacement string is the whole match, 
  instead of the empty string. 
  <LI>Function <CODE>table.setn</CODE> was deprecated. Function 
  <CODE>table.getn</CODE> corresponds to the new length operator 
  (<CODE>#</CODE>); use the operator instead of the function. (See compile-time 
  option <CODE>LUA_COMPAT_GETN</CODE> in <CODE>luaconf.h</CODE>.) 
  <LI>Function <CODE>loadlib</CODE> was renamed <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.loadlib"><CODE>package.loadlib</CODE></A>. 
  (See compile-time option <CODE>LUA_COMPAT_LOADLIB</CODE> in 
  <CODE>luaconf.h</CODE>.) 
  <LI>Function <CODE>math.mod</CODE> was renamed <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-math.fmod"><CODE>math.fmod</CODE></A>. 
  (See compile-time option <CODE>LUA_COMPAT_MOD</CODE> in 
  <CODE>luaconf.h</CODE>.) 
  <LI>Functions <CODE>table.foreach</CODE> and <CODE>table.foreachi</CODE> are 
  deprecated. You can use a for loop with <CODE>pairs</CODE> or 
  <CODE>ipairs</CODE> instead. 
  <LI>There were substantial changes in function <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-require"><CODE>require</CODE></A> 
  due to the new module system. However, the new behavior is mostly compatible 
  with the old, but <CODE>require</CODE> gets the path from <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-package.path"><CODE>package.path</CODE></A> 
  instead of from <CODE>LUA_PATH</CODE>. 
  <LI>Function <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#pdf-collectgarbage"><CODE>collectgarbage</CODE></A> 
  has different arguments. Function <CODE>gcinfo</CODE> is deprecated; use 
  <CODE>collectgarbage("count")</CODE> instead. </LI></UL>
<H2>7.3 - <A name=7.3>Changes in the API</A></H2>
<UL>
  <LI>The <CODE>luaopen_*</CODE> functions (to open libraries) cannot be called 
  directly, like a regular C function. They must be called through Lua, like a 
  Lua function. 
  <LI>Function <CODE>lua_open</CODE> was replaced by <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#lua_newstate"><CODE>lua_newstate</CODE></A> 
  to allow the user to set a memory-allocation function. You can use <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_newstate"><CODE>luaL_newstate</CODE></A> 
  from the standard library to create a state with a standard allocation 
  function (based on <CODE>realloc</CODE>). 
  <LI>Functions <CODE>luaL_getn</CODE> and <CODE>luaL_setn</CODE> (from the 
  auxiliary library) are deprecated. Use <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#lua_objlen"><CODE>lua_objlen</CODE></A> 
  instead of <CODE>luaL_getn</CODE> and nothing instead of 
  <CODE>luaL_setn</CODE>. 
  <LI>Function <CODE>luaL_openlib</CODE> was replaced by <A 
  href="http://www.codingnow.com/2000/download/lua_manual.html#luaL_register"><CODE>luaL_register</CODE></A>. 

  <LI>Function <CODE>luaL_checkudata</CODE> now throws an error when the given 
  value is not a userdata of the expected type. (In Lua&nbsp;5.0 it returned 
  <CODE>NULL</CODE>.) </LI></UL>
<H1>8 - <A name=8>The Complete Syntax of Lua</A></H1>
<P>Here is the complete syntax of Lua in extended BNF. (It does not describe 
operator precedences.) <PRE>
	chunk ::= {stat [`<B>;</B>&acute;]} [laststat [`<B>;</B>&acute;]]

	block ::= chunk

	stat ::=  varlist1 `<B>=</B>&acute; explist1 | 
		 functioncall | 
		 <B>do</B> block <B>end</B> | 
		 <B>while</B> exp <B>do</B> block <B>end</B> | 
		 <B>repeat</B> block <B>until</B> exp | 
		 <B>if</B> exp <B>then</B> block {<B>elseif</B> exp <B>then</B> block} [<B>else</B> block] <B>end</B> | 
		 <B>for</B> Name `<B>=</B>&acute; exp `<B>,</B>&acute; exp [`<B>,</B>&acute; exp] <B>do</B> block <B>end</B> | 
		 <B>for</B> namelist <B>in</B> explist1 <B>do</B> block <B>end</B> | 
		 <B>function</B> funcname funcbody | 
		 <B>local</B> <B>function</B> Name funcbody | 
		 <B>local</B> namelist [`<B>=</B>&acute; explist1] 

	laststat ::= <B>return</B> [explist1] | <B>break</B>

	funcname ::= Name {`<B>.</B>&acute; Name} [`<B>:</B>&acute; Name]

	varlist1 ::= var {`<B>,</B>&acute; var}

	var ::=  Name | prefixexp `<B>[</B>&acute; exp `<B>]</B>&acute; | prefixexp `<B>.</B>&acute; Name 

	namelist ::= Name {`<B>,</B>&acute; Name}

	explist1 ::= {exp `<B>,</B>&acute;} exp

	exp ::=  <B>nil</B> | <B>false</B> | <B>true</B> | Number | String | `<B>...</B>&acute; | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `<B>(</B>&acute; exp `<B>)</B>&acute;

	functioncall ::=  prefixexp args | prefixexp `<B>:</B>&acute; Name args 

	args ::=  `<B>(</B>&acute; [explist1] `<B>)</B>&acute; | tableconstructor | String 

	function ::= <B>function</B> funcbody

	funcbody ::= `<B>(</B>&acute; [parlist1] `<B>)</B>&acute; block <B>end</B>

	parlist1 ::= namelist [`<B>,</B>&acute; `<B>...</B>&acute;] | `<B>...</B>&acute;

	tableconstructor ::= `<B>{</B>&acute; [fieldlist] `<B>}</B>&acute;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `<B>[</B>&acute; exp `<B>]</B>&acute; `<B>=</B>&acute; exp | Name `<B>=</B>&acute; exp | exp

	fieldsep ::= `<B>,</B>&acute; | `<B>;</B>&acute;

	binop ::= `<B>+</B>&acute; | `<B>-</B>&acute; | `<B>*</B>&acute; | `<B>/</B>&acute; | `<B>^</B>&acute; | `<B>%</B>&acute; | `<B>..</B>&acute; | 
		 `<B>&lt;</B>&acute; | `<B>&lt;=</B>&acute; | `<B>&gt;</B>&acute; | `<B>&gt;=</B>&acute; | `<B>==</B>&acute; | `<B>~=</B>&acute; | 
		 <B>and</B> | <B>or</B>

	unop ::= `<B>-</B>&acute; | <B>not</B> | `<B>#</B>&acute;

</PRE>
<P>
<HR>
<SMALL>Last update: Tue Oct 3 21:27:28 BRT 2006 <BR>译文最后更新：增加一些译注 2006年12月1日 
</SMALL><!--
Last change: minor edit
--></BODY></HTML>
